// DO NOT EDIT!
// Code generated by "github.com/damedic/fhir-toolbox-go/internal/generate";
// use `make generate` to regenerate.

package capabilitiesR4

import (
	"cmp"
	"context"
	"errors"
	"fmt"
	capabilities "github.com/damedic/fhir-toolbox-go/capabilities"
	search "github.com/damedic/fhir-toolbox-go/capabilities/search"
	update "github.com/damedic/fhir-toolbox-go/capabilities/update"
	fhirpath "github.com/damedic/fhir-toolbox-go/fhirpath"
	model "github.com/damedic/fhir-toolbox-go/model"
	r4 "github.com/damedic/fhir-toolbox-go/model/gen/r4"
	ptr "github.com/damedic/fhir-toolbox-go/utils/ptr"
	"reflect"
	"slices"
	"sort"
	"strconv"
	"strings"
)

type Generic struct {
	Concrete capabilities.ConcreteCapabilities[r4.CapabilityStatement]
}

func (w Generic) CapabilityStatement(ctx context.Context) (model.CapabilityStatement, error) {
	gen, ok := w.Concrete.(capabilities.GenericCapabilities)
	if ok {
		// shortcut for the case that the underlying implementation already implements the generic API
		return gen.CapabilityStatement(ctx)
	}
	// Generate CapabilityStatement from concrete implementation
	baseCapabilityStatement, err := w.Concrete.CapabilityBase(ctx)
	if err != nil {
		return nil, err
	}
	var baseUrl string
	if baseCapabilityStatement.Implementation == nil || baseCapabilityStatement.Implementation.Url == nil || baseCapabilityStatement.Implementation.Url.Value == nil {
		return r4.CapabilityStatement{}, fmt.Errorf("base CapabilityStatement must have implementation.url set for canonical SearchParameter references")
	}
	baseUrl = *baseCapabilityStatement.Implementation.Url.Value
	resourcesMap := make(map[string]r4.CapabilityStatementRestResource)
	for _, rest := range baseCapabilityStatement.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil {
				resourcesMap[*resource.Type.Value] = resource
			}
		}
	}
	var errs []error
	addInteraction := func(name string, interactionCode string) r4.CapabilityStatementRestResource {
		r, ok := resourcesMap[name]
		if !ok {
			r = r4.CapabilityStatementRestResource{Type: r4.Code{Value: &name}}
		}
		r.Interaction = append(r.Interaction, r4.CapabilityStatementRestResourceInteraction{Code: r4.Code{Value: ptr.To(interactionCode)}})
		return r
	}
	if _, ok := w.Concrete.(AccountCreate); ok {
		resourcesMap["Account"] = addInteraction("Account", "create")
	}
	if _, ok := w.Concrete.(AccountRead); ok {
		resourcesMap["Account"] = addInteraction("Account", "read")
	}
	if _, ok := w.Concrete.(AccountDelete); ok {
		resourcesMap["Account"] = addInteraction("Account", "delete")
	}
	if c, ok := w.Concrete.(AccountUpdate); ok {
		r := addInteraction("Account", "update")
		c, ok := c.(AccountUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesAccount(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Account"] = r
	}
	if c, ok := w.Concrete.(AccountSearch); ok {
		c, err := c.SearchCapabilitiesAccount(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Account", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Account-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Account"] = r
		}
	}
	if _, ok := w.Concrete.(ActivityDefinitionCreate); ok {
		resourcesMap["ActivityDefinition"] = addInteraction("ActivityDefinition", "create")
	}
	if _, ok := w.Concrete.(ActivityDefinitionRead); ok {
		resourcesMap["ActivityDefinition"] = addInteraction("ActivityDefinition", "read")
	}
	if _, ok := w.Concrete.(ActivityDefinitionDelete); ok {
		resourcesMap["ActivityDefinition"] = addInteraction("ActivityDefinition", "delete")
	}
	if c, ok := w.Concrete.(ActivityDefinitionUpdate); ok {
		r := addInteraction("ActivityDefinition", "update")
		c, ok := c.(ActivityDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesActivityDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ActivityDefinition"] = r
	}
	if c, ok := w.Concrete.(ActivityDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesActivityDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ActivityDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ActivityDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ActivityDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(AdverseEventCreate); ok {
		resourcesMap["AdverseEvent"] = addInteraction("AdverseEvent", "create")
	}
	if _, ok := w.Concrete.(AdverseEventRead); ok {
		resourcesMap["AdverseEvent"] = addInteraction("AdverseEvent", "read")
	}
	if _, ok := w.Concrete.(AdverseEventDelete); ok {
		resourcesMap["AdverseEvent"] = addInteraction("AdverseEvent", "delete")
	}
	if c, ok := w.Concrete.(AdverseEventUpdate); ok {
		r := addInteraction("AdverseEvent", "update")
		c, ok := c.(AdverseEventUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesAdverseEvent(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["AdverseEvent"] = r
	}
	if c, ok := w.Concrete.(AdverseEventSearch); ok {
		c, err := c.SearchCapabilitiesAdverseEvent(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("AdverseEvent", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("AdverseEvent-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["AdverseEvent"] = r
		}
	}
	if _, ok := w.Concrete.(AllergyIntoleranceCreate); ok {
		resourcesMap["AllergyIntolerance"] = addInteraction("AllergyIntolerance", "create")
	}
	if _, ok := w.Concrete.(AllergyIntoleranceRead); ok {
		resourcesMap["AllergyIntolerance"] = addInteraction("AllergyIntolerance", "read")
	}
	if _, ok := w.Concrete.(AllergyIntoleranceDelete); ok {
		resourcesMap["AllergyIntolerance"] = addInteraction("AllergyIntolerance", "delete")
	}
	if c, ok := w.Concrete.(AllergyIntoleranceUpdate); ok {
		r := addInteraction("AllergyIntolerance", "update")
		c, ok := c.(AllergyIntoleranceUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesAllergyIntolerance(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["AllergyIntolerance"] = r
	}
	if c, ok := w.Concrete.(AllergyIntoleranceSearch); ok {
		c, err := c.SearchCapabilitiesAllergyIntolerance(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("AllergyIntolerance", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("AllergyIntolerance-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["AllergyIntolerance"] = r
		}
	}
	if _, ok := w.Concrete.(AppointmentCreate); ok {
		resourcesMap["Appointment"] = addInteraction("Appointment", "create")
	}
	if _, ok := w.Concrete.(AppointmentRead); ok {
		resourcesMap["Appointment"] = addInteraction("Appointment", "read")
	}
	if _, ok := w.Concrete.(AppointmentDelete); ok {
		resourcesMap["Appointment"] = addInteraction("Appointment", "delete")
	}
	if c, ok := w.Concrete.(AppointmentUpdate); ok {
		r := addInteraction("Appointment", "update")
		c, ok := c.(AppointmentUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesAppointment(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Appointment"] = r
	}
	if c, ok := w.Concrete.(AppointmentSearch); ok {
		c, err := c.SearchCapabilitiesAppointment(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Appointment", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Appointment-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Appointment"] = r
		}
	}
	if _, ok := w.Concrete.(AppointmentResponseCreate); ok {
		resourcesMap["AppointmentResponse"] = addInteraction("AppointmentResponse", "create")
	}
	if _, ok := w.Concrete.(AppointmentResponseRead); ok {
		resourcesMap["AppointmentResponse"] = addInteraction("AppointmentResponse", "read")
	}
	if _, ok := w.Concrete.(AppointmentResponseDelete); ok {
		resourcesMap["AppointmentResponse"] = addInteraction("AppointmentResponse", "delete")
	}
	if c, ok := w.Concrete.(AppointmentResponseUpdate); ok {
		r := addInteraction("AppointmentResponse", "update")
		c, ok := c.(AppointmentResponseUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesAppointmentResponse(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["AppointmentResponse"] = r
	}
	if c, ok := w.Concrete.(AppointmentResponseSearch); ok {
		c, err := c.SearchCapabilitiesAppointmentResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("AppointmentResponse", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("AppointmentResponse-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["AppointmentResponse"] = r
		}
	}
	if _, ok := w.Concrete.(AuditEventCreate); ok {
		resourcesMap["AuditEvent"] = addInteraction("AuditEvent", "create")
	}
	if _, ok := w.Concrete.(AuditEventRead); ok {
		resourcesMap["AuditEvent"] = addInteraction("AuditEvent", "read")
	}
	if _, ok := w.Concrete.(AuditEventDelete); ok {
		resourcesMap["AuditEvent"] = addInteraction("AuditEvent", "delete")
	}
	if c, ok := w.Concrete.(AuditEventUpdate); ok {
		r := addInteraction("AuditEvent", "update")
		c, ok := c.(AuditEventUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesAuditEvent(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["AuditEvent"] = r
	}
	if c, ok := w.Concrete.(AuditEventSearch); ok {
		c, err := c.SearchCapabilitiesAuditEvent(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("AuditEvent", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("AuditEvent-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["AuditEvent"] = r
		}
	}
	if _, ok := w.Concrete.(BasicCreate); ok {
		resourcesMap["Basic"] = addInteraction("Basic", "create")
	}
	if _, ok := w.Concrete.(BasicRead); ok {
		resourcesMap["Basic"] = addInteraction("Basic", "read")
	}
	if _, ok := w.Concrete.(BasicDelete); ok {
		resourcesMap["Basic"] = addInteraction("Basic", "delete")
	}
	if c, ok := w.Concrete.(BasicUpdate); ok {
		r := addInteraction("Basic", "update")
		c, ok := c.(BasicUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesBasic(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Basic"] = r
	}
	if c, ok := w.Concrete.(BasicSearch); ok {
		c, err := c.SearchCapabilitiesBasic(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Basic", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Basic-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Basic"] = r
		}
	}
	if _, ok := w.Concrete.(BinaryCreate); ok {
		resourcesMap["Binary"] = addInteraction("Binary", "create")
	}
	if _, ok := w.Concrete.(BinaryRead); ok {
		resourcesMap["Binary"] = addInteraction("Binary", "read")
	}
	if _, ok := w.Concrete.(BinaryDelete); ok {
		resourcesMap["Binary"] = addInteraction("Binary", "delete")
	}
	if c, ok := w.Concrete.(BinaryUpdate); ok {
		r := addInteraction("Binary", "update")
		c, ok := c.(BinaryUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesBinary(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Binary"] = r
	}
	if c, ok := w.Concrete.(BinarySearch); ok {
		c, err := c.SearchCapabilitiesBinary(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Binary", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Binary-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Binary"] = r
		}
	}
	if _, ok := w.Concrete.(BiologicallyDerivedProductCreate); ok {
		resourcesMap["BiologicallyDerivedProduct"] = addInteraction("BiologicallyDerivedProduct", "create")
	}
	if _, ok := w.Concrete.(BiologicallyDerivedProductRead); ok {
		resourcesMap["BiologicallyDerivedProduct"] = addInteraction("BiologicallyDerivedProduct", "read")
	}
	if _, ok := w.Concrete.(BiologicallyDerivedProductDelete); ok {
		resourcesMap["BiologicallyDerivedProduct"] = addInteraction("BiologicallyDerivedProduct", "delete")
	}
	if c, ok := w.Concrete.(BiologicallyDerivedProductUpdate); ok {
		r := addInteraction("BiologicallyDerivedProduct", "update")
		c, ok := c.(BiologicallyDerivedProductUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesBiologicallyDerivedProduct(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["BiologicallyDerivedProduct"] = r
	}
	if c, ok := w.Concrete.(BiologicallyDerivedProductSearch); ok {
		c, err := c.SearchCapabilitiesBiologicallyDerivedProduct(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("BiologicallyDerivedProduct", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("BiologicallyDerivedProduct-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["BiologicallyDerivedProduct"] = r
		}
	}
	if _, ok := w.Concrete.(BodyStructureCreate); ok {
		resourcesMap["BodyStructure"] = addInteraction("BodyStructure", "create")
	}
	if _, ok := w.Concrete.(BodyStructureRead); ok {
		resourcesMap["BodyStructure"] = addInteraction("BodyStructure", "read")
	}
	if _, ok := w.Concrete.(BodyStructureDelete); ok {
		resourcesMap["BodyStructure"] = addInteraction("BodyStructure", "delete")
	}
	if c, ok := w.Concrete.(BodyStructureUpdate); ok {
		r := addInteraction("BodyStructure", "update")
		c, ok := c.(BodyStructureUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesBodyStructure(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["BodyStructure"] = r
	}
	if c, ok := w.Concrete.(BodyStructureSearch); ok {
		c, err := c.SearchCapabilitiesBodyStructure(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("BodyStructure", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("BodyStructure-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["BodyStructure"] = r
		}
	}
	if _, ok := w.Concrete.(BundleCreate); ok {
		resourcesMap["Bundle"] = addInteraction("Bundle", "create")
	}
	if _, ok := w.Concrete.(BundleRead); ok {
		resourcesMap["Bundle"] = addInteraction("Bundle", "read")
	}
	if _, ok := w.Concrete.(BundleDelete); ok {
		resourcesMap["Bundle"] = addInteraction("Bundle", "delete")
	}
	if c, ok := w.Concrete.(BundleUpdate); ok {
		r := addInteraction("Bundle", "update")
		c, ok := c.(BundleUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesBundle(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Bundle"] = r
	}
	if c, ok := w.Concrete.(BundleSearch); ok {
		c, err := c.SearchCapabilitiesBundle(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Bundle", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Bundle-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Bundle"] = r
		}
	}
	if _, ok := w.Concrete.(CapabilityStatementCreate); ok {
		resourcesMap["CapabilityStatement"] = addInteraction("CapabilityStatement", "create")
	}
	if _, ok := w.Concrete.(CapabilityStatementRead); ok {
		resourcesMap["CapabilityStatement"] = addInteraction("CapabilityStatement", "read")
	}
	if _, ok := w.Concrete.(CapabilityStatementDelete); ok {
		resourcesMap["CapabilityStatement"] = addInteraction("CapabilityStatement", "delete")
	}
	if c, ok := w.Concrete.(CapabilityStatementUpdate); ok {
		r := addInteraction("CapabilityStatement", "update")
		c, ok := c.(CapabilityStatementUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCapabilityStatement(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["CapabilityStatement"] = r
	}
	if c, ok := w.Concrete.(CapabilityStatementSearch); ok {
		c, err := c.SearchCapabilitiesCapabilityStatement(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("CapabilityStatement", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("CapabilityStatement-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["CapabilityStatement"] = r
		}
	}
	if _, ok := w.Concrete.(CarePlanCreate); ok {
		resourcesMap["CarePlan"] = addInteraction("CarePlan", "create")
	}
	if _, ok := w.Concrete.(CarePlanRead); ok {
		resourcesMap["CarePlan"] = addInteraction("CarePlan", "read")
	}
	if _, ok := w.Concrete.(CarePlanDelete); ok {
		resourcesMap["CarePlan"] = addInteraction("CarePlan", "delete")
	}
	if c, ok := w.Concrete.(CarePlanUpdate); ok {
		r := addInteraction("CarePlan", "update")
		c, ok := c.(CarePlanUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCarePlan(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["CarePlan"] = r
	}
	if c, ok := w.Concrete.(CarePlanSearch); ok {
		c, err := c.SearchCapabilitiesCarePlan(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("CarePlan", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("CarePlan-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["CarePlan"] = r
		}
	}
	if _, ok := w.Concrete.(CareTeamCreate); ok {
		resourcesMap["CareTeam"] = addInteraction("CareTeam", "create")
	}
	if _, ok := w.Concrete.(CareTeamRead); ok {
		resourcesMap["CareTeam"] = addInteraction("CareTeam", "read")
	}
	if _, ok := w.Concrete.(CareTeamDelete); ok {
		resourcesMap["CareTeam"] = addInteraction("CareTeam", "delete")
	}
	if c, ok := w.Concrete.(CareTeamUpdate); ok {
		r := addInteraction("CareTeam", "update")
		c, ok := c.(CareTeamUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCareTeam(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["CareTeam"] = r
	}
	if c, ok := w.Concrete.(CareTeamSearch); ok {
		c, err := c.SearchCapabilitiesCareTeam(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("CareTeam", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("CareTeam-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["CareTeam"] = r
		}
	}
	if _, ok := w.Concrete.(CatalogEntryCreate); ok {
		resourcesMap["CatalogEntry"] = addInteraction("CatalogEntry", "create")
	}
	if _, ok := w.Concrete.(CatalogEntryRead); ok {
		resourcesMap["CatalogEntry"] = addInteraction("CatalogEntry", "read")
	}
	if _, ok := w.Concrete.(CatalogEntryDelete); ok {
		resourcesMap["CatalogEntry"] = addInteraction("CatalogEntry", "delete")
	}
	if c, ok := w.Concrete.(CatalogEntryUpdate); ok {
		r := addInteraction("CatalogEntry", "update")
		c, ok := c.(CatalogEntryUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCatalogEntry(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["CatalogEntry"] = r
	}
	if c, ok := w.Concrete.(CatalogEntrySearch); ok {
		c, err := c.SearchCapabilitiesCatalogEntry(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("CatalogEntry", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("CatalogEntry-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["CatalogEntry"] = r
		}
	}
	if _, ok := w.Concrete.(ChargeItemCreate); ok {
		resourcesMap["ChargeItem"] = addInteraction("ChargeItem", "create")
	}
	if _, ok := w.Concrete.(ChargeItemRead); ok {
		resourcesMap["ChargeItem"] = addInteraction("ChargeItem", "read")
	}
	if _, ok := w.Concrete.(ChargeItemDelete); ok {
		resourcesMap["ChargeItem"] = addInteraction("ChargeItem", "delete")
	}
	if c, ok := w.Concrete.(ChargeItemUpdate); ok {
		r := addInteraction("ChargeItem", "update")
		c, ok := c.(ChargeItemUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesChargeItem(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ChargeItem"] = r
	}
	if c, ok := w.Concrete.(ChargeItemSearch); ok {
		c, err := c.SearchCapabilitiesChargeItem(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ChargeItem", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ChargeItem-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ChargeItem"] = r
		}
	}
	if _, ok := w.Concrete.(ChargeItemDefinitionCreate); ok {
		resourcesMap["ChargeItemDefinition"] = addInteraction("ChargeItemDefinition", "create")
	}
	if _, ok := w.Concrete.(ChargeItemDefinitionRead); ok {
		resourcesMap["ChargeItemDefinition"] = addInteraction("ChargeItemDefinition", "read")
	}
	if _, ok := w.Concrete.(ChargeItemDefinitionDelete); ok {
		resourcesMap["ChargeItemDefinition"] = addInteraction("ChargeItemDefinition", "delete")
	}
	if c, ok := w.Concrete.(ChargeItemDefinitionUpdate); ok {
		r := addInteraction("ChargeItemDefinition", "update")
		c, ok := c.(ChargeItemDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesChargeItemDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ChargeItemDefinition"] = r
	}
	if c, ok := w.Concrete.(ChargeItemDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesChargeItemDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ChargeItemDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ChargeItemDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ChargeItemDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(ClaimCreate); ok {
		resourcesMap["Claim"] = addInteraction("Claim", "create")
	}
	if _, ok := w.Concrete.(ClaimRead); ok {
		resourcesMap["Claim"] = addInteraction("Claim", "read")
	}
	if _, ok := w.Concrete.(ClaimDelete); ok {
		resourcesMap["Claim"] = addInteraction("Claim", "delete")
	}
	if c, ok := w.Concrete.(ClaimUpdate); ok {
		r := addInteraction("Claim", "update")
		c, ok := c.(ClaimUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesClaim(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Claim"] = r
	}
	if c, ok := w.Concrete.(ClaimSearch); ok {
		c, err := c.SearchCapabilitiesClaim(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Claim", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Claim-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Claim"] = r
		}
	}
	if _, ok := w.Concrete.(ClaimResponseCreate); ok {
		resourcesMap["ClaimResponse"] = addInteraction("ClaimResponse", "create")
	}
	if _, ok := w.Concrete.(ClaimResponseRead); ok {
		resourcesMap["ClaimResponse"] = addInteraction("ClaimResponse", "read")
	}
	if _, ok := w.Concrete.(ClaimResponseDelete); ok {
		resourcesMap["ClaimResponse"] = addInteraction("ClaimResponse", "delete")
	}
	if c, ok := w.Concrete.(ClaimResponseUpdate); ok {
		r := addInteraction("ClaimResponse", "update")
		c, ok := c.(ClaimResponseUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesClaimResponse(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ClaimResponse"] = r
	}
	if c, ok := w.Concrete.(ClaimResponseSearch); ok {
		c, err := c.SearchCapabilitiesClaimResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ClaimResponse", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ClaimResponse-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ClaimResponse"] = r
		}
	}
	if _, ok := w.Concrete.(ClinicalImpressionCreate); ok {
		resourcesMap["ClinicalImpression"] = addInteraction("ClinicalImpression", "create")
	}
	if _, ok := w.Concrete.(ClinicalImpressionRead); ok {
		resourcesMap["ClinicalImpression"] = addInteraction("ClinicalImpression", "read")
	}
	if _, ok := w.Concrete.(ClinicalImpressionDelete); ok {
		resourcesMap["ClinicalImpression"] = addInteraction("ClinicalImpression", "delete")
	}
	if c, ok := w.Concrete.(ClinicalImpressionUpdate); ok {
		r := addInteraction("ClinicalImpression", "update")
		c, ok := c.(ClinicalImpressionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesClinicalImpression(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ClinicalImpression"] = r
	}
	if c, ok := w.Concrete.(ClinicalImpressionSearch); ok {
		c, err := c.SearchCapabilitiesClinicalImpression(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ClinicalImpression", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ClinicalImpression-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ClinicalImpression"] = r
		}
	}
	if _, ok := w.Concrete.(CodeSystemCreate); ok {
		resourcesMap["CodeSystem"] = addInteraction("CodeSystem", "create")
	}
	if _, ok := w.Concrete.(CodeSystemRead); ok {
		resourcesMap["CodeSystem"] = addInteraction("CodeSystem", "read")
	}
	if _, ok := w.Concrete.(CodeSystemDelete); ok {
		resourcesMap["CodeSystem"] = addInteraction("CodeSystem", "delete")
	}
	if c, ok := w.Concrete.(CodeSystemUpdate); ok {
		r := addInteraction("CodeSystem", "update")
		c, ok := c.(CodeSystemUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCodeSystem(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["CodeSystem"] = r
	}
	if c, ok := w.Concrete.(CodeSystemSearch); ok {
		c, err := c.SearchCapabilitiesCodeSystem(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("CodeSystem", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("CodeSystem-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["CodeSystem"] = r
		}
	}
	if _, ok := w.Concrete.(CommunicationCreate); ok {
		resourcesMap["Communication"] = addInteraction("Communication", "create")
	}
	if _, ok := w.Concrete.(CommunicationRead); ok {
		resourcesMap["Communication"] = addInteraction("Communication", "read")
	}
	if _, ok := w.Concrete.(CommunicationDelete); ok {
		resourcesMap["Communication"] = addInteraction("Communication", "delete")
	}
	if c, ok := w.Concrete.(CommunicationUpdate); ok {
		r := addInteraction("Communication", "update")
		c, ok := c.(CommunicationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCommunication(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Communication"] = r
	}
	if c, ok := w.Concrete.(CommunicationSearch); ok {
		c, err := c.SearchCapabilitiesCommunication(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Communication", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Communication-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Communication"] = r
		}
	}
	if _, ok := w.Concrete.(CommunicationRequestCreate); ok {
		resourcesMap["CommunicationRequest"] = addInteraction("CommunicationRequest", "create")
	}
	if _, ok := w.Concrete.(CommunicationRequestRead); ok {
		resourcesMap["CommunicationRequest"] = addInteraction("CommunicationRequest", "read")
	}
	if _, ok := w.Concrete.(CommunicationRequestDelete); ok {
		resourcesMap["CommunicationRequest"] = addInteraction("CommunicationRequest", "delete")
	}
	if c, ok := w.Concrete.(CommunicationRequestUpdate); ok {
		r := addInteraction("CommunicationRequest", "update")
		c, ok := c.(CommunicationRequestUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCommunicationRequest(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["CommunicationRequest"] = r
	}
	if c, ok := w.Concrete.(CommunicationRequestSearch); ok {
		c, err := c.SearchCapabilitiesCommunicationRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("CommunicationRequest", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("CommunicationRequest-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["CommunicationRequest"] = r
		}
	}
	if _, ok := w.Concrete.(CompartmentDefinitionCreate); ok {
		resourcesMap["CompartmentDefinition"] = addInteraction("CompartmentDefinition", "create")
	}
	if _, ok := w.Concrete.(CompartmentDefinitionRead); ok {
		resourcesMap["CompartmentDefinition"] = addInteraction("CompartmentDefinition", "read")
	}
	if _, ok := w.Concrete.(CompartmentDefinitionDelete); ok {
		resourcesMap["CompartmentDefinition"] = addInteraction("CompartmentDefinition", "delete")
	}
	if c, ok := w.Concrete.(CompartmentDefinitionUpdate); ok {
		r := addInteraction("CompartmentDefinition", "update")
		c, ok := c.(CompartmentDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCompartmentDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["CompartmentDefinition"] = r
	}
	if c, ok := w.Concrete.(CompartmentDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesCompartmentDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("CompartmentDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("CompartmentDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["CompartmentDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(CompositionCreate); ok {
		resourcesMap["Composition"] = addInteraction("Composition", "create")
	}
	if _, ok := w.Concrete.(CompositionRead); ok {
		resourcesMap["Composition"] = addInteraction("Composition", "read")
	}
	if _, ok := w.Concrete.(CompositionDelete); ok {
		resourcesMap["Composition"] = addInteraction("Composition", "delete")
	}
	if c, ok := w.Concrete.(CompositionUpdate); ok {
		r := addInteraction("Composition", "update")
		c, ok := c.(CompositionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesComposition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Composition"] = r
	}
	if c, ok := w.Concrete.(CompositionSearch); ok {
		c, err := c.SearchCapabilitiesComposition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Composition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Composition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Composition"] = r
		}
	}
	if _, ok := w.Concrete.(ConceptMapCreate); ok {
		resourcesMap["ConceptMap"] = addInteraction("ConceptMap", "create")
	}
	if _, ok := w.Concrete.(ConceptMapRead); ok {
		resourcesMap["ConceptMap"] = addInteraction("ConceptMap", "read")
	}
	if _, ok := w.Concrete.(ConceptMapDelete); ok {
		resourcesMap["ConceptMap"] = addInteraction("ConceptMap", "delete")
	}
	if c, ok := w.Concrete.(ConceptMapUpdate); ok {
		r := addInteraction("ConceptMap", "update")
		c, ok := c.(ConceptMapUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesConceptMap(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ConceptMap"] = r
	}
	if c, ok := w.Concrete.(ConceptMapSearch); ok {
		c, err := c.SearchCapabilitiesConceptMap(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ConceptMap", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ConceptMap-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ConceptMap"] = r
		}
	}
	if _, ok := w.Concrete.(ConditionCreate); ok {
		resourcesMap["Condition"] = addInteraction("Condition", "create")
	}
	if _, ok := w.Concrete.(ConditionRead); ok {
		resourcesMap["Condition"] = addInteraction("Condition", "read")
	}
	if _, ok := w.Concrete.(ConditionDelete); ok {
		resourcesMap["Condition"] = addInteraction("Condition", "delete")
	}
	if c, ok := w.Concrete.(ConditionUpdate); ok {
		r := addInteraction("Condition", "update")
		c, ok := c.(ConditionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCondition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Condition"] = r
	}
	if c, ok := w.Concrete.(ConditionSearch); ok {
		c, err := c.SearchCapabilitiesCondition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Condition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Condition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Condition"] = r
		}
	}
	if _, ok := w.Concrete.(ConsentCreate); ok {
		resourcesMap["Consent"] = addInteraction("Consent", "create")
	}
	if _, ok := w.Concrete.(ConsentRead); ok {
		resourcesMap["Consent"] = addInteraction("Consent", "read")
	}
	if _, ok := w.Concrete.(ConsentDelete); ok {
		resourcesMap["Consent"] = addInteraction("Consent", "delete")
	}
	if c, ok := w.Concrete.(ConsentUpdate); ok {
		r := addInteraction("Consent", "update")
		c, ok := c.(ConsentUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesConsent(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Consent"] = r
	}
	if c, ok := w.Concrete.(ConsentSearch); ok {
		c, err := c.SearchCapabilitiesConsent(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Consent", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Consent-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Consent"] = r
		}
	}
	if _, ok := w.Concrete.(ContractCreate); ok {
		resourcesMap["Contract"] = addInteraction("Contract", "create")
	}
	if _, ok := w.Concrete.(ContractRead); ok {
		resourcesMap["Contract"] = addInteraction("Contract", "read")
	}
	if _, ok := w.Concrete.(ContractDelete); ok {
		resourcesMap["Contract"] = addInteraction("Contract", "delete")
	}
	if c, ok := w.Concrete.(ContractUpdate); ok {
		r := addInteraction("Contract", "update")
		c, ok := c.(ContractUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesContract(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Contract"] = r
	}
	if c, ok := w.Concrete.(ContractSearch); ok {
		c, err := c.SearchCapabilitiesContract(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Contract", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Contract-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Contract"] = r
		}
	}
	if _, ok := w.Concrete.(CoverageCreate); ok {
		resourcesMap["Coverage"] = addInteraction("Coverage", "create")
	}
	if _, ok := w.Concrete.(CoverageRead); ok {
		resourcesMap["Coverage"] = addInteraction("Coverage", "read")
	}
	if _, ok := w.Concrete.(CoverageDelete); ok {
		resourcesMap["Coverage"] = addInteraction("Coverage", "delete")
	}
	if c, ok := w.Concrete.(CoverageUpdate); ok {
		r := addInteraction("Coverage", "update")
		c, ok := c.(CoverageUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCoverage(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Coverage"] = r
	}
	if c, ok := w.Concrete.(CoverageSearch); ok {
		c, err := c.SearchCapabilitiesCoverage(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Coverage", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Coverage-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Coverage"] = r
		}
	}
	if _, ok := w.Concrete.(CoverageEligibilityRequestCreate); ok {
		resourcesMap["CoverageEligibilityRequest"] = addInteraction("CoverageEligibilityRequest", "create")
	}
	if _, ok := w.Concrete.(CoverageEligibilityRequestRead); ok {
		resourcesMap["CoverageEligibilityRequest"] = addInteraction("CoverageEligibilityRequest", "read")
	}
	if _, ok := w.Concrete.(CoverageEligibilityRequestDelete); ok {
		resourcesMap["CoverageEligibilityRequest"] = addInteraction("CoverageEligibilityRequest", "delete")
	}
	if c, ok := w.Concrete.(CoverageEligibilityRequestUpdate); ok {
		r := addInteraction("CoverageEligibilityRequest", "update")
		c, ok := c.(CoverageEligibilityRequestUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCoverageEligibilityRequest(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["CoverageEligibilityRequest"] = r
	}
	if c, ok := w.Concrete.(CoverageEligibilityRequestSearch); ok {
		c, err := c.SearchCapabilitiesCoverageEligibilityRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("CoverageEligibilityRequest", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("CoverageEligibilityRequest-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["CoverageEligibilityRequest"] = r
		}
	}
	if _, ok := w.Concrete.(CoverageEligibilityResponseCreate); ok {
		resourcesMap["CoverageEligibilityResponse"] = addInteraction("CoverageEligibilityResponse", "create")
	}
	if _, ok := w.Concrete.(CoverageEligibilityResponseRead); ok {
		resourcesMap["CoverageEligibilityResponse"] = addInteraction("CoverageEligibilityResponse", "read")
	}
	if _, ok := w.Concrete.(CoverageEligibilityResponseDelete); ok {
		resourcesMap["CoverageEligibilityResponse"] = addInteraction("CoverageEligibilityResponse", "delete")
	}
	if c, ok := w.Concrete.(CoverageEligibilityResponseUpdate); ok {
		r := addInteraction("CoverageEligibilityResponse", "update")
		c, ok := c.(CoverageEligibilityResponseUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCoverageEligibilityResponse(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["CoverageEligibilityResponse"] = r
	}
	if c, ok := w.Concrete.(CoverageEligibilityResponseSearch); ok {
		c, err := c.SearchCapabilitiesCoverageEligibilityResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("CoverageEligibilityResponse", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("CoverageEligibilityResponse-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["CoverageEligibilityResponse"] = r
		}
	}
	if _, ok := w.Concrete.(DetectedIssueCreate); ok {
		resourcesMap["DetectedIssue"] = addInteraction("DetectedIssue", "create")
	}
	if _, ok := w.Concrete.(DetectedIssueRead); ok {
		resourcesMap["DetectedIssue"] = addInteraction("DetectedIssue", "read")
	}
	if _, ok := w.Concrete.(DetectedIssueDelete); ok {
		resourcesMap["DetectedIssue"] = addInteraction("DetectedIssue", "delete")
	}
	if c, ok := w.Concrete.(DetectedIssueUpdate); ok {
		r := addInteraction("DetectedIssue", "update")
		c, ok := c.(DetectedIssueUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDetectedIssue(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["DetectedIssue"] = r
	}
	if c, ok := w.Concrete.(DetectedIssueSearch); ok {
		c, err := c.SearchCapabilitiesDetectedIssue(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("DetectedIssue", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("DetectedIssue-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["DetectedIssue"] = r
		}
	}
	if _, ok := w.Concrete.(DeviceCreate); ok {
		resourcesMap["Device"] = addInteraction("Device", "create")
	}
	if _, ok := w.Concrete.(DeviceRead); ok {
		resourcesMap["Device"] = addInteraction("Device", "read")
	}
	if _, ok := w.Concrete.(DeviceDelete); ok {
		resourcesMap["Device"] = addInteraction("Device", "delete")
	}
	if c, ok := w.Concrete.(DeviceUpdate); ok {
		r := addInteraction("Device", "update")
		c, ok := c.(DeviceUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDevice(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Device"] = r
	}
	if c, ok := w.Concrete.(DeviceSearch); ok {
		c, err := c.SearchCapabilitiesDevice(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Device", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Device-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Device"] = r
		}
	}
	if _, ok := w.Concrete.(DeviceDefinitionCreate); ok {
		resourcesMap["DeviceDefinition"] = addInteraction("DeviceDefinition", "create")
	}
	if _, ok := w.Concrete.(DeviceDefinitionRead); ok {
		resourcesMap["DeviceDefinition"] = addInteraction("DeviceDefinition", "read")
	}
	if _, ok := w.Concrete.(DeviceDefinitionDelete); ok {
		resourcesMap["DeviceDefinition"] = addInteraction("DeviceDefinition", "delete")
	}
	if c, ok := w.Concrete.(DeviceDefinitionUpdate); ok {
		r := addInteraction("DeviceDefinition", "update")
		c, ok := c.(DeviceDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDeviceDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["DeviceDefinition"] = r
	}
	if c, ok := w.Concrete.(DeviceDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesDeviceDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("DeviceDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("DeviceDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["DeviceDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(DeviceMetricCreate); ok {
		resourcesMap["DeviceMetric"] = addInteraction("DeviceMetric", "create")
	}
	if _, ok := w.Concrete.(DeviceMetricRead); ok {
		resourcesMap["DeviceMetric"] = addInteraction("DeviceMetric", "read")
	}
	if _, ok := w.Concrete.(DeviceMetricDelete); ok {
		resourcesMap["DeviceMetric"] = addInteraction("DeviceMetric", "delete")
	}
	if c, ok := w.Concrete.(DeviceMetricUpdate); ok {
		r := addInteraction("DeviceMetric", "update")
		c, ok := c.(DeviceMetricUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDeviceMetric(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["DeviceMetric"] = r
	}
	if c, ok := w.Concrete.(DeviceMetricSearch); ok {
		c, err := c.SearchCapabilitiesDeviceMetric(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("DeviceMetric", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("DeviceMetric-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["DeviceMetric"] = r
		}
	}
	if _, ok := w.Concrete.(DeviceRequestCreate); ok {
		resourcesMap["DeviceRequest"] = addInteraction("DeviceRequest", "create")
	}
	if _, ok := w.Concrete.(DeviceRequestRead); ok {
		resourcesMap["DeviceRequest"] = addInteraction("DeviceRequest", "read")
	}
	if _, ok := w.Concrete.(DeviceRequestDelete); ok {
		resourcesMap["DeviceRequest"] = addInteraction("DeviceRequest", "delete")
	}
	if c, ok := w.Concrete.(DeviceRequestUpdate); ok {
		r := addInteraction("DeviceRequest", "update")
		c, ok := c.(DeviceRequestUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDeviceRequest(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["DeviceRequest"] = r
	}
	if c, ok := w.Concrete.(DeviceRequestSearch); ok {
		c, err := c.SearchCapabilitiesDeviceRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("DeviceRequest", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("DeviceRequest-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["DeviceRequest"] = r
		}
	}
	if _, ok := w.Concrete.(DeviceUseStatementCreate); ok {
		resourcesMap["DeviceUseStatement"] = addInteraction("DeviceUseStatement", "create")
	}
	if _, ok := w.Concrete.(DeviceUseStatementRead); ok {
		resourcesMap["DeviceUseStatement"] = addInteraction("DeviceUseStatement", "read")
	}
	if _, ok := w.Concrete.(DeviceUseStatementDelete); ok {
		resourcesMap["DeviceUseStatement"] = addInteraction("DeviceUseStatement", "delete")
	}
	if c, ok := w.Concrete.(DeviceUseStatementUpdate); ok {
		r := addInteraction("DeviceUseStatement", "update")
		c, ok := c.(DeviceUseStatementUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDeviceUseStatement(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["DeviceUseStatement"] = r
	}
	if c, ok := w.Concrete.(DeviceUseStatementSearch); ok {
		c, err := c.SearchCapabilitiesDeviceUseStatement(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("DeviceUseStatement", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("DeviceUseStatement-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["DeviceUseStatement"] = r
		}
	}
	if _, ok := w.Concrete.(DiagnosticReportCreate); ok {
		resourcesMap["DiagnosticReport"] = addInteraction("DiagnosticReport", "create")
	}
	if _, ok := w.Concrete.(DiagnosticReportRead); ok {
		resourcesMap["DiagnosticReport"] = addInteraction("DiagnosticReport", "read")
	}
	if _, ok := w.Concrete.(DiagnosticReportDelete); ok {
		resourcesMap["DiagnosticReport"] = addInteraction("DiagnosticReport", "delete")
	}
	if c, ok := w.Concrete.(DiagnosticReportUpdate); ok {
		r := addInteraction("DiagnosticReport", "update")
		c, ok := c.(DiagnosticReportUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDiagnosticReport(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["DiagnosticReport"] = r
	}
	if c, ok := w.Concrete.(DiagnosticReportSearch); ok {
		c, err := c.SearchCapabilitiesDiagnosticReport(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("DiagnosticReport", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("DiagnosticReport-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["DiagnosticReport"] = r
		}
	}
	if _, ok := w.Concrete.(DocumentManifestCreate); ok {
		resourcesMap["DocumentManifest"] = addInteraction("DocumentManifest", "create")
	}
	if _, ok := w.Concrete.(DocumentManifestRead); ok {
		resourcesMap["DocumentManifest"] = addInteraction("DocumentManifest", "read")
	}
	if _, ok := w.Concrete.(DocumentManifestDelete); ok {
		resourcesMap["DocumentManifest"] = addInteraction("DocumentManifest", "delete")
	}
	if c, ok := w.Concrete.(DocumentManifestUpdate); ok {
		r := addInteraction("DocumentManifest", "update")
		c, ok := c.(DocumentManifestUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDocumentManifest(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["DocumentManifest"] = r
	}
	if c, ok := w.Concrete.(DocumentManifestSearch); ok {
		c, err := c.SearchCapabilitiesDocumentManifest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("DocumentManifest", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("DocumentManifest-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["DocumentManifest"] = r
		}
	}
	if _, ok := w.Concrete.(DocumentReferenceCreate); ok {
		resourcesMap["DocumentReference"] = addInteraction("DocumentReference", "create")
	}
	if _, ok := w.Concrete.(DocumentReferenceRead); ok {
		resourcesMap["DocumentReference"] = addInteraction("DocumentReference", "read")
	}
	if _, ok := w.Concrete.(DocumentReferenceDelete); ok {
		resourcesMap["DocumentReference"] = addInteraction("DocumentReference", "delete")
	}
	if c, ok := w.Concrete.(DocumentReferenceUpdate); ok {
		r := addInteraction("DocumentReference", "update")
		c, ok := c.(DocumentReferenceUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDocumentReference(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["DocumentReference"] = r
	}
	if c, ok := w.Concrete.(DocumentReferenceSearch); ok {
		c, err := c.SearchCapabilitiesDocumentReference(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("DocumentReference", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("DocumentReference-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["DocumentReference"] = r
		}
	}
	if _, ok := w.Concrete.(EffectEvidenceSynthesisCreate); ok {
		resourcesMap["EffectEvidenceSynthesis"] = addInteraction("EffectEvidenceSynthesis", "create")
	}
	if _, ok := w.Concrete.(EffectEvidenceSynthesisRead); ok {
		resourcesMap["EffectEvidenceSynthesis"] = addInteraction("EffectEvidenceSynthesis", "read")
	}
	if _, ok := w.Concrete.(EffectEvidenceSynthesisDelete); ok {
		resourcesMap["EffectEvidenceSynthesis"] = addInteraction("EffectEvidenceSynthesis", "delete")
	}
	if c, ok := w.Concrete.(EffectEvidenceSynthesisUpdate); ok {
		r := addInteraction("EffectEvidenceSynthesis", "update")
		c, ok := c.(EffectEvidenceSynthesisUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEffectEvidenceSynthesis(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["EffectEvidenceSynthesis"] = r
	}
	if c, ok := w.Concrete.(EffectEvidenceSynthesisSearch); ok {
		c, err := c.SearchCapabilitiesEffectEvidenceSynthesis(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("EffectEvidenceSynthesis", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("EffectEvidenceSynthesis-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["EffectEvidenceSynthesis"] = r
		}
	}
	if _, ok := w.Concrete.(EncounterCreate); ok {
		resourcesMap["Encounter"] = addInteraction("Encounter", "create")
	}
	if _, ok := w.Concrete.(EncounterRead); ok {
		resourcesMap["Encounter"] = addInteraction("Encounter", "read")
	}
	if _, ok := w.Concrete.(EncounterDelete); ok {
		resourcesMap["Encounter"] = addInteraction("Encounter", "delete")
	}
	if c, ok := w.Concrete.(EncounterUpdate); ok {
		r := addInteraction("Encounter", "update")
		c, ok := c.(EncounterUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEncounter(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Encounter"] = r
	}
	if c, ok := w.Concrete.(EncounterSearch); ok {
		c, err := c.SearchCapabilitiesEncounter(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Encounter", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Encounter-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Encounter"] = r
		}
	}
	if _, ok := w.Concrete.(EndpointCreate); ok {
		resourcesMap["Endpoint"] = addInteraction("Endpoint", "create")
	}
	if _, ok := w.Concrete.(EndpointRead); ok {
		resourcesMap["Endpoint"] = addInteraction("Endpoint", "read")
	}
	if _, ok := w.Concrete.(EndpointDelete); ok {
		resourcesMap["Endpoint"] = addInteraction("Endpoint", "delete")
	}
	if c, ok := w.Concrete.(EndpointUpdate); ok {
		r := addInteraction("Endpoint", "update")
		c, ok := c.(EndpointUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEndpoint(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Endpoint"] = r
	}
	if c, ok := w.Concrete.(EndpointSearch); ok {
		c, err := c.SearchCapabilitiesEndpoint(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Endpoint", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Endpoint-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Endpoint"] = r
		}
	}
	if _, ok := w.Concrete.(EnrollmentRequestCreate); ok {
		resourcesMap["EnrollmentRequest"] = addInteraction("EnrollmentRequest", "create")
	}
	if _, ok := w.Concrete.(EnrollmentRequestRead); ok {
		resourcesMap["EnrollmentRequest"] = addInteraction("EnrollmentRequest", "read")
	}
	if _, ok := w.Concrete.(EnrollmentRequestDelete); ok {
		resourcesMap["EnrollmentRequest"] = addInteraction("EnrollmentRequest", "delete")
	}
	if c, ok := w.Concrete.(EnrollmentRequestUpdate); ok {
		r := addInteraction("EnrollmentRequest", "update")
		c, ok := c.(EnrollmentRequestUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEnrollmentRequest(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["EnrollmentRequest"] = r
	}
	if c, ok := w.Concrete.(EnrollmentRequestSearch); ok {
		c, err := c.SearchCapabilitiesEnrollmentRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("EnrollmentRequest", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("EnrollmentRequest-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["EnrollmentRequest"] = r
		}
	}
	if _, ok := w.Concrete.(EnrollmentResponseCreate); ok {
		resourcesMap["EnrollmentResponse"] = addInteraction("EnrollmentResponse", "create")
	}
	if _, ok := w.Concrete.(EnrollmentResponseRead); ok {
		resourcesMap["EnrollmentResponse"] = addInteraction("EnrollmentResponse", "read")
	}
	if _, ok := w.Concrete.(EnrollmentResponseDelete); ok {
		resourcesMap["EnrollmentResponse"] = addInteraction("EnrollmentResponse", "delete")
	}
	if c, ok := w.Concrete.(EnrollmentResponseUpdate); ok {
		r := addInteraction("EnrollmentResponse", "update")
		c, ok := c.(EnrollmentResponseUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEnrollmentResponse(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["EnrollmentResponse"] = r
	}
	if c, ok := w.Concrete.(EnrollmentResponseSearch); ok {
		c, err := c.SearchCapabilitiesEnrollmentResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("EnrollmentResponse", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("EnrollmentResponse-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["EnrollmentResponse"] = r
		}
	}
	if _, ok := w.Concrete.(EpisodeOfCareCreate); ok {
		resourcesMap["EpisodeOfCare"] = addInteraction("EpisodeOfCare", "create")
	}
	if _, ok := w.Concrete.(EpisodeOfCareRead); ok {
		resourcesMap["EpisodeOfCare"] = addInteraction("EpisodeOfCare", "read")
	}
	if _, ok := w.Concrete.(EpisodeOfCareDelete); ok {
		resourcesMap["EpisodeOfCare"] = addInteraction("EpisodeOfCare", "delete")
	}
	if c, ok := w.Concrete.(EpisodeOfCareUpdate); ok {
		r := addInteraction("EpisodeOfCare", "update")
		c, ok := c.(EpisodeOfCareUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEpisodeOfCare(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["EpisodeOfCare"] = r
	}
	if c, ok := w.Concrete.(EpisodeOfCareSearch); ok {
		c, err := c.SearchCapabilitiesEpisodeOfCare(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("EpisodeOfCare", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("EpisodeOfCare-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["EpisodeOfCare"] = r
		}
	}
	if _, ok := w.Concrete.(EventDefinitionCreate); ok {
		resourcesMap["EventDefinition"] = addInteraction("EventDefinition", "create")
	}
	if _, ok := w.Concrete.(EventDefinitionRead); ok {
		resourcesMap["EventDefinition"] = addInteraction("EventDefinition", "read")
	}
	if _, ok := w.Concrete.(EventDefinitionDelete); ok {
		resourcesMap["EventDefinition"] = addInteraction("EventDefinition", "delete")
	}
	if c, ok := w.Concrete.(EventDefinitionUpdate); ok {
		r := addInteraction("EventDefinition", "update")
		c, ok := c.(EventDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEventDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["EventDefinition"] = r
	}
	if c, ok := w.Concrete.(EventDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesEventDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("EventDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("EventDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["EventDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(EvidenceCreate); ok {
		resourcesMap["Evidence"] = addInteraction("Evidence", "create")
	}
	if _, ok := w.Concrete.(EvidenceRead); ok {
		resourcesMap["Evidence"] = addInteraction("Evidence", "read")
	}
	if _, ok := w.Concrete.(EvidenceDelete); ok {
		resourcesMap["Evidence"] = addInteraction("Evidence", "delete")
	}
	if c, ok := w.Concrete.(EvidenceUpdate); ok {
		r := addInteraction("Evidence", "update")
		c, ok := c.(EvidenceUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEvidence(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Evidence"] = r
	}
	if c, ok := w.Concrete.(EvidenceSearch); ok {
		c, err := c.SearchCapabilitiesEvidence(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Evidence", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Evidence-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Evidence"] = r
		}
	}
	if _, ok := w.Concrete.(EvidenceVariableCreate); ok {
		resourcesMap["EvidenceVariable"] = addInteraction("EvidenceVariable", "create")
	}
	if _, ok := w.Concrete.(EvidenceVariableRead); ok {
		resourcesMap["EvidenceVariable"] = addInteraction("EvidenceVariable", "read")
	}
	if _, ok := w.Concrete.(EvidenceVariableDelete); ok {
		resourcesMap["EvidenceVariable"] = addInteraction("EvidenceVariable", "delete")
	}
	if c, ok := w.Concrete.(EvidenceVariableUpdate); ok {
		r := addInteraction("EvidenceVariable", "update")
		c, ok := c.(EvidenceVariableUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEvidenceVariable(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["EvidenceVariable"] = r
	}
	if c, ok := w.Concrete.(EvidenceVariableSearch); ok {
		c, err := c.SearchCapabilitiesEvidenceVariable(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("EvidenceVariable", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("EvidenceVariable-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["EvidenceVariable"] = r
		}
	}
	if _, ok := w.Concrete.(ExampleScenarioCreate); ok {
		resourcesMap["ExampleScenario"] = addInteraction("ExampleScenario", "create")
	}
	if _, ok := w.Concrete.(ExampleScenarioRead); ok {
		resourcesMap["ExampleScenario"] = addInteraction("ExampleScenario", "read")
	}
	if _, ok := w.Concrete.(ExampleScenarioDelete); ok {
		resourcesMap["ExampleScenario"] = addInteraction("ExampleScenario", "delete")
	}
	if c, ok := w.Concrete.(ExampleScenarioUpdate); ok {
		r := addInteraction("ExampleScenario", "update")
		c, ok := c.(ExampleScenarioUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesExampleScenario(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ExampleScenario"] = r
	}
	if c, ok := w.Concrete.(ExampleScenarioSearch); ok {
		c, err := c.SearchCapabilitiesExampleScenario(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ExampleScenario", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ExampleScenario-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ExampleScenario"] = r
		}
	}
	if _, ok := w.Concrete.(ExplanationOfBenefitCreate); ok {
		resourcesMap["ExplanationOfBenefit"] = addInteraction("ExplanationOfBenefit", "create")
	}
	if _, ok := w.Concrete.(ExplanationOfBenefitRead); ok {
		resourcesMap["ExplanationOfBenefit"] = addInteraction("ExplanationOfBenefit", "read")
	}
	if _, ok := w.Concrete.(ExplanationOfBenefitDelete); ok {
		resourcesMap["ExplanationOfBenefit"] = addInteraction("ExplanationOfBenefit", "delete")
	}
	if c, ok := w.Concrete.(ExplanationOfBenefitUpdate); ok {
		r := addInteraction("ExplanationOfBenefit", "update")
		c, ok := c.(ExplanationOfBenefitUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesExplanationOfBenefit(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ExplanationOfBenefit"] = r
	}
	if c, ok := w.Concrete.(ExplanationOfBenefitSearch); ok {
		c, err := c.SearchCapabilitiesExplanationOfBenefit(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ExplanationOfBenefit", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ExplanationOfBenefit-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ExplanationOfBenefit"] = r
		}
	}
	if _, ok := w.Concrete.(FamilyMemberHistoryCreate); ok {
		resourcesMap["FamilyMemberHistory"] = addInteraction("FamilyMemberHistory", "create")
	}
	if _, ok := w.Concrete.(FamilyMemberHistoryRead); ok {
		resourcesMap["FamilyMemberHistory"] = addInteraction("FamilyMemberHistory", "read")
	}
	if _, ok := w.Concrete.(FamilyMemberHistoryDelete); ok {
		resourcesMap["FamilyMemberHistory"] = addInteraction("FamilyMemberHistory", "delete")
	}
	if c, ok := w.Concrete.(FamilyMemberHistoryUpdate); ok {
		r := addInteraction("FamilyMemberHistory", "update")
		c, ok := c.(FamilyMemberHistoryUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesFamilyMemberHistory(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["FamilyMemberHistory"] = r
	}
	if c, ok := w.Concrete.(FamilyMemberHistorySearch); ok {
		c, err := c.SearchCapabilitiesFamilyMemberHistory(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("FamilyMemberHistory", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("FamilyMemberHistory-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["FamilyMemberHistory"] = r
		}
	}
	if _, ok := w.Concrete.(FlagCreate); ok {
		resourcesMap["Flag"] = addInteraction("Flag", "create")
	}
	if _, ok := w.Concrete.(FlagRead); ok {
		resourcesMap["Flag"] = addInteraction("Flag", "read")
	}
	if _, ok := w.Concrete.(FlagDelete); ok {
		resourcesMap["Flag"] = addInteraction("Flag", "delete")
	}
	if c, ok := w.Concrete.(FlagUpdate); ok {
		r := addInteraction("Flag", "update")
		c, ok := c.(FlagUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesFlag(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Flag"] = r
	}
	if c, ok := w.Concrete.(FlagSearch); ok {
		c, err := c.SearchCapabilitiesFlag(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Flag", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Flag-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Flag"] = r
		}
	}
	if _, ok := w.Concrete.(GoalCreate); ok {
		resourcesMap["Goal"] = addInteraction("Goal", "create")
	}
	if _, ok := w.Concrete.(GoalRead); ok {
		resourcesMap["Goal"] = addInteraction("Goal", "read")
	}
	if _, ok := w.Concrete.(GoalDelete); ok {
		resourcesMap["Goal"] = addInteraction("Goal", "delete")
	}
	if c, ok := w.Concrete.(GoalUpdate); ok {
		r := addInteraction("Goal", "update")
		c, ok := c.(GoalUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesGoal(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Goal"] = r
	}
	if c, ok := w.Concrete.(GoalSearch); ok {
		c, err := c.SearchCapabilitiesGoal(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Goal", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Goal-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Goal"] = r
		}
	}
	if _, ok := w.Concrete.(GraphDefinitionCreate); ok {
		resourcesMap["GraphDefinition"] = addInteraction("GraphDefinition", "create")
	}
	if _, ok := w.Concrete.(GraphDefinitionRead); ok {
		resourcesMap["GraphDefinition"] = addInteraction("GraphDefinition", "read")
	}
	if _, ok := w.Concrete.(GraphDefinitionDelete); ok {
		resourcesMap["GraphDefinition"] = addInteraction("GraphDefinition", "delete")
	}
	if c, ok := w.Concrete.(GraphDefinitionUpdate); ok {
		r := addInteraction("GraphDefinition", "update")
		c, ok := c.(GraphDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesGraphDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["GraphDefinition"] = r
	}
	if c, ok := w.Concrete.(GraphDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesGraphDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("GraphDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("GraphDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["GraphDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(GroupCreate); ok {
		resourcesMap["Group"] = addInteraction("Group", "create")
	}
	if _, ok := w.Concrete.(GroupRead); ok {
		resourcesMap["Group"] = addInteraction("Group", "read")
	}
	if _, ok := w.Concrete.(GroupDelete); ok {
		resourcesMap["Group"] = addInteraction("Group", "delete")
	}
	if c, ok := w.Concrete.(GroupUpdate); ok {
		r := addInteraction("Group", "update")
		c, ok := c.(GroupUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesGroup(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Group"] = r
	}
	if c, ok := w.Concrete.(GroupSearch); ok {
		c, err := c.SearchCapabilitiesGroup(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Group", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Group-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Group"] = r
		}
	}
	if _, ok := w.Concrete.(GuidanceResponseCreate); ok {
		resourcesMap["GuidanceResponse"] = addInteraction("GuidanceResponse", "create")
	}
	if _, ok := w.Concrete.(GuidanceResponseRead); ok {
		resourcesMap["GuidanceResponse"] = addInteraction("GuidanceResponse", "read")
	}
	if _, ok := w.Concrete.(GuidanceResponseDelete); ok {
		resourcesMap["GuidanceResponse"] = addInteraction("GuidanceResponse", "delete")
	}
	if c, ok := w.Concrete.(GuidanceResponseUpdate); ok {
		r := addInteraction("GuidanceResponse", "update")
		c, ok := c.(GuidanceResponseUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesGuidanceResponse(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["GuidanceResponse"] = r
	}
	if c, ok := w.Concrete.(GuidanceResponseSearch); ok {
		c, err := c.SearchCapabilitiesGuidanceResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("GuidanceResponse", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("GuidanceResponse-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["GuidanceResponse"] = r
		}
	}
	if _, ok := w.Concrete.(HealthcareServiceCreate); ok {
		resourcesMap["HealthcareService"] = addInteraction("HealthcareService", "create")
	}
	if _, ok := w.Concrete.(HealthcareServiceRead); ok {
		resourcesMap["HealthcareService"] = addInteraction("HealthcareService", "read")
	}
	if _, ok := w.Concrete.(HealthcareServiceDelete); ok {
		resourcesMap["HealthcareService"] = addInteraction("HealthcareService", "delete")
	}
	if c, ok := w.Concrete.(HealthcareServiceUpdate); ok {
		r := addInteraction("HealthcareService", "update")
		c, ok := c.(HealthcareServiceUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesHealthcareService(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["HealthcareService"] = r
	}
	if c, ok := w.Concrete.(HealthcareServiceSearch); ok {
		c, err := c.SearchCapabilitiesHealthcareService(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("HealthcareService", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("HealthcareService-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["HealthcareService"] = r
		}
	}
	if _, ok := w.Concrete.(ImagingStudyCreate); ok {
		resourcesMap["ImagingStudy"] = addInteraction("ImagingStudy", "create")
	}
	if _, ok := w.Concrete.(ImagingStudyRead); ok {
		resourcesMap["ImagingStudy"] = addInteraction("ImagingStudy", "read")
	}
	if _, ok := w.Concrete.(ImagingStudyDelete); ok {
		resourcesMap["ImagingStudy"] = addInteraction("ImagingStudy", "delete")
	}
	if c, ok := w.Concrete.(ImagingStudyUpdate); ok {
		r := addInteraction("ImagingStudy", "update")
		c, ok := c.(ImagingStudyUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesImagingStudy(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ImagingStudy"] = r
	}
	if c, ok := w.Concrete.(ImagingStudySearch); ok {
		c, err := c.SearchCapabilitiesImagingStudy(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ImagingStudy", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ImagingStudy-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ImagingStudy"] = r
		}
	}
	if _, ok := w.Concrete.(ImmunizationCreate); ok {
		resourcesMap["Immunization"] = addInteraction("Immunization", "create")
	}
	if _, ok := w.Concrete.(ImmunizationRead); ok {
		resourcesMap["Immunization"] = addInteraction("Immunization", "read")
	}
	if _, ok := w.Concrete.(ImmunizationDelete); ok {
		resourcesMap["Immunization"] = addInteraction("Immunization", "delete")
	}
	if c, ok := w.Concrete.(ImmunizationUpdate); ok {
		r := addInteraction("Immunization", "update")
		c, ok := c.(ImmunizationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesImmunization(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Immunization"] = r
	}
	if c, ok := w.Concrete.(ImmunizationSearch); ok {
		c, err := c.SearchCapabilitiesImmunization(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Immunization", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Immunization-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Immunization"] = r
		}
	}
	if _, ok := w.Concrete.(ImmunizationEvaluationCreate); ok {
		resourcesMap["ImmunizationEvaluation"] = addInteraction("ImmunizationEvaluation", "create")
	}
	if _, ok := w.Concrete.(ImmunizationEvaluationRead); ok {
		resourcesMap["ImmunizationEvaluation"] = addInteraction("ImmunizationEvaluation", "read")
	}
	if _, ok := w.Concrete.(ImmunizationEvaluationDelete); ok {
		resourcesMap["ImmunizationEvaluation"] = addInteraction("ImmunizationEvaluation", "delete")
	}
	if c, ok := w.Concrete.(ImmunizationEvaluationUpdate); ok {
		r := addInteraction("ImmunizationEvaluation", "update")
		c, ok := c.(ImmunizationEvaluationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesImmunizationEvaluation(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ImmunizationEvaluation"] = r
	}
	if c, ok := w.Concrete.(ImmunizationEvaluationSearch); ok {
		c, err := c.SearchCapabilitiesImmunizationEvaluation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ImmunizationEvaluation", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ImmunizationEvaluation-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ImmunizationEvaluation"] = r
		}
	}
	if _, ok := w.Concrete.(ImmunizationRecommendationCreate); ok {
		resourcesMap["ImmunizationRecommendation"] = addInteraction("ImmunizationRecommendation", "create")
	}
	if _, ok := w.Concrete.(ImmunizationRecommendationRead); ok {
		resourcesMap["ImmunizationRecommendation"] = addInteraction("ImmunizationRecommendation", "read")
	}
	if _, ok := w.Concrete.(ImmunizationRecommendationDelete); ok {
		resourcesMap["ImmunizationRecommendation"] = addInteraction("ImmunizationRecommendation", "delete")
	}
	if c, ok := w.Concrete.(ImmunizationRecommendationUpdate); ok {
		r := addInteraction("ImmunizationRecommendation", "update")
		c, ok := c.(ImmunizationRecommendationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesImmunizationRecommendation(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ImmunizationRecommendation"] = r
	}
	if c, ok := w.Concrete.(ImmunizationRecommendationSearch); ok {
		c, err := c.SearchCapabilitiesImmunizationRecommendation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ImmunizationRecommendation", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ImmunizationRecommendation-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ImmunizationRecommendation"] = r
		}
	}
	if _, ok := w.Concrete.(ImplementationGuideCreate); ok {
		resourcesMap["ImplementationGuide"] = addInteraction("ImplementationGuide", "create")
	}
	if _, ok := w.Concrete.(ImplementationGuideRead); ok {
		resourcesMap["ImplementationGuide"] = addInteraction("ImplementationGuide", "read")
	}
	if _, ok := w.Concrete.(ImplementationGuideDelete); ok {
		resourcesMap["ImplementationGuide"] = addInteraction("ImplementationGuide", "delete")
	}
	if c, ok := w.Concrete.(ImplementationGuideUpdate); ok {
		r := addInteraction("ImplementationGuide", "update")
		c, ok := c.(ImplementationGuideUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesImplementationGuide(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ImplementationGuide"] = r
	}
	if c, ok := w.Concrete.(ImplementationGuideSearch); ok {
		c, err := c.SearchCapabilitiesImplementationGuide(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ImplementationGuide", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ImplementationGuide-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ImplementationGuide"] = r
		}
	}
	if _, ok := w.Concrete.(InsurancePlanCreate); ok {
		resourcesMap["InsurancePlan"] = addInteraction("InsurancePlan", "create")
	}
	if _, ok := w.Concrete.(InsurancePlanRead); ok {
		resourcesMap["InsurancePlan"] = addInteraction("InsurancePlan", "read")
	}
	if _, ok := w.Concrete.(InsurancePlanDelete); ok {
		resourcesMap["InsurancePlan"] = addInteraction("InsurancePlan", "delete")
	}
	if c, ok := w.Concrete.(InsurancePlanUpdate); ok {
		r := addInteraction("InsurancePlan", "update")
		c, ok := c.(InsurancePlanUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesInsurancePlan(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["InsurancePlan"] = r
	}
	if c, ok := w.Concrete.(InsurancePlanSearch); ok {
		c, err := c.SearchCapabilitiesInsurancePlan(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("InsurancePlan", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("InsurancePlan-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["InsurancePlan"] = r
		}
	}
	if _, ok := w.Concrete.(InvoiceCreate); ok {
		resourcesMap["Invoice"] = addInteraction("Invoice", "create")
	}
	if _, ok := w.Concrete.(InvoiceRead); ok {
		resourcesMap["Invoice"] = addInteraction("Invoice", "read")
	}
	if _, ok := w.Concrete.(InvoiceDelete); ok {
		resourcesMap["Invoice"] = addInteraction("Invoice", "delete")
	}
	if c, ok := w.Concrete.(InvoiceUpdate); ok {
		r := addInteraction("Invoice", "update")
		c, ok := c.(InvoiceUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesInvoice(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Invoice"] = r
	}
	if c, ok := w.Concrete.(InvoiceSearch); ok {
		c, err := c.SearchCapabilitiesInvoice(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Invoice", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Invoice-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Invoice"] = r
		}
	}
	if _, ok := w.Concrete.(LibraryCreate); ok {
		resourcesMap["Library"] = addInteraction("Library", "create")
	}
	if _, ok := w.Concrete.(LibraryRead); ok {
		resourcesMap["Library"] = addInteraction("Library", "read")
	}
	if _, ok := w.Concrete.(LibraryDelete); ok {
		resourcesMap["Library"] = addInteraction("Library", "delete")
	}
	if c, ok := w.Concrete.(LibraryUpdate); ok {
		r := addInteraction("Library", "update")
		c, ok := c.(LibraryUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesLibrary(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Library"] = r
	}
	if c, ok := w.Concrete.(LibrarySearch); ok {
		c, err := c.SearchCapabilitiesLibrary(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Library", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Library-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Library"] = r
		}
	}
	if _, ok := w.Concrete.(LinkageCreate); ok {
		resourcesMap["Linkage"] = addInteraction("Linkage", "create")
	}
	if _, ok := w.Concrete.(LinkageRead); ok {
		resourcesMap["Linkage"] = addInteraction("Linkage", "read")
	}
	if _, ok := w.Concrete.(LinkageDelete); ok {
		resourcesMap["Linkage"] = addInteraction("Linkage", "delete")
	}
	if c, ok := w.Concrete.(LinkageUpdate); ok {
		r := addInteraction("Linkage", "update")
		c, ok := c.(LinkageUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesLinkage(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Linkage"] = r
	}
	if c, ok := w.Concrete.(LinkageSearch); ok {
		c, err := c.SearchCapabilitiesLinkage(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Linkage", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Linkage-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Linkage"] = r
		}
	}
	if _, ok := w.Concrete.(ListCreate); ok {
		resourcesMap["List"] = addInteraction("List", "create")
	}
	if _, ok := w.Concrete.(ListRead); ok {
		resourcesMap["List"] = addInteraction("List", "read")
	}
	if _, ok := w.Concrete.(ListDelete); ok {
		resourcesMap["List"] = addInteraction("List", "delete")
	}
	if c, ok := w.Concrete.(ListUpdate); ok {
		r := addInteraction("List", "update")
		c, ok := c.(ListUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesList(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["List"] = r
	}
	if c, ok := w.Concrete.(ListSearch); ok {
		c, err := c.SearchCapabilitiesList(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("List", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("List-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["List"] = r
		}
	}
	if _, ok := w.Concrete.(LocationCreate); ok {
		resourcesMap["Location"] = addInteraction("Location", "create")
	}
	if _, ok := w.Concrete.(LocationRead); ok {
		resourcesMap["Location"] = addInteraction("Location", "read")
	}
	if _, ok := w.Concrete.(LocationDelete); ok {
		resourcesMap["Location"] = addInteraction("Location", "delete")
	}
	if c, ok := w.Concrete.(LocationUpdate); ok {
		r := addInteraction("Location", "update")
		c, ok := c.(LocationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesLocation(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Location"] = r
	}
	if c, ok := w.Concrete.(LocationSearch); ok {
		c, err := c.SearchCapabilitiesLocation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Location", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Location-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Location"] = r
		}
	}
	if _, ok := w.Concrete.(MeasureCreate); ok {
		resourcesMap["Measure"] = addInteraction("Measure", "create")
	}
	if _, ok := w.Concrete.(MeasureRead); ok {
		resourcesMap["Measure"] = addInteraction("Measure", "read")
	}
	if _, ok := w.Concrete.(MeasureDelete); ok {
		resourcesMap["Measure"] = addInteraction("Measure", "delete")
	}
	if c, ok := w.Concrete.(MeasureUpdate); ok {
		r := addInteraction("Measure", "update")
		c, ok := c.(MeasureUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMeasure(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Measure"] = r
	}
	if c, ok := w.Concrete.(MeasureSearch); ok {
		c, err := c.SearchCapabilitiesMeasure(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Measure", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Measure-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Measure"] = r
		}
	}
	if _, ok := w.Concrete.(MeasureReportCreate); ok {
		resourcesMap["MeasureReport"] = addInteraction("MeasureReport", "create")
	}
	if _, ok := w.Concrete.(MeasureReportRead); ok {
		resourcesMap["MeasureReport"] = addInteraction("MeasureReport", "read")
	}
	if _, ok := w.Concrete.(MeasureReportDelete); ok {
		resourcesMap["MeasureReport"] = addInteraction("MeasureReport", "delete")
	}
	if c, ok := w.Concrete.(MeasureReportUpdate); ok {
		r := addInteraction("MeasureReport", "update")
		c, ok := c.(MeasureReportUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMeasureReport(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MeasureReport"] = r
	}
	if c, ok := w.Concrete.(MeasureReportSearch); ok {
		c, err := c.SearchCapabilitiesMeasureReport(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MeasureReport", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MeasureReport-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MeasureReport"] = r
		}
	}
	if _, ok := w.Concrete.(MediaCreate); ok {
		resourcesMap["Media"] = addInteraction("Media", "create")
	}
	if _, ok := w.Concrete.(MediaRead); ok {
		resourcesMap["Media"] = addInteraction("Media", "read")
	}
	if _, ok := w.Concrete.(MediaDelete); ok {
		resourcesMap["Media"] = addInteraction("Media", "delete")
	}
	if c, ok := w.Concrete.(MediaUpdate); ok {
		r := addInteraction("Media", "update")
		c, ok := c.(MediaUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedia(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Media"] = r
	}
	if c, ok := w.Concrete.(MediaSearch); ok {
		c, err := c.SearchCapabilitiesMedia(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Media", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Media-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Media"] = r
		}
	}
	if _, ok := w.Concrete.(MedicationCreate); ok {
		resourcesMap["Medication"] = addInteraction("Medication", "create")
	}
	if _, ok := w.Concrete.(MedicationRead); ok {
		resourcesMap["Medication"] = addInteraction("Medication", "read")
	}
	if _, ok := w.Concrete.(MedicationDelete); ok {
		resourcesMap["Medication"] = addInteraction("Medication", "delete")
	}
	if c, ok := w.Concrete.(MedicationUpdate); ok {
		r := addInteraction("Medication", "update")
		c, ok := c.(MedicationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedication(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Medication"] = r
	}
	if c, ok := w.Concrete.(MedicationSearch); ok {
		c, err := c.SearchCapabilitiesMedication(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Medication", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Medication-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Medication"] = r
		}
	}
	if _, ok := w.Concrete.(MedicationAdministrationCreate); ok {
		resourcesMap["MedicationAdministration"] = addInteraction("MedicationAdministration", "create")
	}
	if _, ok := w.Concrete.(MedicationAdministrationRead); ok {
		resourcesMap["MedicationAdministration"] = addInteraction("MedicationAdministration", "read")
	}
	if _, ok := w.Concrete.(MedicationAdministrationDelete); ok {
		resourcesMap["MedicationAdministration"] = addInteraction("MedicationAdministration", "delete")
	}
	if c, ok := w.Concrete.(MedicationAdministrationUpdate); ok {
		r := addInteraction("MedicationAdministration", "update")
		c, ok := c.(MedicationAdministrationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedicationAdministration(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MedicationAdministration"] = r
	}
	if c, ok := w.Concrete.(MedicationAdministrationSearch); ok {
		c, err := c.SearchCapabilitiesMedicationAdministration(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MedicationAdministration", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MedicationAdministration-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MedicationAdministration"] = r
		}
	}
	if _, ok := w.Concrete.(MedicationDispenseCreate); ok {
		resourcesMap["MedicationDispense"] = addInteraction("MedicationDispense", "create")
	}
	if _, ok := w.Concrete.(MedicationDispenseRead); ok {
		resourcesMap["MedicationDispense"] = addInteraction("MedicationDispense", "read")
	}
	if _, ok := w.Concrete.(MedicationDispenseDelete); ok {
		resourcesMap["MedicationDispense"] = addInteraction("MedicationDispense", "delete")
	}
	if c, ok := w.Concrete.(MedicationDispenseUpdate); ok {
		r := addInteraction("MedicationDispense", "update")
		c, ok := c.(MedicationDispenseUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedicationDispense(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MedicationDispense"] = r
	}
	if c, ok := w.Concrete.(MedicationDispenseSearch); ok {
		c, err := c.SearchCapabilitiesMedicationDispense(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MedicationDispense", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MedicationDispense-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MedicationDispense"] = r
		}
	}
	if _, ok := w.Concrete.(MedicationKnowledgeCreate); ok {
		resourcesMap["MedicationKnowledge"] = addInteraction("MedicationKnowledge", "create")
	}
	if _, ok := w.Concrete.(MedicationKnowledgeRead); ok {
		resourcesMap["MedicationKnowledge"] = addInteraction("MedicationKnowledge", "read")
	}
	if _, ok := w.Concrete.(MedicationKnowledgeDelete); ok {
		resourcesMap["MedicationKnowledge"] = addInteraction("MedicationKnowledge", "delete")
	}
	if c, ok := w.Concrete.(MedicationKnowledgeUpdate); ok {
		r := addInteraction("MedicationKnowledge", "update")
		c, ok := c.(MedicationKnowledgeUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedicationKnowledge(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MedicationKnowledge"] = r
	}
	if c, ok := w.Concrete.(MedicationKnowledgeSearch); ok {
		c, err := c.SearchCapabilitiesMedicationKnowledge(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MedicationKnowledge", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MedicationKnowledge-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MedicationKnowledge"] = r
		}
	}
	if _, ok := w.Concrete.(MedicationRequestCreate); ok {
		resourcesMap["MedicationRequest"] = addInteraction("MedicationRequest", "create")
	}
	if _, ok := w.Concrete.(MedicationRequestRead); ok {
		resourcesMap["MedicationRequest"] = addInteraction("MedicationRequest", "read")
	}
	if _, ok := w.Concrete.(MedicationRequestDelete); ok {
		resourcesMap["MedicationRequest"] = addInteraction("MedicationRequest", "delete")
	}
	if c, ok := w.Concrete.(MedicationRequestUpdate); ok {
		r := addInteraction("MedicationRequest", "update")
		c, ok := c.(MedicationRequestUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedicationRequest(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MedicationRequest"] = r
	}
	if c, ok := w.Concrete.(MedicationRequestSearch); ok {
		c, err := c.SearchCapabilitiesMedicationRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MedicationRequest", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MedicationRequest-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MedicationRequest"] = r
		}
	}
	if _, ok := w.Concrete.(MedicationStatementCreate); ok {
		resourcesMap["MedicationStatement"] = addInteraction("MedicationStatement", "create")
	}
	if _, ok := w.Concrete.(MedicationStatementRead); ok {
		resourcesMap["MedicationStatement"] = addInteraction("MedicationStatement", "read")
	}
	if _, ok := w.Concrete.(MedicationStatementDelete); ok {
		resourcesMap["MedicationStatement"] = addInteraction("MedicationStatement", "delete")
	}
	if c, ok := w.Concrete.(MedicationStatementUpdate); ok {
		r := addInteraction("MedicationStatement", "update")
		c, ok := c.(MedicationStatementUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedicationStatement(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MedicationStatement"] = r
	}
	if c, ok := w.Concrete.(MedicationStatementSearch); ok {
		c, err := c.SearchCapabilitiesMedicationStatement(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MedicationStatement", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MedicationStatement-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MedicationStatement"] = r
		}
	}
	if _, ok := w.Concrete.(MedicinalProductCreate); ok {
		resourcesMap["MedicinalProduct"] = addInteraction("MedicinalProduct", "create")
	}
	if _, ok := w.Concrete.(MedicinalProductRead); ok {
		resourcesMap["MedicinalProduct"] = addInteraction("MedicinalProduct", "read")
	}
	if _, ok := w.Concrete.(MedicinalProductDelete); ok {
		resourcesMap["MedicinalProduct"] = addInteraction("MedicinalProduct", "delete")
	}
	if c, ok := w.Concrete.(MedicinalProductUpdate); ok {
		r := addInteraction("MedicinalProduct", "update")
		c, ok := c.(MedicinalProductUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedicinalProduct(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MedicinalProduct"] = r
	}
	if c, ok := w.Concrete.(MedicinalProductSearch); ok {
		c, err := c.SearchCapabilitiesMedicinalProduct(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MedicinalProduct", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MedicinalProduct-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MedicinalProduct"] = r
		}
	}
	if _, ok := w.Concrete.(MedicinalProductAuthorizationCreate); ok {
		resourcesMap["MedicinalProductAuthorization"] = addInteraction("MedicinalProductAuthorization", "create")
	}
	if _, ok := w.Concrete.(MedicinalProductAuthorizationRead); ok {
		resourcesMap["MedicinalProductAuthorization"] = addInteraction("MedicinalProductAuthorization", "read")
	}
	if _, ok := w.Concrete.(MedicinalProductAuthorizationDelete); ok {
		resourcesMap["MedicinalProductAuthorization"] = addInteraction("MedicinalProductAuthorization", "delete")
	}
	if c, ok := w.Concrete.(MedicinalProductAuthorizationUpdate); ok {
		r := addInteraction("MedicinalProductAuthorization", "update")
		c, ok := c.(MedicinalProductAuthorizationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedicinalProductAuthorization(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MedicinalProductAuthorization"] = r
	}
	if c, ok := w.Concrete.(MedicinalProductAuthorizationSearch); ok {
		c, err := c.SearchCapabilitiesMedicinalProductAuthorization(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MedicinalProductAuthorization", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MedicinalProductAuthorization-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MedicinalProductAuthorization"] = r
		}
	}
	if _, ok := w.Concrete.(MedicinalProductContraindicationCreate); ok {
		resourcesMap["MedicinalProductContraindication"] = addInteraction("MedicinalProductContraindication", "create")
	}
	if _, ok := w.Concrete.(MedicinalProductContraindicationRead); ok {
		resourcesMap["MedicinalProductContraindication"] = addInteraction("MedicinalProductContraindication", "read")
	}
	if _, ok := w.Concrete.(MedicinalProductContraindicationDelete); ok {
		resourcesMap["MedicinalProductContraindication"] = addInteraction("MedicinalProductContraindication", "delete")
	}
	if c, ok := w.Concrete.(MedicinalProductContraindicationUpdate); ok {
		r := addInteraction("MedicinalProductContraindication", "update")
		c, ok := c.(MedicinalProductContraindicationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedicinalProductContraindication(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MedicinalProductContraindication"] = r
	}
	if c, ok := w.Concrete.(MedicinalProductContraindicationSearch); ok {
		c, err := c.SearchCapabilitiesMedicinalProductContraindication(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MedicinalProductContraindication", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MedicinalProductContraindication-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MedicinalProductContraindication"] = r
		}
	}
	if _, ok := w.Concrete.(MedicinalProductIndicationCreate); ok {
		resourcesMap["MedicinalProductIndication"] = addInteraction("MedicinalProductIndication", "create")
	}
	if _, ok := w.Concrete.(MedicinalProductIndicationRead); ok {
		resourcesMap["MedicinalProductIndication"] = addInteraction("MedicinalProductIndication", "read")
	}
	if _, ok := w.Concrete.(MedicinalProductIndicationDelete); ok {
		resourcesMap["MedicinalProductIndication"] = addInteraction("MedicinalProductIndication", "delete")
	}
	if c, ok := w.Concrete.(MedicinalProductIndicationUpdate); ok {
		r := addInteraction("MedicinalProductIndication", "update")
		c, ok := c.(MedicinalProductIndicationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedicinalProductIndication(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MedicinalProductIndication"] = r
	}
	if c, ok := w.Concrete.(MedicinalProductIndicationSearch); ok {
		c, err := c.SearchCapabilitiesMedicinalProductIndication(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MedicinalProductIndication", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MedicinalProductIndication-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MedicinalProductIndication"] = r
		}
	}
	if _, ok := w.Concrete.(MedicinalProductIngredientCreate); ok {
		resourcesMap["MedicinalProductIngredient"] = addInteraction("MedicinalProductIngredient", "create")
	}
	if _, ok := w.Concrete.(MedicinalProductIngredientRead); ok {
		resourcesMap["MedicinalProductIngredient"] = addInteraction("MedicinalProductIngredient", "read")
	}
	if _, ok := w.Concrete.(MedicinalProductIngredientDelete); ok {
		resourcesMap["MedicinalProductIngredient"] = addInteraction("MedicinalProductIngredient", "delete")
	}
	if c, ok := w.Concrete.(MedicinalProductIngredientUpdate); ok {
		r := addInteraction("MedicinalProductIngredient", "update")
		c, ok := c.(MedicinalProductIngredientUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedicinalProductIngredient(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MedicinalProductIngredient"] = r
	}
	if c, ok := w.Concrete.(MedicinalProductIngredientSearch); ok {
		c, err := c.SearchCapabilitiesMedicinalProductIngredient(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MedicinalProductIngredient", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MedicinalProductIngredient-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MedicinalProductIngredient"] = r
		}
	}
	if _, ok := w.Concrete.(MedicinalProductInteractionCreate); ok {
		resourcesMap["MedicinalProductInteraction"] = addInteraction("MedicinalProductInteraction", "create")
	}
	if _, ok := w.Concrete.(MedicinalProductInteractionRead); ok {
		resourcesMap["MedicinalProductInteraction"] = addInteraction("MedicinalProductInteraction", "read")
	}
	if _, ok := w.Concrete.(MedicinalProductInteractionDelete); ok {
		resourcesMap["MedicinalProductInteraction"] = addInteraction("MedicinalProductInteraction", "delete")
	}
	if c, ok := w.Concrete.(MedicinalProductInteractionUpdate); ok {
		r := addInteraction("MedicinalProductInteraction", "update")
		c, ok := c.(MedicinalProductInteractionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedicinalProductInteraction(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MedicinalProductInteraction"] = r
	}
	if c, ok := w.Concrete.(MedicinalProductInteractionSearch); ok {
		c, err := c.SearchCapabilitiesMedicinalProductInteraction(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MedicinalProductInteraction", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MedicinalProductInteraction-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MedicinalProductInteraction"] = r
		}
	}
	if _, ok := w.Concrete.(MedicinalProductManufacturedCreate); ok {
		resourcesMap["MedicinalProductManufactured"] = addInteraction("MedicinalProductManufactured", "create")
	}
	if _, ok := w.Concrete.(MedicinalProductManufacturedRead); ok {
		resourcesMap["MedicinalProductManufactured"] = addInteraction("MedicinalProductManufactured", "read")
	}
	if _, ok := w.Concrete.(MedicinalProductManufacturedDelete); ok {
		resourcesMap["MedicinalProductManufactured"] = addInteraction("MedicinalProductManufactured", "delete")
	}
	if c, ok := w.Concrete.(MedicinalProductManufacturedUpdate); ok {
		r := addInteraction("MedicinalProductManufactured", "update")
		c, ok := c.(MedicinalProductManufacturedUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedicinalProductManufactured(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MedicinalProductManufactured"] = r
	}
	if c, ok := w.Concrete.(MedicinalProductManufacturedSearch); ok {
		c, err := c.SearchCapabilitiesMedicinalProductManufactured(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MedicinalProductManufactured", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MedicinalProductManufactured-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MedicinalProductManufactured"] = r
		}
	}
	if _, ok := w.Concrete.(MedicinalProductPackagedCreate); ok {
		resourcesMap["MedicinalProductPackaged"] = addInteraction("MedicinalProductPackaged", "create")
	}
	if _, ok := w.Concrete.(MedicinalProductPackagedRead); ok {
		resourcesMap["MedicinalProductPackaged"] = addInteraction("MedicinalProductPackaged", "read")
	}
	if _, ok := w.Concrete.(MedicinalProductPackagedDelete); ok {
		resourcesMap["MedicinalProductPackaged"] = addInteraction("MedicinalProductPackaged", "delete")
	}
	if c, ok := w.Concrete.(MedicinalProductPackagedUpdate); ok {
		r := addInteraction("MedicinalProductPackaged", "update")
		c, ok := c.(MedicinalProductPackagedUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedicinalProductPackaged(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MedicinalProductPackaged"] = r
	}
	if c, ok := w.Concrete.(MedicinalProductPackagedSearch); ok {
		c, err := c.SearchCapabilitiesMedicinalProductPackaged(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MedicinalProductPackaged", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MedicinalProductPackaged-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MedicinalProductPackaged"] = r
		}
	}
	if _, ok := w.Concrete.(MedicinalProductPharmaceuticalCreate); ok {
		resourcesMap["MedicinalProductPharmaceutical"] = addInteraction("MedicinalProductPharmaceutical", "create")
	}
	if _, ok := w.Concrete.(MedicinalProductPharmaceuticalRead); ok {
		resourcesMap["MedicinalProductPharmaceutical"] = addInteraction("MedicinalProductPharmaceutical", "read")
	}
	if _, ok := w.Concrete.(MedicinalProductPharmaceuticalDelete); ok {
		resourcesMap["MedicinalProductPharmaceutical"] = addInteraction("MedicinalProductPharmaceutical", "delete")
	}
	if c, ok := w.Concrete.(MedicinalProductPharmaceuticalUpdate); ok {
		r := addInteraction("MedicinalProductPharmaceutical", "update")
		c, ok := c.(MedicinalProductPharmaceuticalUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedicinalProductPharmaceutical(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MedicinalProductPharmaceutical"] = r
	}
	if c, ok := w.Concrete.(MedicinalProductPharmaceuticalSearch); ok {
		c, err := c.SearchCapabilitiesMedicinalProductPharmaceutical(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MedicinalProductPharmaceutical", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MedicinalProductPharmaceutical-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MedicinalProductPharmaceutical"] = r
		}
	}
	if _, ok := w.Concrete.(MedicinalProductUndesirableEffectCreate); ok {
		resourcesMap["MedicinalProductUndesirableEffect"] = addInteraction("MedicinalProductUndesirableEffect", "create")
	}
	if _, ok := w.Concrete.(MedicinalProductUndesirableEffectRead); ok {
		resourcesMap["MedicinalProductUndesirableEffect"] = addInteraction("MedicinalProductUndesirableEffect", "read")
	}
	if _, ok := w.Concrete.(MedicinalProductUndesirableEffectDelete); ok {
		resourcesMap["MedicinalProductUndesirableEffect"] = addInteraction("MedicinalProductUndesirableEffect", "delete")
	}
	if c, ok := w.Concrete.(MedicinalProductUndesirableEffectUpdate); ok {
		r := addInteraction("MedicinalProductUndesirableEffect", "update")
		c, ok := c.(MedicinalProductUndesirableEffectUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedicinalProductUndesirableEffect(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MedicinalProductUndesirableEffect"] = r
	}
	if c, ok := w.Concrete.(MedicinalProductUndesirableEffectSearch); ok {
		c, err := c.SearchCapabilitiesMedicinalProductUndesirableEffect(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MedicinalProductUndesirableEffect", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MedicinalProductUndesirableEffect-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MedicinalProductUndesirableEffect"] = r
		}
	}
	if _, ok := w.Concrete.(MessageDefinitionCreate); ok {
		resourcesMap["MessageDefinition"] = addInteraction("MessageDefinition", "create")
	}
	if _, ok := w.Concrete.(MessageDefinitionRead); ok {
		resourcesMap["MessageDefinition"] = addInteraction("MessageDefinition", "read")
	}
	if _, ok := w.Concrete.(MessageDefinitionDelete); ok {
		resourcesMap["MessageDefinition"] = addInteraction("MessageDefinition", "delete")
	}
	if c, ok := w.Concrete.(MessageDefinitionUpdate); ok {
		r := addInteraction("MessageDefinition", "update")
		c, ok := c.(MessageDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMessageDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MessageDefinition"] = r
	}
	if c, ok := w.Concrete.(MessageDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesMessageDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MessageDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MessageDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MessageDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(MessageHeaderCreate); ok {
		resourcesMap["MessageHeader"] = addInteraction("MessageHeader", "create")
	}
	if _, ok := w.Concrete.(MessageHeaderRead); ok {
		resourcesMap["MessageHeader"] = addInteraction("MessageHeader", "read")
	}
	if _, ok := w.Concrete.(MessageHeaderDelete); ok {
		resourcesMap["MessageHeader"] = addInteraction("MessageHeader", "delete")
	}
	if c, ok := w.Concrete.(MessageHeaderUpdate); ok {
		r := addInteraction("MessageHeader", "update")
		c, ok := c.(MessageHeaderUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMessageHeader(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MessageHeader"] = r
	}
	if c, ok := w.Concrete.(MessageHeaderSearch); ok {
		c, err := c.SearchCapabilitiesMessageHeader(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MessageHeader", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MessageHeader-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MessageHeader"] = r
		}
	}
	if _, ok := w.Concrete.(MolecularSequenceCreate); ok {
		resourcesMap["MolecularSequence"] = addInteraction("MolecularSequence", "create")
	}
	if _, ok := w.Concrete.(MolecularSequenceRead); ok {
		resourcesMap["MolecularSequence"] = addInteraction("MolecularSequence", "read")
	}
	if _, ok := w.Concrete.(MolecularSequenceDelete); ok {
		resourcesMap["MolecularSequence"] = addInteraction("MolecularSequence", "delete")
	}
	if c, ok := w.Concrete.(MolecularSequenceUpdate); ok {
		r := addInteraction("MolecularSequence", "update")
		c, ok := c.(MolecularSequenceUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMolecularSequence(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MolecularSequence"] = r
	}
	if c, ok := w.Concrete.(MolecularSequenceSearch); ok {
		c, err := c.SearchCapabilitiesMolecularSequence(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MolecularSequence", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MolecularSequence-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MolecularSequence"] = r
		}
	}
	if _, ok := w.Concrete.(NamingSystemCreate); ok {
		resourcesMap["NamingSystem"] = addInteraction("NamingSystem", "create")
	}
	if _, ok := w.Concrete.(NamingSystemRead); ok {
		resourcesMap["NamingSystem"] = addInteraction("NamingSystem", "read")
	}
	if _, ok := w.Concrete.(NamingSystemDelete); ok {
		resourcesMap["NamingSystem"] = addInteraction("NamingSystem", "delete")
	}
	if c, ok := w.Concrete.(NamingSystemUpdate); ok {
		r := addInteraction("NamingSystem", "update")
		c, ok := c.(NamingSystemUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesNamingSystem(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["NamingSystem"] = r
	}
	if c, ok := w.Concrete.(NamingSystemSearch); ok {
		c, err := c.SearchCapabilitiesNamingSystem(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("NamingSystem", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("NamingSystem-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["NamingSystem"] = r
		}
	}
	if _, ok := w.Concrete.(NutritionOrderCreate); ok {
		resourcesMap["NutritionOrder"] = addInteraction("NutritionOrder", "create")
	}
	if _, ok := w.Concrete.(NutritionOrderRead); ok {
		resourcesMap["NutritionOrder"] = addInteraction("NutritionOrder", "read")
	}
	if _, ok := w.Concrete.(NutritionOrderDelete); ok {
		resourcesMap["NutritionOrder"] = addInteraction("NutritionOrder", "delete")
	}
	if c, ok := w.Concrete.(NutritionOrderUpdate); ok {
		r := addInteraction("NutritionOrder", "update")
		c, ok := c.(NutritionOrderUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesNutritionOrder(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["NutritionOrder"] = r
	}
	if c, ok := w.Concrete.(NutritionOrderSearch); ok {
		c, err := c.SearchCapabilitiesNutritionOrder(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("NutritionOrder", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("NutritionOrder-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["NutritionOrder"] = r
		}
	}
	if _, ok := w.Concrete.(ObservationCreate); ok {
		resourcesMap["Observation"] = addInteraction("Observation", "create")
	}
	if _, ok := w.Concrete.(ObservationRead); ok {
		resourcesMap["Observation"] = addInteraction("Observation", "read")
	}
	if _, ok := w.Concrete.(ObservationDelete); ok {
		resourcesMap["Observation"] = addInteraction("Observation", "delete")
	}
	if c, ok := w.Concrete.(ObservationUpdate); ok {
		r := addInteraction("Observation", "update")
		c, ok := c.(ObservationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesObservation(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Observation"] = r
	}
	if c, ok := w.Concrete.(ObservationSearch); ok {
		c, err := c.SearchCapabilitiesObservation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Observation", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Observation-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Observation"] = r
		}
	}
	if _, ok := w.Concrete.(ObservationDefinitionCreate); ok {
		resourcesMap["ObservationDefinition"] = addInteraction("ObservationDefinition", "create")
	}
	if _, ok := w.Concrete.(ObservationDefinitionRead); ok {
		resourcesMap["ObservationDefinition"] = addInteraction("ObservationDefinition", "read")
	}
	if _, ok := w.Concrete.(ObservationDefinitionDelete); ok {
		resourcesMap["ObservationDefinition"] = addInteraction("ObservationDefinition", "delete")
	}
	if c, ok := w.Concrete.(ObservationDefinitionUpdate); ok {
		r := addInteraction("ObservationDefinition", "update")
		c, ok := c.(ObservationDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesObservationDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ObservationDefinition"] = r
	}
	if c, ok := w.Concrete.(ObservationDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesObservationDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ObservationDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ObservationDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ObservationDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(OperationDefinitionCreate); ok {
		resourcesMap["OperationDefinition"] = addInteraction("OperationDefinition", "create")
	}
	if _, ok := w.Concrete.(OperationDefinitionRead); ok {
		resourcesMap["OperationDefinition"] = addInteraction("OperationDefinition", "read")
	}
	if _, ok := w.Concrete.(OperationDefinitionDelete); ok {
		resourcesMap["OperationDefinition"] = addInteraction("OperationDefinition", "delete")
	}
	if c, ok := w.Concrete.(OperationDefinitionUpdate); ok {
		r := addInteraction("OperationDefinition", "update")
		c, ok := c.(OperationDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesOperationDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["OperationDefinition"] = r
	}
	if c, ok := w.Concrete.(OperationDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesOperationDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("OperationDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("OperationDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["OperationDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(OperationOutcomeCreate); ok {
		resourcesMap["OperationOutcome"] = addInteraction("OperationOutcome", "create")
	}
	if _, ok := w.Concrete.(OperationOutcomeRead); ok {
		resourcesMap["OperationOutcome"] = addInteraction("OperationOutcome", "read")
	}
	if _, ok := w.Concrete.(OperationOutcomeDelete); ok {
		resourcesMap["OperationOutcome"] = addInteraction("OperationOutcome", "delete")
	}
	if c, ok := w.Concrete.(OperationOutcomeUpdate); ok {
		r := addInteraction("OperationOutcome", "update")
		c, ok := c.(OperationOutcomeUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesOperationOutcome(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["OperationOutcome"] = r
	}
	if c, ok := w.Concrete.(OperationOutcomeSearch); ok {
		c, err := c.SearchCapabilitiesOperationOutcome(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("OperationOutcome", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("OperationOutcome-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["OperationOutcome"] = r
		}
	}
	if _, ok := w.Concrete.(OrganizationCreate); ok {
		resourcesMap["Organization"] = addInteraction("Organization", "create")
	}
	if _, ok := w.Concrete.(OrganizationRead); ok {
		resourcesMap["Organization"] = addInteraction("Organization", "read")
	}
	if _, ok := w.Concrete.(OrganizationDelete); ok {
		resourcesMap["Organization"] = addInteraction("Organization", "delete")
	}
	if c, ok := w.Concrete.(OrganizationUpdate); ok {
		r := addInteraction("Organization", "update")
		c, ok := c.(OrganizationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesOrganization(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Organization"] = r
	}
	if c, ok := w.Concrete.(OrganizationSearch); ok {
		c, err := c.SearchCapabilitiesOrganization(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Organization", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Organization-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Organization"] = r
		}
	}
	if _, ok := w.Concrete.(OrganizationAffiliationCreate); ok {
		resourcesMap["OrganizationAffiliation"] = addInteraction("OrganizationAffiliation", "create")
	}
	if _, ok := w.Concrete.(OrganizationAffiliationRead); ok {
		resourcesMap["OrganizationAffiliation"] = addInteraction("OrganizationAffiliation", "read")
	}
	if _, ok := w.Concrete.(OrganizationAffiliationDelete); ok {
		resourcesMap["OrganizationAffiliation"] = addInteraction("OrganizationAffiliation", "delete")
	}
	if c, ok := w.Concrete.(OrganizationAffiliationUpdate); ok {
		r := addInteraction("OrganizationAffiliation", "update")
		c, ok := c.(OrganizationAffiliationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesOrganizationAffiliation(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["OrganizationAffiliation"] = r
	}
	if c, ok := w.Concrete.(OrganizationAffiliationSearch); ok {
		c, err := c.SearchCapabilitiesOrganizationAffiliation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("OrganizationAffiliation", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("OrganizationAffiliation-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["OrganizationAffiliation"] = r
		}
	}
	if _, ok := w.Concrete.(ParametersCreate); ok {
		resourcesMap["Parameters"] = addInteraction("Parameters", "create")
	}
	if _, ok := w.Concrete.(ParametersRead); ok {
		resourcesMap["Parameters"] = addInteraction("Parameters", "read")
	}
	if _, ok := w.Concrete.(ParametersDelete); ok {
		resourcesMap["Parameters"] = addInteraction("Parameters", "delete")
	}
	if c, ok := w.Concrete.(ParametersUpdate); ok {
		r := addInteraction("Parameters", "update")
		c, ok := c.(ParametersUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesParameters(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Parameters"] = r
	}
	if c, ok := w.Concrete.(ParametersSearch); ok {
		c, err := c.SearchCapabilitiesParameters(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Parameters", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Parameters-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Parameters"] = r
		}
	}
	if _, ok := w.Concrete.(PatientCreate); ok {
		resourcesMap["Patient"] = addInteraction("Patient", "create")
	}
	if _, ok := w.Concrete.(PatientRead); ok {
		resourcesMap["Patient"] = addInteraction("Patient", "read")
	}
	if _, ok := w.Concrete.(PatientDelete); ok {
		resourcesMap["Patient"] = addInteraction("Patient", "delete")
	}
	if c, ok := w.Concrete.(PatientUpdate); ok {
		r := addInteraction("Patient", "update")
		c, ok := c.(PatientUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesPatient(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Patient"] = r
	}
	if c, ok := w.Concrete.(PatientSearch); ok {
		c, err := c.SearchCapabilitiesPatient(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Patient", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Patient-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Patient"] = r
		}
	}
	if _, ok := w.Concrete.(PaymentNoticeCreate); ok {
		resourcesMap["PaymentNotice"] = addInteraction("PaymentNotice", "create")
	}
	if _, ok := w.Concrete.(PaymentNoticeRead); ok {
		resourcesMap["PaymentNotice"] = addInteraction("PaymentNotice", "read")
	}
	if _, ok := w.Concrete.(PaymentNoticeDelete); ok {
		resourcesMap["PaymentNotice"] = addInteraction("PaymentNotice", "delete")
	}
	if c, ok := w.Concrete.(PaymentNoticeUpdate); ok {
		r := addInteraction("PaymentNotice", "update")
		c, ok := c.(PaymentNoticeUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesPaymentNotice(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["PaymentNotice"] = r
	}
	if c, ok := w.Concrete.(PaymentNoticeSearch); ok {
		c, err := c.SearchCapabilitiesPaymentNotice(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("PaymentNotice", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("PaymentNotice-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["PaymentNotice"] = r
		}
	}
	if _, ok := w.Concrete.(PaymentReconciliationCreate); ok {
		resourcesMap["PaymentReconciliation"] = addInteraction("PaymentReconciliation", "create")
	}
	if _, ok := w.Concrete.(PaymentReconciliationRead); ok {
		resourcesMap["PaymentReconciliation"] = addInteraction("PaymentReconciliation", "read")
	}
	if _, ok := w.Concrete.(PaymentReconciliationDelete); ok {
		resourcesMap["PaymentReconciliation"] = addInteraction("PaymentReconciliation", "delete")
	}
	if c, ok := w.Concrete.(PaymentReconciliationUpdate); ok {
		r := addInteraction("PaymentReconciliation", "update")
		c, ok := c.(PaymentReconciliationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesPaymentReconciliation(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["PaymentReconciliation"] = r
	}
	if c, ok := w.Concrete.(PaymentReconciliationSearch); ok {
		c, err := c.SearchCapabilitiesPaymentReconciliation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("PaymentReconciliation", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("PaymentReconciliation-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["PaymentReconciliation"] = r
		}
	}
	if _, ok := w.Concrete.(PersonCreate); ok {
		resourcesMap["Person"] = addInteraction("Person", "create")
	}
	if _, ok := w.Concrete.(PersonRead); ok {
		resourcesMap["Person"] = addInteraction("Person", "read")
	}
	if _, ok := w.Concrete.(PersonDelete); ok {
		resourcesMap["Person"] = addInteraction("Person", "delete")
	}
	if c, ok := w.Concrete.(PersonUpdate); ok {
		r := addInteraction("Person", "update")
		c, ok := c.(PersonUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesPerson(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Person"] = r
	}
	if c, ok := w.Concrete.(PersonSearch); ok {
		c, err := c.SearchCapabilitiesPerson(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Person", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Person-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Person"] = r
		}
	}
	if _, ok := w.Concrete.(PlanDefinitionCreate); ok {
		resourcesMap["PlanDefinition"] = addInteraction("PlanDefinition", "create")
	}
	if _, ok := w.Concrete.(PlanDefinitionRead); ok {
		resourcesMap["PlanDefinition"] = addInteraction("PlanDefinition", "read")
	}
	if _, ok := w.Concrete.(PlanDefinitionDelete); ok {
		resourcesMap["PlanDefinition"] = addInteraction("PlanDefinition", "delete")
	}
	if c, ok := w.Concrete.(PlanDefinitionUpdate); ok {
		r := addInteraction("PlanDefinition", "update")
		c, ok := c.(PlanDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesPlanDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["PlanDefinition"] = r
	}
	if c, ok := w.Concrete.(PlanDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesPlanDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("PlanDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("PlanDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["PlanDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(PractitionerCreate); ok {
		resourcesMap["Practitioner"] = addInteraction("Practitioner", "create")
	}
	if _, ok := w.Concrete.(PractitionerRead); ok {
		resourcesMap["Practitioner"] = addInteraction("Practitioner", "read")
	}
	if _, ok := w.Concrete.(PractitionerDelete); ok {
		resourcesMap["Practitioner"] = addInteraction("Practitioner", "delete")
	}
	if c, ok := w.Concrete.(PractitionerUpdate); ok {
		r := addInteraction("Practitioner", "update")
		c, ok := c.(PractitionerUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesPractitioner(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Practitioner"] = r
	}
	if c, ok := w.Concrete.(PractitionerSearch); ok {
		c, err := c.SearchCapabilitiesPractitioner(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Practitioner", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Practitioner-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Practitioner"] = r
		}
	}
	if _, ok := w.Concrete.(PractitionerRoleCreate); ok {
		resourcesMap["PractitionerRole"] = addInteraction("PractitionerRole", "create")
	}
	if _, ok := w.Concrete.(PractitionerRoleRead); ok {
		resourcesMap["PractitionerRole"] = addInteraction("PractitionerRole", "read")
	}
	if _, ok := w.Concrete.(PractitionerRoleDelete); ok {
		resourcesMap["PractitionerRole"] = addInteraction("PractitionerRole", "delete")
	}
	if c, ok := w.Concrete.(PractitionerRoleUpdate); ok {
		r := addInteraction("PractitionerRole", "update")
		c, ok := c.(PractitionerRoleUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesPractitionerRole(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["PractitionerRole"] = r
	}
	if c, ok := w.Concrete.(PractitionerRoleSearch); ok {
		c, err := c.SearchCapabilitiesPractitionerRole(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("PractitionerRole", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("PractitionerRole-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["PractitionerRole"] = r
		}
	}
	if _, ok := w.Concrete.(ProcedureCreate); ok {
		resourcesMap["Procedure"] = addInteraction("Procedure", "create")
	}
	if _, ok := w.Concrete.(ProcedureRead); ok {
		resourcesMap["Procedure"] = addInteraction("Procedure", "read")
	}
	if _, ok := w.Concrete.(ProcedureDelete); ok {
		resourcesMap["Procedure"] = addInteraction("Procedure", "delete")
	}
	if c, ok := w.Concrete.(ProcedureUpdate); ok {
		r := addInteraction("Procedure", "update")
		c, ok := c.(ProcedureUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesProcedure(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Procedure"] = r
	}
	if c, ok := w.Concrete.(ProcedureSearch); ok {
		c, err := c.SearchCapabilitiesProcedure(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Procedure", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Procedure-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Procedure"] = r
		}
	}
	if _, ok := w.Concrete.(ProvenanceCreate); ok {
		resourcesMap["Provenance"] = addInteraction("Provenance", "create")
	}
	if _, ok := w.Concrete.(ProvenanceRead); ok {
		resourcesMap["Provenance"] = addInteraction("Provenance", "read")
	}
	if _, ok := w.Concrete.(ProvenanceDelete); ok {
		resourcesMap["Provenance"] = addInteraction("Provenance", "delete")
	}
	if c, ok := w.Concrete.(ProvenanceUpdate); ok {
		r := addInteraction("Provenance", "update")
		c, ok := c.(ProvenanceUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesProvenance(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Provenance"] = r
	}
	if c, ok := w.Concrete.(ProvenanceSearch); ok {
		c, err := c.SearchCapabilitiesProvenance(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Provenance", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Provenance-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Provenance"] = r
		}
	}
	if _, ok := w.Concrete.(QuestionnaireCreate); ok {
		resourcesMap["Questionnaire"] = addInteraction("Questionnaire", "create")
	}
	if _, ok := w.Concrete.(QuestionnaireRead); ok {
		resourcesMap["Questionnaire"] = addInteraction("Questionnaire", "read")
	}
	if _, ok := w.Concrete.(QuestionnaireDelete); ok {
		resourcesMap["Questionnaire"] = addInteraction("Questionnaire", "delete")
	}
	if c, ok := w.Concrete.(QuestionnaireUpdate); ok {
		r := addInteraction("Questionnaire", "update")
		c, ok := c.(QuestionnaireUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesQuestionnaire(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Questionnaire"] = r
	}
	if c, ok := w.Concrete.(QuestionnaireSearch); ok {
		c, err := c.SearchCapabilitiesQuestionnaire(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Questionnaire", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Questionnaire-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Questionnaire"] = r
		}
	}
	if _, ok := w.Concrete.(QuestionnaireResponseCreate); ok {
		resourcesMap["QuestionnaireResponse"] = addInteraction("QuestionnaireResponse", "create")
	}
	if _, ok := w.Concrete.(QuestionnaireResponseRead); ok {
		resourcesMap["QuestionnaireResponse"] = addInteraction("QuestionnaireResponse", "read")
	}
	if _, ok := w.Concrete.(QuestionnaireResponseDelete); ok {
		resourcesMap["QuestionnaireResponse"] = addInteraction("QuestionnaireResponse", "delete")
	}
	if c, ok := w.Concrete.(QuestionnaireResponseUpdate); ok {
		r := addInteraction("QuestionnaireResponse", "update")
		c, ok := c.(QuestionnaireResponseUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesQuestionnaireResponse(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["QuestionnaireResponse"] = r
	}
	if c, ok := w.Concrete.(QuestionnaireResponseSearch); ok {
		c, err := c.SearchCapabilitiesQuestionnaireResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("QuestionnaireResponse", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("QuestionnaireResponse-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["QuestionnaireResponse"] = r
		}
	}
	if _, ok := w.Concrete.(RelatedPersonCreate); ok {
		resourcesMap["RelatedPerson"] = addInteraction("RelatedPerson", "create")
	}
	if _, ok := w.Concrete.(RelatedPersonRead); ok {
		resourcesMap["RelatedPerson"] = addInteraction("RelatedPerson", "read")
	}
	if _, ok := w.Concrete.(RelatedPersonDelete); ok {
		resourcesMap["RelatedPerson"] = addInteraction("RelatedPerson", "delete")
	}
	if c, ok := w.Concrete.(RelatedPersonUpdate); ok {
		r := addInteraction("RelatedPerson", "update")
		c, ok := c.(RelatedPersonUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesRelatedPerson(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["RelatedPerson"] = r
	}
	if c, ok := w.Concrete.(RelatedPersonSearch); ok {
		c, err := c.SearchCapabilitiesRelatedPerson(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("RelatedPerson", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("RelatedPerson-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["RelatedPerson"] = r
		}
	}
	if _, ok := w.Concrete.(RequestGroupCreate); ok {
		resourcesMap["RequestGroup"] = addInteraction("RequestGroup", "create")
	}
	if _, ok := w.Concrete.(RequestGroupRead); ok {
		resourcesMap["RequestGroup"] = addInteraction("RequestGroup", "read")
	}
	if _, ok := w.Concrete.(RequestGroupDelete); ok {
		resourcesMap["RequestGroup"] = addInteraction("RequestGroup", "delete")
	}
	if c, ok := w.Concrete.(RequestGroupUpdate); ok {
		r := addInteraction("RequestGroup", "update")
		c, ok := c.(RequestGroupUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesRequestGroup(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["RequestGroup"] = r
	}
	if c, ok := w.Concrete.(RequestGroupSearch); ok {
		c, err := c.SearchCapabilitiesRequestGroup(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("RequestGroup", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("RequestGroup-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["RequestGroup"] = r
		}
	}
	if _, ok := w.Concrete.(ResearchDefinitionCreate); ok {
		resourcesMap["ResearchDefinition"] = addInteraction("ResearchDefinition", "create")
	}
	if _, ok := w.Concrete.(ResearchDefinitionRead); ok {
		resourcesMap["ResearchDefinition"] = addInteraction("ResearchDefinition", "read")
	}
	if _, ok := w.Concrete.(ResearchDefinitionDelete); ok {
		resourcesMap["ResearchDefinition"] = addInteraction("ResearchDefinition", "delete")
	}
	if c, ok := w.Concrete.(ResearchDefinitionUpdate); ok {
		r := addInteraction("ResearchDefinition", "update")
		c, ok := c.(ResearchDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesResearchDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ResearchDefinition"] = r
	}
	if c, ok := w.Concrete.(ResearchDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesResearchDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ResearchDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ResearchDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ResearchDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(ResearchElementDefinitionCreate); ok {
		resourcesMap["ResearchElementDefinition"] = addInteraction("ResearchElementDefinition", "create")
	}
	if _, ok := w.Concrete.(ResearchElementDefinitionRead); ok {
		resourcesMap["ResearchElementDefinition"] = addInteraction("ResearchElementDefinition", "read")
	}
	if _, ok := w.Concrete.(ResearchElementDefinitionDelete); ok {
		resourcesMap["ResearchElementDefinition"] = addInteraction("ResearchElementDefinition", "delete")
	}
	if c, ok := w.Concrete.(ResearchElementDefinitionUpdate); ok {
		r := addInteraction("ResearchElementDefinition", "update")
		c, ok := c.(ResearchElementDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesResearchElementDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ResearchElementDefinition"] = r
	}
	if c, ok := w.Concrete.(ResearchElementDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesResearchElementDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ResearchElementDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ResearchElementDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ResearchElementDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(ResearchStudyCreate); ok {
		resourcesMap["ResearchStudy"] = addInteraction("ResearchStudy", "create")
	}
	if _, ok := w.Concrete.(ResearchStudyRead); ok {
		resourcesMap["ResearchStudy"] = addInteraction("ResearchStudy", "read")
	}
	if _, ok := w.Concrete.(ResearchStudyDelete); ok {
		resourcesMap["ResearchStudy"] = addInteraction("ResearchStudy", "delete")
	}
	if c, ok := w.Concrete.(ResearchStudyUpdate); ok {
		r := addInteraction("ResearchStudy", "update")
		c, ok := c.(ResearchStudyUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesResearchStudy(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ResearchStudy"] = r
	}
	if c, ok := w.Concrete.(ResearchStudySearch); ok {
		c, err := c.SearchCapabilitiesResearchStudy(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ResearchStudy", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ResearchStudy-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ResearchStudy"] = r
		}
	}
	if _, ok := w.Concrete.(ResearchSubjectCreate); ok {
		resourcesMap["ResearchSubject"] = addInteraction("ResearchSubject", "create")
	}
	if _, ok := w.Concrete.(ResearchSubjectRead); ok {
		resourcesMap["ResearchSubject"] = addInteraction("ResearchSubject", "read")
	}
	if _, ok := w.Concrete.(ResearchSubjectDelete); ok {
		resourcesMap["ResearchSubject"] = addInteraction("ResearchSubject", "delete")
	}
	if c, ok := w.Concrete.(ResearchSubjectUpdate); ok {
		r := addInteraction("ResearchSubject", "update")
		c, ok := c.(ResearchSubjectUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesResearchSubject(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ResearchSubject"] = r
	}
	if c, ok := w.Concrete.(ResearchSubjectSearch); ok {
		c, err := c.SearchCapabilitiesResearchSubject(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ResearchSubject", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ResearchSubject-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ResearchSubject"] = r
		}
	}
	if _, ok := w.Concrete.(RiskAssessmentCreate); ok {
		resourcesMap["RiskAssessment"] = addInteraction("RiskAssessment", "create")
	}
	if _, ok := w.Concrete.(RiskAssessmentRead); ok {
		resourcesMap["RiskAssessment"] = addInteraction("RiskAssessment", "read")
	}
	if _, ok := w.Concrete.(RiskAssessmentDelete); ok {
		resourcesMap["RiskAssessment"] = addInteraction("RiskAssessment", "delete")
	}
	if c, ok := w.Concrete.(RiskAssessmentUpdate); ok {
		r := addInteraction("RiskAssessment", "update")
		c, ok := c.(RiskAssessmentUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesRiskAssessment(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["RiskAssessment"] = r
	}
	if c, ok := w.Concrete.(RiskAssessmentSearch); ok {
		c, err := c.SearchCapabilitiesRiskAssessment(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("RiskAssessment", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("RiskAssessment-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["RiskAssessment"] = r
		}
	}
	if _, ok := w.Concrete.(RiskEvidenceSynthesisCreate); ok {
		resourcesMap["RiskEvidenceSynthesis"] = addInteraction("RiskEvidenceSynthesis", "create")
	}
	if _, ok := w.Concrete.(RiskEvidenceSynthesisRead); ok {
		resourcesMap["RiskEvidenceSynthesis"] = addInteraction("RiskEvidenceSynthesis", "read")
	}
	if _, ok := w.Concrete.(RiskEvidenceSynthesisDelete); ok {
		resourcesMap["RiskEvidenceSynthesis"] = addInteraction("RiskEvidenceSynthesis", "delete")
	}
	if c, ok := w.Concrete.(RiskEvidenceSynthesisUpdate); ok {
		r := addInteraction("RiskEvidenceSynthesis", "update")
		c, ok := c.(RiskEvidenceSynthesisUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesRiskEvidenceSynthesis(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["RiskEvidenceSynthesis"] = r
	}
	if c, ok := w.Concrete.(RiskEvidenceSynthesisSearch); ok {
		c, err := c.SearchCapabilitiesRiskEvidenceSynthesis(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("RiskEvidenceSynthesis", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("RiskEvidenceSynthesis-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["RiskEvidenceSynthesis"] = r
		}
	}
	if _, ok := w.Concrete.(ScheduleCreate); ok {
		resourcesMap["Schedule"] = addInteraction("Schedule", "create")
	}
	if _, ok := w.Concrete.(ScheduleRead); ok {
		resourcesMap["Schedule"] = addInteraction("Schedule", "read")
	}
	if _, ok := w.Concrete.(ScheduleDelete); ok {
		resourcesMap["Schedule"] = addInteraction("Schedule", "delete")
	}
	if c, ok := w.Concrete.(ScheduleUpdate); ok {
		r := addInteraction("Schedule", "update")
		c, ok := c.(ScheduleUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSchedule(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Schedule"] = r
	}
	if c, ok := w.Concrete.(ScheduleSearch); ok {
		c, err := c.SearchCapabilitiesSchedule(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Schedule", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Schedule-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Schedule"] = r
		}
	}
	if _, ok := w.Concrete.(SearchParameterCreate); ok {
		resourcesMap["SearchParameter"] = addInteraction("SearchParameter", "create")
	}
	if _, ok := w.Concrete.(SearchParameterRead); ok {
		resourcesMap["SearchParameter"] = addInteraction("SearchParameter", "read")
	}
	if _, ok := w.Concrete.(SearchParameterDelete); ok {
		resourcesMap["SearchParameter"] = addInteraction("SearchParameter", "delete")
	}
	if c, ok := w.Concrete.(SearchParameterUpdate); ok {
		r := addInteraction("SearchParameter", "update")
		c, ok := c.(SearchParameterUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSearchParameter(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SearchParameter"] = r
	}
	if c, ok := w.Concrete.(SearchParameterSearch); ok {
		c, err := c.SearchCapabilitiesSearchParameter(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SearchParameter", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SearchParameter-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SearchParameter"] = r
		}
	}
	if _, ok := w.Concrete.(ServiceRequestCreate); ok {
		resourcesMap["ServiceRequest"] = addInteraction("ServiceRequest", "create")
	}
	if _, ok := w.Concrete.(ServiceRequestRead); ok {
		resourcesMap["ServiceRequest"] = addInteraction("ServiceRequest", "read")
	}
	if _, ok := w.Concrete.(ServiceRequestDelete); ok {
		resourcesMap["ServiceRequest"] = addInteraction("ServiceRequest", "delete")
	}
	if c, ok := w.Concrete.(ServiceRequestUpdate); ok {
		r := addInteraction("ServiceRequest", "update")
		c, ok := c.(ServiceRequestUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesServiceRequest(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ServiceRequest"] = r
	}
	if c, ok := w.Concrete.(ServiceRequestSearch); ok {
		c, err := c.SearchCapabilitiesServiceRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ServiceRequest", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ServiceRequest-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ServiceRequest"] = r
		}
	}
	if _, ok := w.Concrete.(SlotCreate); ok {
		resourcesMap["Slot"] = addInteraction("Slot", "create")
	}
	if _, ok := w.Concrete.(SlotRead); ok {
		resourcesMap["Slot"] = addInteraction("Slot", "read")
	}
	if _, ok := w.Concrete.(SlotDelete); ok {
		resourcesMap["Slot"] = addInteraction("Slot", "delete")
	}
	if c, ok := w.Concrete.(SlotUpdate); ok {
		r := addInteraction("Slot", "update")
		c, ok := c.(SlotUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSlot(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Slot"] = r
	}
	if c, ok := w.Concrete.(SlotSearch); ok {
		c, err := c.SearchCapabilitiesSlot(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Slot", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Slot-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Slot"] = r
		}
	}
	if _, ok := w.Concrete.(SpecimenCreate); ok {
		resourcesMap["Specimen"] = addInteraction("Specimen", "create")
	}
	if _, ok := w.Concrete.(SpecimenRead); ok {
		resourcesMap["Specimen"] = addInteraction("Specimen", "read")
	}
	if _, ok := w.Concrete.(SpecimenDelete); ok {
		resourcesMap["Specimen"] = addInteraction("Specimen", "delete")
	}
	if c, ok := w.Concrete.(SpecimenUpdate); ok {
		r := addInteraction("Specimen", "update")
		c, ok := c.(SpecimenUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSpecimen(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Specimen"] = r
	}
	if c, ok := w.Concrete.(SpecimenSearch); ok {
		c, err := c.SearchCapabilitiesSpecimen(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Specimen", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Specimen-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Specimen"] = r
		}
	}
	if _, ok := w.Concrete.(SpecimenDefinitionCreate); ok {
		resourcesMap["SpecimenDefinition"] = addInteraction("SpecimenDefinition", "create")
	}
	if _, ok := w.Concrete.(SpecimenDefinitionRead); ok {
		resourcesMap["SpecimenDefinition"] = addInteraction("SpecimenDefinition", "read")
	}
	if _, ok := w.Concrete.(SpecimenDefinitionDelete); ok {
		resourcesMap["SpecimenDefinition"] = addInteraction("SpecimenDefinition", "delete")
	}
	if c, ok := w.Concrete.(SpecimenDefinitionUpdate); ok {
		r := addInteraction("SpecimenDefinition", "update")
		c, ok := c.(SpecimenDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSpecimenDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SpecimenDefinition"] = r
	}
	if c, ok := w.Concrete.(SpecimenDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesSpecimenDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SpecimenDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SpecimenDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SpecimenDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(StructureDefinitionCreate); ok {
		resourcesMap["StructureDefinition"] = addInteraction("StructureDefinition", "create")
	}
	if _, ok := w.Concrete.(StructureDefinitionRead); ok {
		resourcesMap["StructureDefinition"] = addInteraction("StructureDefinition", "read")
	}
	if _, ok := w.Concrete.(StructureDefinitionDelete); ok {
		resourcesMap["StructureDefinition"] = addInteraction("StructureDefinition", "delete")
	}
	if c, ok := w.Concrete.(StructureDefinitionUpdate); ok {
		r := addInteraction("StructureDefinition", "update")
		c, ok := c.(StructureDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesStructureDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["StructureDefinition"] = r
	}
	if c, ok := w.Concrete.(StructureDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesStructureDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("StructureDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("StructureDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["StructureDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(StructureMapCreate); ok {
		resourcesMap["StructureMap"] = addInteraction("StructureMap", "create")
	}
	if _, ok := w.Concrete.(StructureMapRead); ok {
		resourcesMap["StructureMap"] = addInteraction("StructureMap", "read")
	}
	if _, ok := w.Concrete.(StructureMapDelete); ok {
		resourcesMap["StructureMap"] = addInteraction("StructureMap", "delete")
	}
	if c, ok := w.Concrete.(StructureMapUpdate); ok {
		r := addInteraction("StructureMap", "update")
		c, ok := c.(StructureMapUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesStructureMap(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["StructureMap"] = r
	}
	if c, ok := w.Concrete.(StructureMapSearch); ok {
		c, err := c.SearchCapabilitiesStructureMap(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("StructureMap", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("StructureMap-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["StructureMap"] = r
		}
	}
	if _, ok := w.Concrete.(SubscriptionCreate); ok {
		resourcesMap["Subscription"] = addInteraction("Subscription", "create")
	}
	if _, ok := w.Concrete.(SubscriptionRead); ok {
		resourcesMap["Subscription"] = addInteraction("Subscription", "read")
	}
	if _, ok := w.Concrete.(SubscriptionDelete); ok {
		resourcesMap["Subscription"] = addInteraction("Subscription", "delete")
	}
	if c, ok := w.Concrete.(SubscriptionUpdate); ok {
		r := addInteraction("Subscription", "update")
		c, ok := c.(SubscriptionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSubscription(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Subscription"] = r
	}
	if c, ok := w.Concrete.(SubscriptionSearch); ok {
		c, err := c.SearchCapabilitiesSubscription(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Subscription", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Subscription-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Subscription"] = r
		}
	}
	if _, ok := w.Concrete.(SubstanceCreate); ok {
		resourcesMap["Substance"] = addInteraction("Substance", "create")
	}
	if _, ok := w.Concrete.(SubstanceRead); ok {
		resourcesMap["Substance"] = addInteraction("Substance", "read")
	}
	if _, ok := w.Concrete.(SubstanceDelete); ok {
		resourcesMap["Substance"] = addInteraction("Substance", "delete")
	}
	if c, ok := w.Concrete.(SubstanceUpdate); ok {
		r := addInteraction("Substance", "update")
		c, ok := c.(SubstanceUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSubstance(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Substance"] = r
	}
	if c, ok := w.Concrete.(SubstanceSearch); ok {
		c, err := c.SearchCapabilitiesSubstance(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Substance", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Substance-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Substance"] = r
		}
	}
	if _, ok := w.Concrete.(SubstanceNucleicAcidCreate); ok {
		resourcesMap["SubstanceNucleicAcid"] = addInteraction("SubstanceNucleicAcid", "create")
	}
	if _, ok := w.Concrete.(SubstanceNucleicAcidRead); ok {
		resourcesMap["SubstanceNucleicAcid"] = addInteraction("SubstanceNucleicAcid", "read")
	}
	if _, ok := w.Concrete.(SubstanceNucleicAcidDelete); ok {
		resourcesMap["SubstanceNucleicAcid"] = addInteraction("SubstanceNucleicAcid", "delete")
	}
	if c, ok := w.Concrete.(SubstanceNucleicAcidUpdate); ok {
		r := addInteraction("SubstanceNucleicAcid", "update")
		c, ok := c.(SubstanceNucleicAcidUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSubstanceNucleicAcid(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SubstanceNucleicAcid"] = r
	}
	if c, ok := w.Concrete.(SubstanceNucleicAcidSearch); ok {
		c, err := c.SearchCapabilitiesSubstanceNucleicAcid(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SubstanceNucleicAcid", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SubstanceNucleicAcid-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SubstanceNucleicAcid"] = r
		}
	}
	if _, ok := w.Concrete.(SubstancePolymerCreate); ok {
		resourcesMap["SubstancePolymer"] = addInteraction("SubstancePolymer", "create")
	}
	if _, ok := w.Concrete.(SubstancePolymerRead); ok {
		resourcesMap["SubstancePolymer"] = addInteraction("SubstancePolymer", "read")
	}
	if _, ok := w.Concrete.(SubstancePolymerDelete); ok {
		resourcesMap["SubstancePolymer"] = addInteraction("SubstancePolymer", "delete")
	}
	if c, ok := w.Concrete.(SubstancePolymerUpdate); ok {
		r := addInteraction("SubstancePolymer", "update")
		c, ok := c.(SubstancePolymerUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSubstancePolymer(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SubstancePolymer"] = r
	}
	if c, ok := w.Concrete.(SubstancePolymerSearch); ok {
		c, err := c.SearchCapabilitiesSubstancePolymer(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SubstancePolymer", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SubstancePolymer-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SubstancePolymer"] = r
		}
	}
	if _, ok := w.Concrete.(SubstanceProteinCreate); ok {
		resourcesMap["SubstanceProtein"] = addInteraction("SubstanceProtein", "create")
	}
	if _, ok := w.Concrete.(SubstanceProteinRead); ok {
		resourcesMap["SubstanceProtein"] = addInteraction("SubstanceProtein", "read")
	}
	if _, ok := w.Concrete.(SubstanceProteinDelete); ok {
		resourcesMap["SubstanceProtein"] = addInteraction("SubstanceProtein", "delete")
	}
	if c, ok := w.Concrete.(SubstanceProteinUpdate); ok {
		r := addInteraction("SubstanceProtein", "update")
		c, ok := c.(SubstanceProteinUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSubstanceProtein(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SubstanceProtein"] = r
	}
	if c, ok := w.Concrete.(SubstanceProteinSearch); ok {
		c, err := c.SearchCapabilitiesSubstanceProtein(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SubstanceProtein", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SubstanceProtein-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SubstanceProtein"] = r
		}
	}
	if _, ok := w.Concrete.(SubstanceReferenceInformationCreate); ok {
		resourcesMap["SubstanceReferenceInformation"] = addInteraction("SubstanceReferenceInformation", "create")
	}
	if _, ok := w.Concrete.(SubstanceReferenceInformationRead); ok {
		resourcesMap["SubstanceReferenceInformation"] = addInteraction("SubstanceReferenceInformation", "read")
	}
	if _, ok := w.Concrete.(SubstanceReferenceInformationDelete); ok {
		resourcesMap["SubstanceReferenceInformation"] = addInteraction("SubstanceReferenceInformation", "delete")
	}
	if c, ok := w.Concrete.(SubstanceReferenceInformationUpdate); ok {
		r := addInteraction("SubstanceReferenceInformation", "update")
		c, ok := c.(SubstanceReferenceInformationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSubstanceReferenceInformation(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SubstanceReferenceInformation"] = r
	}
	if c, ok := w.Concrete.(SubstanceReferenceInformationSearch); ok {
		c, err := c.SearchCapabilitiesSubstanceReferenceInformation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SubstanceReferenceInformation", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SubstanceReferenceInformation-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SubstanceReferenceInformation"] = r
		}
	}
	if _, ok := w.Concrete.(SubstanceSourceMaterialCreate); ok {
		resourcesMap["SubstanceSourceMaterial"] = addInteraction("SubstanceSourceMaterial", "create")
	}
	if _, ok := w.Concrete.(SubstanceSourceMaterialRead); ok {
		resourcesMap["SubstanceSourceMaterial"] = addInteraction("SubstanceSourceMaterial", "read")
	}
	if _, ok := w.Concrete.(SubstanceSourceMaterialDelete); ok {
		resourcesMap["SubstanceSourceMaterial"] = addInteraction("SubstanceSourceMaterial", "delete")
	}
	if c, ok := w.Concrete.(SubstanceSourceMaterialUpdate); ok {
		r := addInteraction("SubstanceSourceMaterial", "update")
		c, ok := c.(SubstanceSourceMaterialUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSubstanceSourceMaterial(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SubstanceSourceMaterial"] = r
	}
	if c, ok := w.Concrete.(SubstanceSourceMaterialSearch); ok {
		c, err := c.SearchCapabilitiesSubstanceSourceMaterial(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SubstanceSourceMaterial", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SubstanceSourceMaterial-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SubstanceSourceMaterial"] = r
		}
	}
	if _, ok := w.Concrete.(SubstanceSpecificationCreate); ok {
		resourcesMap["SubstanceSpecification"] = addInteraction("SubstanceSpecification", "create")
	}
	if _, ok := w.Concrete.(SubstanceSpecificationRead); ok {
		resourcesMap["SubstanceSpecification"] = addInteraction("SubstanceSpecification", "read")
	}
	if _, ok := w.Concrete.(SubstanceSpecificationDelete); ok {
		resourcesMap["SubstanceSpecification"] = addInteraction("SubstanceSpecification", "delete")
	}
	if c, ok := w.Concrete.(SubstanceSpecificationUpdate); ok {
		r := addInteraction("SubstanceSpecification", "update")
		c, ok := c.(SubstanceSpecificationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSubstanceSpecification(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SubstanceSpecification"] = r
	}
	if c, ok := w.Concrete.(SubstanceSpecificationSearch); ok {
		c, err := c.SearchCapabilitiesSubstanceSpecification(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SubstanceSpecification", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SubstanceSpecification-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SubstanceSpecification"] = r
		}
	}
	if _, ok := w.Concrete.(SupplyDeliveryCreate); ok {
		resourcesMap["SupplyDelivery"] = addInteraction("SupplyDelivery", "create")
	}
	if _, ok := w.Concrete.(SupplyDeliveryRead); ok {
		resourcesMap["SupplyDelivery"] = addInteraction("SupplyDelivery", "read")
	}
	if _, ok := w.Concrete.(SupplyDeliveryDelete); ok {
		resourcesMap["SupplyDelivery"] = addInteraction("SupplyDelivery", "delete")
	}
	if c, ok := w.Concrete.(SupplyDeliveryUpdate); ok {
		r := addInteraction("SupplyDelivery", "update")
		c, ok := c.(SupplyDeliveryUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSupplyDelivery(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SupplyDelivery"] = r
	}
	if c, ok := w.Concrete.(SupplyDeliverySearch); ok {
		c, err := c.SearchCapabilitiesSupplyDelivery(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SupplyDelivery", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SupplyDelivery-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SupplyDelivery"] = r
		}
	}
	if _, ok := w.Concrete.(SupplyRequestCreate); ok {
		resourcesMap["SupplyRequest"] = addInteraction("SupplyRequest", "create")
	}
	if _, ok := w.Concrete.(SupplyRequestRead); ok {
		resourcesMap["SupplyRequest"] = addInteraction("SupplyRequest", "read")
	}
	if _, ok := w.Concrete.(SupplyRequestDelete); ok {
		resourcesMap["SupplyRequest"] = addInteraction("SupplyRequest", "delete")
	}
	if c, ok := w.Concrete.(SupplyRequestUpdate); ok {
		r := addInteraction("SupplyRequest", "update")
		c, ok := c.(SupplyRequestUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSupplyRequest(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SupplyRequest"] = r
	}
	if c, ok := w.Concrete.(SupplyRequestSearch); ok {
		c, err := c.SearchCapabilitiesSupplyRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SupplyRequest", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SupplyRequest-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SupplyRequest"] = r
		}
	}
	if _, ok := w.Concrete.(TaskCreate); ok {
		resourcesMap["Task"] = addInteraction("Task", "create")
	}
	if _, ok := w.Concrete.(TaskRead); ok {
		resourcesMap["Task"] = addInteraction("Task", "read")
	}
	if _, ok := w.Concrete.(TaskDelete); ok {
		resourcesMap["Task"] = addInteraction("Task", "delete")
	}
	if c, ok := w.Concrete.(TaskUpdate); ok {
		r := addInteraction("Task", "update")
		c, ok := c.(TaskUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesTask(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Task"] = r
	}
	if c, ok := w.Concrete.(TaskSearch); ok {
		c, err := c.SearchCapabilitiesTask(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Task", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Task-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Task"] = r
		}
	}
	if _, ok := w.Concrete.(TerminologyCapabilitiesCreate); ok {
		resourcesMap["TerminologyCapabilities"] = addInteraction("TerminologyCapabilities", "create")
	}
	if _, ok := w.Concrete.(TerminologyCapabilitiesRead); ok {
		resourcesMap["TerminologyCapabilities"] = addInteraction("TerminologyCapabilities", "read")
	}
	if _, ok := w.Concrete.(TerminologyCapabilitiesDelete); ok {
		resourcesMap["TerminologyCapabilities"] = addInteraction("TerminologyCapabilities", "delete")
	}
	if c, ok := w.Concrete.(TerminologyCapabilitiesUpdate); ok {
		r := addInteraction("TerminologyCapabilities", "update")
		c, ok := c.(TerminologyCapabilitiesUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesTerminologyCapabilities(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["TerminologyCapabilities"] = r
	}
	if c, ok := w.Concrete.(TerminologyCapabilitiesSearch); ok {
		c, err := c.SearchCapabilitiesTerminologyCapabilities(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("TerminologyCapabilities", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("TerminologyCapabilities-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["TerminologyCapabilities"] = r
		}
	}
	if _, ok := w.Concrete.(TestReportCreate); ok {
		resourcesMap["TestReport"] = addInteraction("TestReport", "create")
	}
	if _, ok := w.Concrete.(TestReportRead); ok {
		resourcesMap["TestReport"] = addInteraction("TestReport", "read")
	}
	if _, ok := w.Concrete.(TestReportDelete); ok {
		resourcesMap["TestReport"] = addInteraction("TestReport", "delete")
	}
	if c, ok := w.Concrete.(TestReportUpdate); ok {
		r := addInteraction("TestReport", "update")
		c, ok := c.(TestReportUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesTestReport(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["TestReport"] = r
	}
	if c, ok := w.Concrete.(TestReportSearch); ok {
		c, err := c.SearchCapabilitiesTestReport(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("TestReport", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("TestReport-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["TestReport"] = r
		}
	}
	if _, ok := w.Concrete.(TestScriptCreate); ok {
		resourcesMap["TestScript"] = addInteraction("TestScript", "create")
	}
	if _, ok := w.Concrete.(TestScriptRead); ok {
		resourcesMap["TestScript"] = addInteraction("TestScript", "read")
	}
	if _, ok := w.Concrete.(TestScriptDelete); ok {
		resourcesMap["TestScript"] = addInteraction("TestScript", "delete")
	}
	if c, ok := w.Concrete.(TestScriptUpdate); ok {
		r := addInteraction("TestScript", "update")
		c, ok := c.(TestScriptUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesTestScript(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["TestScript"] = r
	}
	if c, ok := w.Concrete.(TestScriptSearch); ok {
		c, err := c.SearchCapabilitiesTestScript(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("TestScript", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("TestScript-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["TestScript"] = r
		}
	}
	if _, ok := w.Concrete.(ValueSetCreate); ok {
		resourcesMap["ValueSet"] = addInteraction("ValueSet", "create")
	}
	if _, ok := w.Concrete.(ValueSetRead); ok {
		resourcesMap["ValueSet"] = addInteraction("ValueSet", "read")
	}
	if _, ok := w.Concrete.(ValueSetDelete); ok {
		resourcesMap["ValueSet"] = addInteraction("ValueSet", "delete")
	}
	if c, ok := w.Concrete.(ValueSetUpdate); ok {
		r := addInteraction("ValueSet", "update")
		c, ok := c.(ValueSetUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesValueSet(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ValueSet"] = r
	}
	if c, ok := w.Concrete.(ValueSetSearch); ok {
		c, err := c.SearchCapabilitiesValueSet(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ValueSet", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ValueSet-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ValueSet"] = r
		}
	}
	if _, ok := w.Concrete.(VerificationResultCreate); ok {
		resourcesMap["VerificationResult"] = addInteraction("VerificationResult", "create")
	}
	if _, ok := w.Concrete.(VerificationResultRead); ok {
		resourcesMap["VerificationResult"] = addInteraction("VerificationResult", "read")
	}
	if _, ok := w.Concrete.(VerificationResultDelete); ok {
		resourcesMap["VerificationResult"] = addInteraction("VerificationResult", "delete")
	}
	if c, ok := w.Concrete.(VerificationResultUpdate); ok {
		r := addInteraction("VerificationResult", "update")
		c, ok := c.(VerificationResultUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesVerificationResult(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["VerificationResult"] = r
	}
	if c, ok := w.Concrete.(VerificationResultSearch); ok {
		c, err := c.SearchCapabilitiesVerificationResult(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("VerificationResult", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("VerificationResult-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["VerificationResult"] = r
		}
	}
	if _, ok := w.Concrete.(VisionPrescriptionCreate); ok {
		resourcesMap["VisionPrescription"] = addInteraction("VisionPrescription", "create")
	}
	if _, ok := w.Concrete.(VisionPrescriptionRead); ok {
		resourcesMap["VisionPrescription"] = addInteraction("VisionPrescription", "read")
	}
	if _, ok := w.Concrete.(VisionPrescriptionDelete); ok {
		resourcesMap["VisionPrescription"] = addInteraction("VisionPrescription", "delete")
	}
	if c, ok := w.Concrete.(VisionPrescriptionUpdate); ok {
		r := addInteraction("VisionPrescription", "update")
		c, ok := c.(VisionPrescriptionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesVisionPrescription(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["VisionPrescription"] = r
	}
	if c, ok := w.Concrete.(VisionPrescriptionSearch); ok {
		c, err := c.SearchCapabilitiesVisionPrescription(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("VisionPrescription", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("VisionPrescription-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4.String{Value: &n},
					Type:       r4.Code{Value: &resolvedType},
				})
			}
			resourcesMap["VisionPrescription"] = r
		}
	}
	if _, ok := w.Concrete.(SearchParameterSearch); !ok {
		resourcesMap["SearchParameter"] = addInteraction("SearchParameter", "read")
		spResource := addInteraction("SearchParameter", "search-type")
		idParam := "_id"
		tokenType := "token"
		idDefinition := baseUrl + "/SearchParameter/SearchParameter-id"
		spResource.SearchParam = append(spResource.SearchParam, r4.CapabilityStatementRestResourceSearchParam{
			Definition: &r4.Canonical{Value: &idDefinition},
			Name:       r4.String{Value: &idParam},
			Type:       r4.Code{Value: &tokenType},
		})
		resourcesMap["SearchParameter"] = spResource
	}
	if len(errs) > 0 {
		return r4.CapabilityStatement{}, errors.Join(errs...)
	}
	capabilityStatement := baseCapabilityStatement
	if capabilityStatement.FhirVersion.Value == nil {
		capabilityStatement.FhirVersion = r4.Code{Value: ptr.To("4.0")}
	}
	if len(capabilityStatement.Rest) == 0 {
		capabilityStatement.Rest = []r4.CapabilityStatementRest{{Mode: r4.Code{Value: ptr.To("server")}}}
	}
	defs := operationDefinitionsByCode(ctx, w.Concrete)
	var sysOps []r4.CapabilityStatementRestResourceOperation
	for code, entry := range defs {
		id := code
		if entry.Def.Id != nil && entry.Def.Id.Value != nil {
			id = *entry.Def.Id.Value
		}
		canonical := baseUrl + "/OperationDefinition/" + id
		if entry.Def.System.Value != nil && *entry.Def.System.Value {
			sysOps = append(sysOps, r4.CapabilityStatementRestResourceOperation{
				Definition: r4.Canonical{Value: &canonical},
				Name:       r4.String{Value: &code},
			})
		}
		for _, rt := range entry.Def.Resource {
			if rt.Value == nil {
				continue
			}
			rtype := *rt.Value
			r, ok := resourcesMap[rtype]
			if !ok {
				r = r4.CapabilityStatementRestResource{Type: r4.Code{Value: &rtype}}
			}
			r.Operation = append(r.Operation, r4.CapabilityStatementRestResourceOperation{
				Definition: r4.Canonical{Value: &canonical},
				Name:       r4.String{Value: &code},
			})
			resourcesMap[rtype] = r
		}
	}
	capabilityStatement.Rest[0].Operation = sysOps
	resourcesList := make([]r4.CapabilityStatementRestResource, 0, len(resourcesMap))
	for _, r := range resourcesMap {
		slices.SortStableFunc(r.SearchParam, func(a, b r4.CapabilityStatementRestResourceSearchParam) int {
			return cmp.Compare(*a.Name.Value, *b.Name.Value)
		})
		slices.SortStableFunc(r.Interaction, func(a, b r4.CapabilityStatementRestResourceInteraction) int {
			order := map[string]int{
				"create":      1,
				"delete":      4,
				"read":        2,
				"search-type": 5,
				"update":      3,
			}
			aCode := ""
			if a.Code.Value != nil {
				aCode = *a.Code.Value
			}
			bCode := ""
			if b.Code.Value != nil {
				bCode = *b.Code.Value
			}
			return cmp.Compare(order[aCode], order[bCode])
		})
		slices.SortStableFunc(r.Operation, func(a, b r4.CapabilityStatementRestResourceOperation) int {
			return cmp.Compare(*a.Name.Value, *b.Name.Value)
		})
		resourcesList = append(resourcesList, r)
	}
	slices.SortFunc(resourcesList, func(a, b r4.CapabilityStatementRestResource) int {
		return cmp.Compare(*a.Type.Value, *b.Type.Value)
	})
	capabilityStatement.Rest[0].Resource = resourcesList
	return capabilityStatement, nil
}
func searchParameters(ctx context.Context, api any, baseUrl string) (map[string]r4.SearchParameter, error) {
	searchParameters := make(map[string]r4.SearchParameter)
	var errs []error
	if c, ok := api.(AccountSearch); ok {
		c, err := c.SearchCapabilitiesAccount(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Account", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Account"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ActivityDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesActivityDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ActivityDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ActivityDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(AdverseEventSearch); ok {
		c, err := c.SearchCapabilitiesAdverseEvent(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "AdverseEvent", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["AdverseEvent"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(AllergyIntoleranceSearch); ok {
		c, err := c.SearchCapabilitiesAllergyIntolerance(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "AllergyIntolerance", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["AllergyIntolerance"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(AppointmentSearch); ok {
		c, err := c.SearchCapabilitiesAppointment(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Appointment", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Appointment"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(AppointmentResponseSearch); ok {
		c, err := c.SearchCapabilitiesAppointmentResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "AppointmentResponse", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["AppointmentResponse"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(AuditEventSearch); ok {
		c, err := c.SearchCapabilitiesAuditEvent(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "AuditEvent", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["AuditEvent"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(BasicSearch); ok {
		c, err := c.SearchCapabilitiesBasic(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Basic", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Basic"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(BinarySearch); ok {
		c, err := c.SearchCapabilitiesBinary(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Binary", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Binary"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(BiologicallyDerivedProductSearch); ok {
		c, err := c.SearchCapabilitiesBiologicallyDerivedProduct(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "BiologicallyDerivedProduct", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["BiologicallyDerivedProduct"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(BodyStructureSearch); ok {
		c, err := c.SearchCapabilitiesBodyStructure(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "BodyStructure", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["BodyStructure"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(BundleSearch); ok {
		c, err := c.SearchCapabilitiesBundle(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Bundle", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Bundle"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CapabilityStatementSearch); ok {
		c, err := c.SearchCapabilitiesCapabilityStatement(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "CapabilityStatement", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["CapabilityStatement"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CarePlanSearch); ok {
		c, err := c.SearchCapabilitiesCarePlan(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "CarePlan", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["CarePlan"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CareTeamSearch); ok {
		c, err := c.SearchCapabilitiesCareTeam(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "CareTeam", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["CareTeam"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CatalogEntrySearch); ok {
		c, err := c.SearchCapabilitiesCatalogEntry(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "CatalogEntry", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["CatalogEntry"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ChargeItemSearch); ok {
		c, err := c.SearchCapabilitiesChargeItem(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ChargeItem", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ChargeItem"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ChargeItemDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesChargeItemDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ChargeItemDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ChargeItemDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ClaimSearch); ok {
		c, err := c.SearchCapabilitiesClaim(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Claim", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Claim"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ClaimResponseSearch); ok {
		c, err := c.SearchCapabilitiesClaimResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ClaimResponse", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ClaimResponse"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ClinicalImpressionSearch); ok {
		c, err := c.SearchCapabilitiesClinicalImpression(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ClinicalImpression", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ClinicalImpression"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CodeSystemSearch); ok {
		c, err := c.SearchCapabilitiesCodeSystem(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "CodeSystem", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["CodeSystem"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CommunicationSearch); ok {
		c, err := c.SearchCapabilitiesCommunication(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Communication", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Communication"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CommunicationRequestSearch); ok {
		c, err := c.SearchCapabilitiesCommunicationRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "CommunicationRequest", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["CommunicationRequest"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CompartmentDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesCompartmentDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "CompartmentDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["CompartmentDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CompositionSearch); ok {
		c, err := c.SearchCapabilitiesComposition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Composition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Composition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ConceptMapSearch); ok {
		c, err := c.SearchCapabilitiesConceptMap(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ConceptMap", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ConceptMap"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ConditionSearch); ok {
		c, err := c.SearchCapabilitiesCondition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Condition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Condition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ConsentSearch); ok {
		c, err := c.SearchCapabilitiesConsent(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Consent", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Consent"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ContractSearch); ok {
		c, err := c.SearchCapabilitiesContract(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Contract", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Contract"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CoverageSearch); ok {
		c, err := c.SearchCapabilitiesCoverage(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Coverage", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Coverage"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CoverageEligibilityRequestSearch); ok {
		c, err := c.SearchCapabilitiesCoverageEligibilityRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "CoverageEligibilityRequest", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["CoverageEligibilityRequest"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CoverageEligibilityResponseSearch); ok {
		c, err := c.SearchCapabilitiesCoverageEligibilityResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "CoverageEligibilityResponse", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["CoverageEligibilityResponse"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DetectedIssueSearch); ok {
		c, err := c.SearchCapabilitiesDetectedIssue(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "DetectedIssue", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["DetectedIssue"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DeviceSearch); ok {
		c, err := c.SearchCapabilitiesDevice(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Device", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Device"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DeviceDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesDeviceDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "DeviceDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["DeviceDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DeviceMetricSearch); ok {
		c, err := c.SearchCapabilitiesDeviceMetric(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "DeviceMetric", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["DeviceMetric"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DeviceRequestSearch); ok {
		c, err := c.SearchCapabilitiesDeviceRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "DeviceRequest", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["DeviceRequest"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DeviceUseStatementSearch); ok {
		c, err := c.SearchCapabilitiesDeviceUseStatement(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "DeviceUseStatement", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["DeviceUseStatement"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DiagnosticReportSearch); ok {
		c, err := c.SearchCapabilitiesDiagnosticReport(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "DiagnosticReport", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["DiagnosticReport"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DocumentManifestSearch); ok {
		c, err := c.SearchCapabilitiesDocumentManifest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "DocumentManifest", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["DocumentManifest"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DocumentReferenceSearch); ok {
		c, err := c.SearchCapabilitiesDocumentReference(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "DocumentReference", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["DocumentReference"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EffectEvidenceSynthesisSearch); ok {
		c, err := c.SearchCapabilitiesEffectEvidenceSynthesis(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "EffectEvidenceSynthesis", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["EffectEvidenceSynthesis"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EncounterSearch); ok {
		c, err := c.SearchCapabilitiesEncounter(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Encounter", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Encounter"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EndpointSearch); ok {
		c, err := c.SearchCapabilitiesEndpoint(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Endpoint", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Endpoint"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EnrollmentRequestSearch); ok {
		c, err := c.SearchCapabilitiesEnrollmentRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "EnrollmentRequest", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["EnrollmentRequest"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EnrollmentResponseSearch); ok {
		c, err := c.SearchCapabilitiesEnrollmentResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "EnrollmentResponse", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["EnrollmentResponse"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EpisodeOfCareSearch); ok {
		c, err := c.SearchCapabilitiesEpisodeOfCare(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "EpisodeOfCare", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["EpisodeOfCare"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EventDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesEventDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "EventDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["EventDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EvidenceSearch); ok {
		c, err := c.SearchCapabilitiesEvidence(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Evidence", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Evidence"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EvidenceVariableSearch); ok {
		c, err := c.SearchCapabilitiesEvidenceVariable(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "EvidenceVariable", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["EvidenceVariable"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ExampleScenarioSearch); ok {
		c, err := c.SearchCapabilitiesExampleScenario(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ExampleScenario", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ExampleScenario"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ExplanationOfBenefitSearch); ok {
		c, err := c.SearchCapabilitiesExplanationOfBenefit(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ExplanationOfBenefit", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ExplanationOfBenefit"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(FamilyMemberHistorySearch); ok {
		c, err := c.SearchCapabilitiesFamilyMemberHistory(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "FamilyMemberHistory", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["FamilyMemberHistory"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(FlagSearch); ok {
		c, err := c.SearchCapabilitiesFlag(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Flag", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Flag"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(GoalSearch); ok {
		c, err := c.SearchCapabilitiesGoal(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Goal", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Goal"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(GraphDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesGraphDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "GraphDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["GraphDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(GroupSearch); ok {
		c, err := c.SearchCapabilitiesGroup(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Group", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Group"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(GuidanceResponseSearch); ok {
		c, err := c.SearchCapabilitiesGuidanceResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "GuidanceResponse", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["GuidanceResponse"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(HealthcareServiceSearch); ok {
		c, err := c.SearchCapabilitiesHealthcareService(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "HealthcareService", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["HealthcareService"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ImagingStudySearch); ok {
		c, err := c.SearchCapabilitiesImagingStudy(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ImagingStudy", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ImagingStudy"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ImmunizationSearch); ok {
		c, err := c.SearchCapabilitiesImmunization(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Immunization", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Immunization"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ImmunizationEvaluationSearch); ok {
		c, err := c.SearchCapabilitiesImmunizationEvaluation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ImmunizationEvaluation", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ImmunizationEvaluation"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ImmunizationRecommendationSearch); ok {
		c, err := c.SearchCapabilitiesImmunizationRecommendation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ImmunizationRecommendation", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ImmunizationRecommendation"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ImplementationGuideSearch); ok {
		c, err := c.SearchCapabilitiesImplementationGuide(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ImplementationGuide", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ImplementationGuide"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(InsurancePlanSearch); ok {
		c, err := c.SearchCapabilitiesInsurancePlan(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "InsurancePlan", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["InsurancePlan"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(InvoiceSearch); ok {
		c, err := c.SearchCapabilitiesInvoice(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Invoice", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Invoice"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(LibrarySearch); ok {
		c, err := c.SearchCapabilitiesLibrary(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Library", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Library"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(LinkageSearch); ok {
		c, err := c.SearchCapabilitiesLinkage(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Linkage", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Linkage"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ListSearch); ok {
		c, err := c.SearchCapabilitiesList(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "List", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["List"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(LocationSearch); ok {
		c, err := c.SearchCapabilitiesLocation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Location", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Location"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MeasureSearch); ok {
		c, err := c.SearchCapabilitiesMeasure(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Measure", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Measure"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MeasureReportSearch); ok {
		c, err := c.SearchCapabilitiesMeasureReport(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MeasureReport", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MeasureReport"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MediaSearch); ok {
		c, err := c.SearchCapabilitiesMedia(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Media", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Media"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicationSearch); ok {
		c, err := c.SearchCapabilitiesMedication(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Medication", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Medication"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicationAdministrationSearch); ok {
		c, err := c.SearchCapabilitiesMedicationAdministration(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MedicationAdministration", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MedicationAdministration"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicationDispenseSearch); ok {
		c, err := c.SearchCapabilitiesMedicationDispense(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MedicationDispense", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MedicationDispense"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicationKnowledgeSearch); ok {
		c, err := c.SearchCapabilitiesMedicationKnowledge(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MedicationKnowledge", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MedicationKnowledge"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicationRequestSearch); ok {
		c, err := c.SearchCapabilitiesMedicationRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MedicationRequest", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MedicationRequest"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicationStatementSearch); ok {
		c, err := c.SearchCapabilitiesMedicationStatement(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MedicationStatement", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MedicationStatement"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicinalProductSearch); ok {
		c, err := c.SearchCapabilitiesMedicinalProduct(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MedicinalProduct", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MedicinalProduct"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicinalProductAuthorizationSearch); ok {
		c, err := c.SearchCapabilitiesMedicinalProductAuthorization(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MedicinalProductAuthorization", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MedicinalProductAuthorization"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicinalProductContraindicationSearch); ok {
		c, err := c.SearchCapabilitiesMedicinalProductContraindication(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MedicinalProductContraindication", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MedicinalProductContraindication"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicinalProductIndicationSearch); ok {
		c, err := c.SearchCapabilitiesMedicinalProductIndication(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MedicinalProductIndication", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MedicinalProductIndication"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicinalProductIngredientSearch); ok {
		c, err := c.SearchCapabilitiesMedicinalProductIngredient(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MedicinalProductIngredient", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MedicinalProductIngredient"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicinalProductInteractionSearch); ok {
		c, err := c.SearchCapabilitiesMedicinalProductInteraction(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MedicinalProductInteraction", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MedicinalProductInteraction"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicinalProductManufacturedSearch); ok {
		c, err := c.SearchCapabilitiesMedicinalProductManufactured(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MedicinalProductManufactured", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MedicinalProductManufactured"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicinalProductPackagedSearch); ok {
		c, err := c.SearchCapabilitiesMedicinalProductPackaged(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MedicinalProductPackaged", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MedicinalProductPackaged"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicinalProductPharmaceuticalSearch); ok {
		c, err := c.SearchCapabilitiesMedicinalProductPharmaceutical(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MedicinalProductPharmaceutical", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MedicinalProductPharmaceutical"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicinalProductUndesirableEffectSearch); ok {
		c, err := c.SearchCapabilitiesMedicinalProductUndesirableEffect(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MedicinalProductUndesirableEffect", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MedicinalProductUndesirableEffect"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MessageDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesMessageDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MessageDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MessageDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MessageHeaderSearch); ok {
		c, err := c.SearchCapabilitiesMessageHeader(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MessageHeader", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MessageHeader"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MolecularSequenceSearch); ok {
		c, err := c.SearchCapabilitiesMolecularSequence(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MolecularSequence", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MolecularSequence"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(NamingSystemSearch); ok {
		c, err := c.SearchCapabilitiesNamingSystem(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "NamingSystem", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["NamingSystem"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(NutritionOrderSearch); ok {
		c, err := c.SearchCapabilitiesNutritionOrder(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "NutritionOrder", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["NutritionOrder"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ObservationSearch); ok {
		c, err := c.SearchCapabilitiesObservation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Observation", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Observation"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ObservationDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesObservationDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ObservationDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ObservationDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(OperationDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesOperationDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "OperationDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["OperationDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(OperationOutcomeSearch); ok {
		c, err := c.SearchCapabilitiesOperationOutcome(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "OperationOutcome", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["OperationOutcome"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(OrganizationSearch); ok {
		c, err := c.SearchCapabilitiesOrganization(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Organization", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Organization"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(OrganizationAffiliationSearch); ok {
		c, err := c.SearchCapabilitiesOrganizationAffiliation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "OrganizationAffiliation", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["OrganizationAffiliation"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ParametersSearch); ok {
		c, err := c.SearchCapabilitiesParameters(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Parameters", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Parameters"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(PatientSearch); ok {
		c, err := c.SearchCapabilitiesPatient(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Patient", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Patient"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(PaymentNoticeSearch); ok {
		c, err := c.SearchCapabilitiesPaymentNotice(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "PaymentNotice", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["PaymentNotice"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(PaymentReconciliationSearch); ok {
		c, err := c.SearchCapabilitiesPaymentReconciliation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "PaymentReconciliation", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["PaymentReconciliation"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(PersonSearch); ok {
		c, err := c.SearchCapabilitiesPerson(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Person", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Person"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(PlanDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesPlanDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "PlanDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["PlanDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(PractitionerSearch); ok {
		c, err := c.SearchCapabilitiesPractitioner(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Practitioner", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Practitioner"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(PractitionerRoleSearch); ok {
		c, err := c.SearchCapabilitiesPractitionerRole(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "PractitionerRole", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["PractitionerRole"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ProcedureSearch); ok {
		c, err := c.SearchCapabilitiesProcedure(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Procedure", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Procedure"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ProvenanceSearch); ok {
		c, err := c.SearchCapabilitiesProvenance(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Provenance", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Provenance"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(QuestionnaireSearch); ok {
		c, err := c.SearchCapabilitiesQuestionnaire(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Questionnaire", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Questionnaire"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(QuestionnaireResponseSearch); ok {
		c, err := c.SearchCapabilitiesQuestionnaireResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "QuestionnaireResponse", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["QuestionnaireResponse"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(RelatedPersonSearch); ok {
		c, err := c.SearchCapabilitiesRelatedPerson(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "RelatedPerson", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["RelatedPerson"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(RequestGroupSearch); ok {
		c, err := c.SearchCapabilitiesRequestGroup(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "RequestGroup", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["RequestGroup"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ResearchDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesResearchDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ResearchDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ResearchDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ResearchElementDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesResearchElementDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ResearchElementDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ResearchElementDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ResearchStudySearch); ok {
		c, err := c.SearchCapabilitiesResearchStudy(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ResearchStudy", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ResearchStudy"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ResearchSubjectSearch); ok {
		c, err := c.SearchCapabilitiesResearchSubject(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ResearchSubject", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ResearchSubject"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(RiskAssessmentSearch); ok {
		c, err := c.SearchCapabilitiesRiskAssessment(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "RiskAssessment", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["RiskAssessment"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(RiskEvidenceSynthesisSearch); ok {
		c, err := c.SearchCapabilitiesRiskEvidenceSynthesis(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "RiskEvidenceSynthesis", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["RiskEvidenceSynthesis"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ScheduleSearch); ok {
		c, err := c.SearchCapabilitiesSchedule(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Schedule", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Schedule"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SearchParameterSearch); ok {
		c, err := c.SearchCapabilitiesSearchParameter(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SearchParameter", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SearchParameter"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ServiceRequestSearch); ok {
		c, err := c.SearchCapabilitiesServiceRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ServiceRequest", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ServiceRequest"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SlotSearch); ok {
		c, err := c.SearchCapabilitiesSlot(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Slot", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Slot"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SpecimenSearch); ok {
		c, err := c.SearchCapabilitiesSpecimen(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Specimen", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Specimen"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SpecimenDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesSpecimenDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SpecimenDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SpecimenDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(StructureDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesStructureDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "StructureDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["StructureDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(StructureMapSearch); ok {
		c, err := c.SearchCapabilitiesStructureMap(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "StructureMap", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["StructureMap"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SubscriptionSearch); ok {
		c, err := c.SearchCapabilitiesSubscription(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Subscription", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Subscription"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SubstanceSearch); ok {
		c, err := c.SearchCapabilitiesSubstance(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Substance", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Substance"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SubstanceNucleicAcidSearch); ok {
		c, err := c.SearchCapabilitiesSubstanceNucleicAcid(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SubstanceNucleicAcid", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SubstanceNucleicAcid"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SubstancePolymerSearch); ok {
		c, err := c.SearchCapabilitiesSubstancePolymer(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SubstancePolymer", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SubstancePolymer"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SubstanceProteinSearch); ok {
		c, err := c.SearchCapabilitiesSubstanceProtein(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SubstanceProtein", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SubstanceProtein"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SubstanceReferenceInformationSearch); ok {
		c, err := c.SearchCapabilitiesSubstanceReferenceInformation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SubstanceReferenceInformation", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SubstanceReferenceInformation"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SubstanceSourceMaterialSearch); ok {
		c, err := c.SearchCapabilitiesSubstanceSourceMaterial(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SubstanceSourceMaterial", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SubstanceSourceMaterial"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SubstanceSpecificationSearch); ok {
		c, err := c.SearchCapabilitiesSubstanceSpecification(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SubstanceSpecification", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SubstanceSpecification"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SupplyDeliverySearch); ok {
		c, err := c.SearchCapabilitiesSupplyDelivery(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SupplyDelivery", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SupplyDelivery"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SupplyRequestSearch); ok {
		c, err := c.SearchCapabilitiesSupplyRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SupplyRequest", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SupplyRequest"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(TaskSearch); ok {
		c, err := c.SearchCapabilitiesTask(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Task", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Task"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(TerminologyCapabilitiesSearch); ok {
		c, err := c.SearchCapabilitiesTerminologyCapabilities(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "TerminologyCapabilities", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["TerminologyCapabilities"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(TestReportSearch); ok {
		c, err := c.SearchCapabilitiesTestReport(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "TestReport", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["TestReport"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(TestScriptSearch); ok {
		c, err := c.SearchCapabilitiesTestScript(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "TestScript", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["TestScript"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ValueSetSearch); ok {
		c, err := c.SearchCapabilitiesValueSet(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ValueSet", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ValueSet"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(VerificationResultSearch); ok {
		c, err := c.SearchCapabilitiesVerificationResult(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "VerificationResult", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["VerificationResult"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(VisionPrescriptionSearch); ok {
		c, err := c.SearchCapabilitiesVisionPrescription(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "VisionPrescription", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["VisionPrescription"+"-"+n] = populatedParam
				}
			}
		}
	}
	if len(errs) > 0 {
		return nil, errors.Join(errs...)
	}
	if _, ok := api.(SearchParameterSearch); !ok {
		idParam := r4.SearchParameter{
			Base:        []r4.Code{r4.Code{Value: ptr.To("SearchParameter")}},
			Code:        r4.Code{Value: ptr.To("_id")},
			Description: r4.Markdown{Value: ptr.To("Logical id of this artifact")},
			Expression:  &r4.String{Value: ptr.To("SearchParameter.id")},
			Id:          &r4.Id{Value: ptr.To("SearchParameter-id")},
			Name:        r4.String{Value: ptr.To("_id")},
			Status:      r4.Code{Value: ptr.To("active")},
			Type:        r4.Code{Value: ptr.To("token")},
			Url:         r4.Uri{Value: ptr.To(baseUrl + "/SearchParameter/SearchParameter-id")},
		}
		searchParameters["SearchParameter-id"] = idParam
	}
	return searchParameters, nil
}
func sanitizeIdentifier(input string) string {
	result := strings.ReplaceAll(input, "_", "")
	return result
}
func populateSearchParameter(searchParam r4.SearchParameter, resourceType string, paramName string, baseUrl string) r4.SearchParameter {
	_, idOk, idErr := fhirpath.Singleton[fhirpath.String](searchParam.Children("id"))
	if !idOk || idErr != nil {
		// Set auto-generated ID using pattern {resourceType}-{name} (FHIR-compliant)
		id := sanitizeIdentifier(resourceType + "-" + paramName)
		searchParam.Id = &r4.Id{Value: ptr.To(id)}
	}
	_, urlOk, urlErr := fhirpath.Singleton[fhirpath.String](searchParam.Children("url"))
	if !urlOk || urlErr != nil {
		// Set canonical URL using sanitized ID
		canonicalUrl := baseUrl + "/SearchParameter/" + *searchParam.Id.Value
		searchParam.Url = r4.Uri{Value: ptr.To(canonicalUrl)}
	}
	_, nameOk, nameErr := fhirpath.Singleton[fhirpath.String](searchParam.Children("name"))
	if !nameOk || nameErr != nil {
		// Set name based on parameter name
		searchParam.Name = r4.String{Value: ptr.To(paramName)}
	}
	_, statusOk, statusErr := fhirpath.Singleton[fhirpath.String](searchParam.Children("status"))
	if !statusOk || statusErr != nil {
		// Set default status to active
		searchParam.Status = r4.Code{Value: ptr.To("active")}
	}
	_, codeOk, codeErr := fhirpath.Singleton[fhirpath.String](searchParam.Children("code"))
	if !codeOk || codeErr != nil {
		// Set code based on parameter name
		searchParam.Code = r4.Code{Value: ptr.To(paramName)}
	}
	baseElements := searchParam.Children("base")
	if len(baseElements) == 0 {
		// Set base resource type
		searchParam.Base = []r4.Code{{Value: ptr.To(resourceType)}}
	}
	_, descOk, descErr := fhirpath.Singleton[fhirpath.String](searchParam.Children("description"))
	if !descOk || descErr != nil {
		// Set default description
		description := "Search parameter " + paramName + " for " + resourceType + " resource"
		searchParam.Description = r4.Markdown{Value: ptr.To(description)}
	}
	return searchParam
}
func operationDefinitionsByCode(ctx context.Context, api any) map[string]struct {
	Base string
	Def  r4.OperationDefinition
} {
	defs := make(map[string]struct {
		Base string
		Def  r4.OperationDefinition
	})
	ctxT := reflect.TypeOf((*context.Context)(nil)).Elem()
	t := reflect.TypeOf(api)
	v := reflect.ValueOf(api)
	for i := 0; i < t.NumMethod(); i++ {
		m := t.Method(i)
		name := m.Name
		if !strings.HasSuffix(name, "Definition") && !strings.HasSuffix(name, "OperationDefinition") {
			continue
		}
		mv := v.MethodByName(name)
		mt := mv.Type()
		if (mt.NumIn() != 0) && (mt.NumIn() != 1) {
			continue
		}
		if mt.NumOut() != 1 {
			continue
		}
		if mt.Out(0) != reflect.TypeOf(r4.OperationDefinition{}) {
			continue
		}
		args := []reflect.Value{}
		if mt.NumIn() == 1 {
			if mt.In(0) != ctxT {
				continue
			}
			args = append(args, reflect.ValueOf(ctx))
		}
		out := mv.Call(args)
		od := out[0].Interface().(r4.OperationDefinition)
		base := name
		base = strings.TrimSuffix(base, "OperationDefinition")
		base = strings.TrimSuffix(base, "Definition")
		code := strings.ToLower(base)
		if od.Code.Value != nil {
			code = strings.ToLower(*od.Code.Value)
		}
		defs[code] = struct {
			Base string
			Def  r4.OperationDefinition
		}{
			Base: base,
			Def:  od,
		}
	}
	return defs
}
func operationDefinitionsByID(ctx context.Context, api any, baseUrl string) (map[string]r4.OperationDefinition, error) {
	defs := make(map[string]r4.OperationDefinition)
	ctxT := reflect.TypeOf((*context.Context)(nil)).Elem()
	t := reflect.TypeOf(api)
	v := reflect.ValueOf(api)
	for i := 0; i < t.NumMethod(); i++ {
		m := t.Method(i)
		name := m.Name
		if !strings.HasSuffix(name, "Definition") && !strings.HasSuffix(name, "OperationDefinition") {
			continue
		}
		mv := v.MethodByName(name)
		mt := mv.Type()
		if (mt.NumIn() != 0) && (mt.NumIn() != 1) {
			continue
		}
		if mt.NumOut() != 1 {
			continue
		}
		if mt.Out(0) != reflect.TypeOf(r4.OperationDefinition{}) {
			continue
		}
		args := []reflect.Value{}
		if mt.NumIn() == 1 {
			if mt.In(0) != ctxT {
				continue
			}
			args = append(args, reflect.ValueOf(ctx))
		}
		out := mv.Call(args)
		od := out[0].Interface().(r4.OperationDefinition)
		base := name
		base = strings.TrimSuffix(base, "OperationDefinition")
		base = strings.TrimSuffix(base, "Definition")
		code := strings.ToLower(base)
		if od.Code.Value != nil {
			code = strings.ToLower(*od.Code.Value)
		}
		id := code
		if od.Id != nil && od.Id.Value != nil {
			id = *od.Id.Value
		} else {
			od.Id = &r4.Id{Value: ptr.To(id)}
		}
		if baseUrl != "" {
			canonical := baseUrl + "/OperationDefinition/" + id
			od.Url = &r4.Uri{Value: ptr.To(canonical)}
		}
		defs[id] = od
	}
	return defs, nil
}
func (w Generic) Create(ctx context.Context, resource model.Resource) (model.Resource, error) {
	g, ok := w.Concrete.(capabilities.GenericCreate)
	if ok {
		// shortcut for the case that the underlying implementation already implements the generic API
		return g.Create(ctx, resource)
	}
	switch r := resource.(type) {
	case r4.Account:
		impl, ok := w.Concrete.(AccountCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Account")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateAccount(ctx, r)
	case r4.ActivityDefinition:
		impl, ok := w.Concrete.(ActivityDefinitionCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for ActivityDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateActivityDefinition(ctx, r)
	case r4.AdverseEvent:
		impl, ok := w.Concrete.(AdverseEventCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for AdverseEvent")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateAdverseEvent(ctx, r)
	case r4.AllergyIntolerance:
		impl, ok := w.Concrete.(AllergyIntoleranceCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for AllergyIntolerance")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateAllergyIntolerance(ctx, r)
	case r4.Appointment:
		impl, ok := w.Concrete.(AppointmentCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Appointment")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateAppointment(ctx, r)
	case r4.AppointmentResponse:
		impl, ok := w.Concrete.(AppointmentResponseCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for AppointmentResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateAppointmentResponse(ctx, r)
	case r4.AuditEvent:
		impl, ok := w.Concrete.(AuditEventCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for AuditEvent")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateAuditEvent(ctx, r)
	case r4.Basic:
		impl, ok := w.Concrete.(BasicCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Basic")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateBasic(ctx, r)
	case r4.Binary:
		impl, ok := w.Concrete.(BinaryCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Binary")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateBinary(ctx, r)
	case r4.BiologicallyDerivedProduct:
		impl, ok := w.Concrete.(BiologicallyDerivedProductCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for BiologicallyDerivedProduct")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateBiologicallyDerivedProduct(ctx, r)
	case r4.BodyStructure:
		impl, ok := w.Concrete.(BodyStructureCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for BodyStructure")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateBodyStructure(ctx, r)
	case r4.Bundle:
		impl, ok := w.Concrete.(BundleCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Bundle")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateBundle(ctx, r)
	case r4.CapabilityStatement:
		impl, ok := w.Concrete.(CapabilityStatementCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for CapabilityStatement")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateCapabilityStatement(ctx, r)
	case r4.CarePlan:
		impl, ok := w.Concrete.(CarePlanCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for CarePlan")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateCarePlan(ctx, r)
	case r4.CareTeam:
		impl, ok := w.Concrete.(CareTeamCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for CareTeam")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateCareTeam(ctx, r)
	case r4.CatalogEntry:
		impl, ok := w.Concrete.(CatalogEntryCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for CatalogEntry")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateCatalogEntry(ctx, r)
	case r4.ChargeItem:
		impl, ok := w.Concrete.(ChargeItemCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for ChargeItem")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateChargeItem(ctx, r)
	case r4.ChargeItemDefinition:
		impl, ok := w.Concrete.(ChargeItemDefinitionCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for ChargeItemDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateChargeItemDefinition(ctx, r)
	case r4.Claim:
		impl, ok := w.Concrete.(ClaimCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Claim")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateClaim(ctx, r)
	case r4.ClaimResponse:
		impl, ok := w.Concrete.(ClaimResponseCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for ClaimResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateClaimResponse(ctx, r)
	case r4.ClinicalImpression:
		impl, ok := w.Concrete.(ClinicalImpressionCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for ClinicalImpression")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateClinicalImpression(ctx, r)
	case r4.CodeSystem:
		impl, ok := w.Concrete.(CodeSystemCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for CodeSystem")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateCodeSystem(ctx, r)
	case r4.Communication:
		impl, ok := w.Concrete.(CommunicationCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Communication")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateCommunication(ctx, r)
	case r4.CommunicationRequest:
		impl, ok := w.Concrete.(CommunicationRequestCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for CommunicationRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateCommunicationRequest(ctx, r)
	case r4.CompartmentDefinition:
		impl, ok := w.Concrete.(CompartmentDefinitionCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for CompartmentDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateCompartmentDefinition(ctx, r)
	case r4.Composition:
		impl, ok := w.Concrete.(CompositionCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Composition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateComposition(ctx, r)
	case r4.ConceptMap:
		impl, ok := w.Concrete.(ConceptMapCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for ConceptMap")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateConceptMap(ctx, r)
	case r4.Condition:
		impl, ok := w.Concrete.(ConditionCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Condition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateCondition(ctx, r)
	case r4.Consent:
		impl, ok := w.Concrete.(ConsentCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Consent")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateConsent(ctx, r)
	case r4.Contract:
		impl, ok := w.Concrete.(ContractCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Contract")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateContract(ctx, r)
	case r4.Coverage:
		impl, ok := w.Concrete.(CoverageCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Coverage")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateCoverage(ctx, r)
	case r4.CoverageEligibilityRequest:
		impl, ok := w.Concrete.(CoverageEligibilityRequestCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for CoverageEligibilityRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateCoverageEligibilityRequest(ctx, r)
	case r4.CoverageEligibilityResponse:
		impl, ok := w.Concrete.(CoverageEligibilityResponseCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for CoverageEligibilityResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateCoverageEligibilityResponse(ctx, r)
	case r4.DetectedIssue:
		impl, ok := w.Concrete.(DetectedIssueCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for DetectedIssue")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateDetectedIssue(ctx, r)
	case r4.Device:
		impl, ok := w.Concrete.(DeviceCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Device")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateDevice(ctx, r)
	case r4.DeviceDefinition:
		impl, ok := w.Concrete.(DeviceDefinitionCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for DeviceDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateDeviceDefinition(ctx, r)
	case r4.DeviceMetric:
		impl, ok := w.Concrete.(DeviceMetricCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for DeviceMetric")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateDeviceMetric(ctx, r)
	case r4.DeviceRequest:
		impl, ok := w.Concrete.(DeviceRequestCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for DeviceRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateDeviceRequest(ctx, r)
	case r4.DeviceUseStatement:
		impl, ok := w.Concrete.(DeviceUseStatementCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for DeviceUseStatement")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateDeviceUseStatement(ctx, r)
	case r4.DiagnosticReport:
		impl, ok := w.Concrete.(DiagnosticReportCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for DiagnosticReport")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateDiagnosticReport(ctx, r)
	case r4.DocumentManifest:
		impl, ok := w.Concrete.(DocumentManifestCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for DocumentManifest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateDocumentManifest(ctx, r)
	case r4.DocumentReference:
		impl, ok := w.Concrete.(DocumentReferenceCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for DocumentReference")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateDocumentReference(ctx, r)
	case r4.EffectEvidenceSynthesis:
		impl, ok := w.Concrete.(EffectEvidenceSynthesisCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for EffectEvidenceSynthesis")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateEffectEvidenceSynthesis(ctx, r)
	case r4.Encounter:
		impl, ok := w.Concrete.(EncounterCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Encounter")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateEncounter(ctx, r)
	case r4.Endpoint:
		impl, ok := w.Concrete.(EndpointCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Endpoint")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateEndpoint(ctx, r)
	case r4.EnrollmentRequest:
		impl, ok := w.Concrete.(EnrollmentRequestCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for EnrollmentRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateEnrollmentRequest(ctx, r)
	case r4.EnrollmentResponse:
		impl, ok := w.Concrete.(EnrollmentResponseCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for EnrollmentResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateEnrollmentResponse(ctx, r)
	case r4.EpisodeOfCare:
		impl, ok := w.Concrete.(EpisodeOfCareCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for EpisodeOfCare")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateEpisodeOfCare(ctx, r)
	case r4.EventDefinition:
		impl, ok := w.Concrete.(EventDefinitionCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for EventDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateEventDefinition(ctx, r)
	case r4.Evidence:
		impl, ok := w.Concrete.(EvidenceCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Evidence")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateEvidence(ctx, r)
	case r4.EvidenceVariable:
		impl, ok := w.Concrete.(EvidenceVariableCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for EvidenceVariable")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateEvidenceVariable(ctx, r)
	case r4.ExampleScenario:
		impl, ok := w.Concrete.(ExampleScenarioCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for ExampleScenario")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateExampleScenario(ctx, r)
	case r4.ExplanationOfBenefit:
		impl, ok := w.Concrete.(ExplanationOfBenefitCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for ExplanationOfBenefit")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateExplanationOfBenefit(ctx, r)
	case r4.FamilyMemberHistory:
		impl, ok := w.Concrete.(FamilyMemberHistoryCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for FamilyMemberHistory")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateFamilyMemberHistory(ctx, r)
	case r4.Flag:
		impl, ok := w.Concrete.(FlagCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Flag")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateFlag(ctx, r)
	case r4.Goal:
		impl, ok := w.Concrete.(GoalCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Goal")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateGoal(ctx, r)
	case r4.GraphDefinition:
		impl, ok := w.Concrete.(GraphDefinitionCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for GraphDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateGraphDefinition(ctx, r)
	case r4.Group:
		impl, ok := w.Concrete.(GroupCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Group")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateGroup(ctx, r)
	case r4.GuidanceResponse:
		impl, ok := w.Concrete.(GuidanceResponseCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for GuidanceResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateGuidanceResponse(ctx, r)
	case r4.HealthcareService:
		impl, ok := w.Concrete.(HealthcareServiceCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for HealthcareService")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateHealthcareService(ctx, r)
	case r4.ImagingStudy:
		impl, ok := w.Concrete.(ImagingStudyCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for ImagingStudy")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateImagingStudy(ctx, r)
	case r4.Immunization:
		impl, ok := w.Concrete.(ImmunizationCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Immunization")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateImmunization(ctx, r)
	case r4.ImmunizationEvaluation:
		impl, ok := w.Concrete.(ImmunizationEvaluationCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for ImmunizationEvaluation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateImmunizationEvaluation(ctx, r)
	case r4.ImmunizationRecommendation:
		impl, ok := w.Concrete.(ImmunizationRecommendationCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for ImmunizationRecommendation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateImmunizationRecommendation(ctx, r)
	case r4.ImplementationGuide:
		impl, ok := w.Concrete.(ImplementationGuideCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for ImplementationGuide")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateImplementationGuide(ctx, r)
	case r4.InsurancePlan:
		impl, ok := w.Concrete.(InsurancePlanCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for InsurancePlan")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateInsurancePlan(ctx, r)
	case r4.Invoice:
		impl, ok := w.Concrete.(InvoiceCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Invoice")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateInvoice(ctx, r)
	case r4.Library:
		impl, ok := w.Concrete.(LibraryCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Library")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateLibrary(ctx, r)
	case r4.Linkage:
		impl, ok := w.Concrete.(LinkageCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Linkage")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateLinkage(ctx, r)
	case r4.List:
		impl, ok := w.Concrete.(ListCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for List")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateList(ctx, r)
	case r4.Location:
		impl, ok := w.Concrete.(LocationCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Location")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateLocation(ctx, r)
	case r4.Measure:
		impl, ok := w.Concrete.(MeasureCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Measure")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMeasure(ctx, r)
	case r4.MeasureReport:
		impl, ok := w.Concrete.(MeasureReportCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for MeasureReport")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMeasureReport(ctx, r)
	case r4.Media:
		impl, ok := w.Concrete.(MediaCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Media")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMedia(ctx, r)
	case r4.Medication:
		impl, ok := w.Concrete.(MedicationCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Medication")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMedication(ctx, r)
	case r4.MedicationAdministration:
		impl, ok := w.Concrete.(MedicationAdministrationCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for MedicationAdministration")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMedicationAdministration(ctx, r)
	case r4.MedicationDispense:
		impl, ok := w.Concrete.(MedicationDispenseCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for MedicationDispense")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMedicationDispense(ctx, r)
	case r4.MedicationKnowledge:
		impl, ok := w.Concrete.(MedicationKnowledgeCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for MedicationKnowledge")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMedicationKnowledge(ctx, r)
	case r4.MedicationRequest:
		impl, ok := w.Concrete.(MedicationRequestCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for MedicationRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMedicationRequest(ctx, r)
	case r4.MedicationStatement:
		impl, ok := w.Concrete.(MedicationStatementCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for MedicationStatement")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMedicationStatement(ctx, r)
	case r4.MedicinalProduct:
		impl, ok := w.Concrete.(MedicinalProductCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for MedicinalProduct")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMedicinalProduct(ctx, r)
	case r4.MedicinalProductAuthorization:
		impl, ok := w.Concrete.(MedicinalProductAuthorizationCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for MedicinalProductAuthorization")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMedicinalProductAuthorization(ctx, r)
	case r4.MedicinalProductContraindication:
		impl, ok := w.Concrete.(MedicinalProductContraindicationCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for MedicinalProductContraindication")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMedicinalProductContraindication(ctx, r)
	case r4.MedicinalProductIndication:
		impl, ok := w.Concrete.(MedicinalProductIndicationCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for MedicinalProductIndication")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMedicinalProductIndication(ctx, r)
	case r4.MedicinalProductIngredient:
		impl, ok := w.Concrete.(MedicinalProductIngredientCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for MedicinalProductIngredient")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMedicinalProductIngredient(ctx, r)
	case r4.MedicinalProductInteraction:
		impl, ok := w.Concrete.(MedicinalProductInteractionCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for MedicinalProductInteraction")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMedicinalProductInteraction(ctx, r)
	case r4.MedicinalProductManufactured:
		impl, ok := w.Concrete.(MedicinalProductManufacturedCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for MedicinalProductManufactured")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMedicinalProductManufactured(ctx, r)
	case r4.MedicinalProductPackaged:
		impl, ok := w.Concrete.(MedicinalProductPackagedCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for MedicinalProductPackaged")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMedicinalProductPackaged(ctx, r)
	case r4.MedicinalProductPharmaceutical:
		impl, ok := w.Concrete.(MedicinalProductPharmaceuticalCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for MedicinalProductPharmaceutical")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMedicinalProductPharmaceutical(ctx, r)
	case r4.MedicinalProductUndesirableEffect:
		impl, ok := w.Concrete.(MedicinalProductUndesirableEffectCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for MedicinalProductUndesirableEffect")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMedicinalProductUndesirableEffect(ctx, r)
	case r4.MessageDefinition:
		impl, ok := w.Concrete.(MessageDefinitionCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for MessageDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMessageDefinition(ctx, r)
	case r4.MessageHeader:
		impl, ok := w.Concrete.(MessageHeaderCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for MessageHeader")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMessageHeader(ctx, r)
	case r4.MolecularSequence:
		impl, ok := w.Concrete.(MolecularSequenceCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for MolecularSequence")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateMolecularSequence(ctx, r)
	case r4.NamingSystem:
		impl, ok := w.Concrete.(NamingSystemCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for NamingSystem")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateNamingSystem(ctx, r)
	case r4.NutritionOrder:
		impl, ok := w.Concrete.(NutritionOrderCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for NutritionOrder")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateNutritionOrder(ctx, r)
	case r4.Observation:
		impl, ok := w.Concrete.(ObservationCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Observation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateObservation(ctx, r)
	case r4.ObservationDefinition:
		impl, ok := w.Concrete.(ObservationDefinitionCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for ObservationDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateObservationDefinition(ctx, r)
	case r4.OperationDefinition:
		impl, ok := w.Concrete.(OperationDefinitionCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for OperationDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateOperationDefinition(ctx, r)
	case r4.OperationOutcome:
		impl, ok := w.Concrete.(OperationOutcomeCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for OperationOutcome")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateOperationOutcome(ctx, r)
	case r4.Organization:
		impl, ok := w.Concrete.(OrganizationCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Organization")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateOrganization(ctx, r)
	case r4.OrganizationAffiliation:
		impl, ok := w.Concrete.(OrganizationAffiliationCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for OrganizationAffiliation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateOrganizationAffiliation(ctx, r)
	case r4.Parameters:
		impl, ok := w.Concrete.(ParametersCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Parameters")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateParameters(ctx, r)
	case r4.Patient:
		impl, ok := w.Concrete.(PatientCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Patient")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreatePatient(ctx, r)
	case r4.PaymentNotice:
		impl, ok := w.Concrete.(PaymentNoticeCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for PaymentNotice")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreatePaymentNotice(ctx, r)
	case r4.PaymentReconciliation:
		impl, ok := w.Concrete.(PaymentReconciliationCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for PaymentReconciliation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreatePaymentReconciliation(ctx, r)
	case r4.Person:
		impl, ok := w.Concrete.(PersonCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Person")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreatePerson(ctx, r)
	case r4.PlanDefinition:
		impl, ok := w.Concrete.(PlanDefinitionCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for PlanDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreatePlanDefinition(ctx, r)
	case r4.Practitioner:
		impl, ok := w.Concrete.(PractitionerCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Practitioner")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreatePractitioner(ctx, r)
	case r4.PractitionerRole:
		impl, ok := w.Concrete.(PractitionerRoleCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for PractitionerRole")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreatePractitionerRole(ctx, r)
	case r4.Procedure:
		impl, ok := w.Concrete.(ProcedureCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Procedure")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateProcedure(ctx, r)
	case r4.Provenance:
		impl, ok := w.Concrete.(ProvenanceCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Provenance")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateProvenance(ctx, r)
	case r4.Questionnaire:
		impl, ok := w.Concrete.(QuestionnaireCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Questionnaire")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateQuestionnaire(ctx, r)
	case r4.QuestionnaireResponse:
		impl, ok := w.Concrete.(QuestionnaireResponseCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for QuestionnaireResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateQuestionnaireResponse(ctx, r)
	case r4.RelatedPerson:
		impl, ok := w.Concrete.(RelatedPersonCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for RelatedPerson")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateRelatedPerson(ctx, r)
	case r4.RequestGroup:
		impl, ok := w.Concrete.(RequestGroupCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for RequestGroup")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateRequestGroup(ctx, r)
	case r4.ResearchDefinition:
		impl, ok := w.Concrete.(ResearchDefinitionCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for ResearchDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateResearchDefinition(ctx, r)
	case r4.ResearchElementDefinition:
		impl, ok := w.Concrete.(ResearchElementDefinitionCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for ResearchElementDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateResearchElementDefinition(ctx, r)
	case r4.ResearchStudy:
		impl, ok := w.Concrete.(ResearchStudyCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for ResearchStudy")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateResearchStudy(ctx, r)
	case r4.ResearchSubject:
		impl, ok := w.Concrete.(ResearchSubjectCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for ResearchSubject")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateResearchSubject(ctx, r)
	case r4.RiskAssessment:
		impl, ok := w.Concrete.(RiskAssessmentCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for RiskAssessment")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateRiskAssessment(ctx, r)
	case r4.RiskEvidenceSynthesis:
		impl, ok := w.Concrete.(RiskEvidenceSynthesisCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for RiskEvidenceSynthesis")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateRiskEvidenceSynthesis(ctx, r)
	case r4.Schedule:
		impl, ok := w.Concrete.(ScheduleCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Schedule")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSchedule(ctx, r)
	case r4.SearchParameter:
		impl, ok := w.Concrete.(SearchParameterCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for SearchParameter")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSearchParameter(ctx, r)
	case r4.ServiceRequest:
		impl, ok := w.Concrete.(ServiceRequestCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for ServiceRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateServiceRequest(ctx, r)
	case r4.Slot:
		impl, ok := w.Concrete.(SlotCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Slot")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSlot(ctx, r)
	case r4.Specimen:
		impl, ok := w.Concrete.(SpecimenCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Specimen")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSpecimen(ctx, r)
	case r4.SpecimenDefinition:
		impl, ok := w.Concrete.(SpecimenDefinitionCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for SpecimenDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSpecimenDefinition(ctx, r)
	case r4.StructureDefinition:
		impl, ok := w.Concrete.(StructureDefinitionCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for StructureDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateStructureDefinition(ctx, r)
	case r4.StructureMap:
		impl, ok := w.Concrete.(StructureMapCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for StructureMap")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateStructureMap(ctx, r)
	case r4.Subscription:
		impl, ok := w.Concrete.(SubscriptionCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Subscription")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSubscription(ctx, r)
	case r4.Substance:
		impl, ok := w.Concrete.(SubstanceCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Substance")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSubstance(ctx, r)
	case r4.SubstanceNucleicAcid:
		impl, ok := w.Concrete.(SubstanceNucleicAcidCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for SubstanceNucleicAcid")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSubstanceNucleicAcid(ctx, r)
	case r4.SubstancePolymer:
		impl, ok := w.Concrete.(SubstancePolymerCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for SubstancePolymer")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSubstancePolymer(ctx, r)
	case r4.SubstanceProtein:
		impl, ok := w.Concrete.(SubstanceProteinCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for SubstanceProtein")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSubstanceProtein(ctx, r)
	case r4.SubstanceReferenceInformation:
		impl, ok := w.Concrete.(SubstanceReferenceInformationCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for SubstanceReferenceInformation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSubstanceReferenceInformation(ctx, r)
	case r4.SubstanceSourceMaterial:
		impl, ok := w.Concrete.(SubstanceSourceMaterialCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for SubstanceSourceMaterial")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSubstanceSourceMaterial(ctx, r)
	case r4.SubstanceSpecification:
		impl, ok := w.Concrete.(SubstanceSpecificationCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for SubstanceSpecification")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSubstanceSpecification(ctx, r)
	case r4.SupplyDelivery:
		impl, ok := w.Concrete.(SupplyDeliveryCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for SupplyDelivery")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSupplyDelivery(ctx, r)
	case r4.SupplyRequest:
		impl, ok := w.Concrete.(SupplyRequestCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for SupplyRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateSupplyRequest(ctx, r)
	case r4.Task:
		impl, ok := w.Concrete.(TaskCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for Task")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateTask(ctx, r)
	case r4.TerminologyCapabilities:
		impl, ok := w.Concrete.(TerminologyCapabilitiesCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for TerminologyCapabilities")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateTerminologyCapabilities(ctx, r)
	case r4.TestReport:
		impl, ok := w.Concrete.(TestReportCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for TestReport")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateTestReport(ctx, r)
	case r4.TestScript:
		impl, ok := w.Concrete.(TestScriptCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for TestScript")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateTestScript(ctx, r)
	case r4.ValueSet:
		impl, ok := w.Concrete.(ValueSetCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for ValueSet")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateValueSet(ctx, r)
	case r4.VerificationResult:
		impl, ok := w.Concrete.(VerificationResultCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for VerificationResult")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateVerificationResult(ctx, r)
	case r4.VisionPrescription:
		impl, ok := w.Concrete.(VisionPrescriptionCreate)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("create not implemented for VisionPrescription")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.CreateVisionPrescription(ctx, r)
	default:
		return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
			Code:        r4.Code{Value: ptr.To("processing")},
			Diagnostics: &r4.String{Value: ptr.To("invalid resource type: " + resource.ResourceType())},
			Severity:    r4.Code{Value: ptr.To("fatal")},
		}}}
	}
}
func (w Generic) Read(ctx context.Context, resourceType string, id string) (model.Resource, error) {
	g, ok := w.Concrete.(capabilities.GenericRead)
	if ok {
		// shortcut for the case that the underlying implementation already implements the generic API
		return g.Read(ctx, resourceType, id)
	}
	switch resourceType {
	case "Account":
		impl, ok := w.Concrete.(AccountRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Account")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadAccount(ctx, id)
	case "ActivityDefinition":
		impl, ok := w.Concrete.(ActivityDefinitionRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for ActivityDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadActivityDefinition(ctx, id)
	case "AdverseEvent":
		impl, ok := w.Concrete.(AdverseEventRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for AdverseEvent")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadAdverseEvent(ctx, id)
	case "AllergyIntolerance":
		impl, ok := w.Concrete.(AllergyIntoleranceRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for AllergyIntolerance")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadAllergyIntolerance(ctx, id)
	case "Appointment":
		impl, ok := w.Concrete.(AppointmentRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Appointment")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadAppointment(ctx, id)
	case "AppointmentResponse":
		impl, ok := w.Concrete.(AppointmentResponseRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for AppointmentResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadAppointmentResponse(ctx, id)
	case "AuditEvent":
		impl, ok := w.Concrete.(AuditEventRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for AuditEvent")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadAuditEvent(ctx, id)
	case "Basic":
		impl, ok := w.Concrete.(BasicRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Basic")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadBasic(ctx, id)
	case "Binary":
		impl, ok := w.Concrete.(BinaryRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Binary")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadBinary(ctx, id)
	case "BiologicallyDerivedProduct":
		impl, ok := w.Concrete.(BiologicallyDerivedProductRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for BiologicallyDerivedProduct")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadBiologicallyDerivedProduct(ctx, id)
	case "BodyStructure":
		impl, ok := w.Concrete.(BodyStructureRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for BodyStructure")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadBodyStructure(ctx, id)
	case "Bundle":
		impl, ok := w.Concrete.(BundleRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Bundle")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadBundle(ctx, id)
	case "CapabilityStatement":
		impl, ok := w.Concrete.(CapabilityStatementRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for CapabilityStatement")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadCapabilityStatement(ctx, id)
	case "CarePlan":
		impl, ok := w.Concrete.(CarePlanRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for CarePlan")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadCarePlan(ctx, id)
	case "CareTeam":
		impl, ok := w.Concrete.(CareTeamRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for CareTeam")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadCareTeam(ctx, id)
	case "CatalogEntry":
		impl, ok := w.Concrete.(CatalogEntryRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for CatalogEntry")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadCatalogEntry(ctx, id)
	case "ChargeItem":
		impl, ok := w.Concrete.(ChargeItemRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for ChargeItem")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadChargeItem(ctx, id)
	case "ChargeItemDefinition":
		impl, ok := w.Concrete.(ChargeItemDefinitionRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for ChargeItemDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadChargeItemDefinition(ctx, id)
	case "Claim":
		impl, ok := w.Concrete.(ClaimRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Claim")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadClaim(ctx, id)
	case "ClaimResponse":
		impl, ok := w.Concrete.(ClaimResponseRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for ClaimResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadClaimResponse(ctx, id)
	case "ClinicalImpression":
		impl, ok := w.Concrete.(ClinicalImpressionRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for ClinicalImpression")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadClinicalImpression(ctx, id)
	case "CodeSystem":
		impl, ok := w.Concrete.(CodeSystemRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for CodeSystem")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadCodeSystem(ctx, id)
	case "Communication":
		impl, ok := w.Concrete.(CommunicationRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Communication")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadCommunication(ctx, id)
	case "CommunicationRequest":
		impl, ok := w.Concrete.(CommunicationRequestRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for CommunicationRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadCommunicationRequest(ctx, id)
	case "CompartmentDefinition":
		impl, ok := w.Concrete.(CompartmentDefinitionRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for CompartmentDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadCompartmentDefinition(ctx, id)
	case "Composition":
		impl, ok := w.Concrete.(CompositionRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Composition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadComposition(ctx, id)
	case "ConceptMap":
		impl, ok := w.Concrete.(ConceptMapRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for ConceptMap")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadConceptMap(ctx, id)
	case "Condition":
		impl, ok := w.Concrete.(ConditionRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Condition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadCondition(ctx, id)
	case "Consent":
		impl, ok := w.Concrete.(ConsentRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Consent")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadConsent(ctx, id)
	case "Contract":
		impl, ok := w.Concrete.(ContractRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Contract")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadContract(ctx, id)
	case "Coverage":
		impl, ok := w.Concrete.(CoverageRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Coverage")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadCoverage(ctx, id)
	case "CoverageEligibilityRequest":
		impl, ok := w.Concrete.(CoverageEligibilityRequestRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for CoverageEligibilityRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadCoverageEligibilityRequest(ctx, id)
	case "CoverageEligibilityResponse":
		impl, ok := w.Concrete.(CoverageEligibilityResponseRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for CoverageEligibilityResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadCoverageEligibilityResponse(ctx, id)
	case "DetectedIssue":
		impl, ok := w.Concrete.(DetectedIssueRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for DetectedIssue")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadDetectedIssue(ctx, id)
	case "Device":
		impl, ok := w.Concrete.(DeviceRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Device")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadDevice(ctx, id)
	case "DeviceDefinition":
		impl, ok := w.Concrete.(DeviceDefinitionRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for DeviceDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadDeviceDefinition(ctx, id)
	case "DeviceMetric":
		impl, ok := w.Concrete.(DeviceMetricRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for DeviceMetric")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadDeviceMetric(ctx, id)
	case "DeviceRequest":
		impl, ok := w.Concrete.(DeviceRequestRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for DeviceRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadDeviceRequest(ctx, id)
	case "DeviceUseStatement":
		impl, ok := w.Concrete.(DeviceUseStatementRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for DeviceUseStatement")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadDeviceUseStatement(ctx, id)
	case "DiagnosticReport":
		impl, ok := w.Concrete.(DiagnosticReportRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for DiagnosticReport")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadDiagnosticReport(ctx, id)
	case "DocumentManifest":
		impl, ok := w.Concrete.(DocumentManifestRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for DocumentManifest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadDocumentManifest(ctx, id)
	case "DocumentReference":
		impl, ok := w.Concrete.(DocumentReferenceRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for DocumentReference")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadDocumentReference(ctx, id)
	case "EffectEvidenceSynthesis":
		impl, ok := w.Concrete.(EffectEvidenceSynthesisRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for EffectEvidenceSynthesis")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadEffectEvidenceSynthesis(ctx, id)
	case "Encounter":
		impl, ok := w.Concrete.(EncounterRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Encounter")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadEncounter(ctx, id)
	case "Endpoint":
		impl, ok := w.Concrete.(EndpointRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Endpoint")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadEndpoint(ctx, id)
	case "EnrollmentRequest":
		impl, ok := w.Concrete.(EnrollmentRequestRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for EnrollmentRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadEnrollmentRequest(ctx, id)
	case "EnrollmentResponse":
		impl, ok := w.Concrete.(EnrollmentResponseRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for EnrollmentResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadEnrollmentResponse(ctx, id)
	case "EpisodeOfCare":
		impl, ok := w.Concrete.(EpisodeOfCareRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for EpisodeOfCare")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadEpisodeOfCare(ctx, id)
	case "EventDefinition":
		impl, ok := w.Concrete.(EventDefinitionRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for EventDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadEventDefinition(ctx, id)
	case "Evidence":
		impl, ok := w.Concrete.(EvidenceRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Evidence")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadEvidence(ctx, id)
	case "EvidenceVariable":
		impl, ok := w.Concrete.(EvidenceVariableRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for EvidenceVariable")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadEvidenceVariable(ctx, id)
	case "ExampleScenario":
		impl, ok := w.Concrete.(ExampleScenarioRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for ExampleScenario")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadExampleScenario(ctx, id)
	case "ExplanationOfBenefit":
		impl, ok := w.Concrete.(ExplanationOfBenefitRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for ExplanationOfBenefit")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadExplanationOfBenefit(ctx, id)
	case "FamilyMemberHistory":
		impl, ok := w.Concrete.(FamilyMemberHistoryRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for FamilyMemberHistory")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadFamilyMemberHistory(ctx, id)
	case "Flag":
		impl, ok := w.Concrete.(FlagRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Flag")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadFlag(ctx, id)
	case "Goal":
		impl, ok := w.Concrete.(GoalRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Goal")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadGoal(ctx, id)
	case "GraphDefinition":
		impl, ok := w.Concrete.(GraphDefinitionRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for GraphDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadGraphDefinition(ctx, id)
	case "Group":
		impl, ok := w.Concrete.(GroupRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Group")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadGroup(ctx, id)
	case "GuidanceResponse":
		impl, ok := w.Concrete.(GuidanceResponseRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for GuidanceResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadGuidanceResponse(ctx, id)
	case "HealthcareService":
		impl, ok := w.Concrete.(HealthcareServiceRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for HealthcareService")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadHealthcareService(ctx, id)
	case "ImagingStudy":
		impl, ok := w.Concrete.(ImagingStudyRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for ImagingStudy")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadImagingStudy(ctx, id)
	case "Immunization":
		impl, ok := w.Concrete.(ImmunizationRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Immunization")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadImmunization(ctx, id)
	case "ImmunizationEvaluation":
		impl, ok := w.Concrete.(ImmunizationEvaluationRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for ImmunizationEvaluation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadImmunizationEvaluation(ctx, id)
	case "ImmunizationRecommendation":
		impl, ok := w.Concrete.(ImmunizationRecommendationRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for ImmunizationRecommendation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadImmunizationRecommendation(ctx, id)
	case "ImplementationGuide":
		impl, ok := w.Concrete.(ImplementationGuideRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for ImplementationGuide")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadImplementationGuide(ctx, id)
	case "InsurancePlan":
		impl, ok := w.Concrete.(InsurancePlanRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for InsurancePlan")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadInsurancePlan(ctx, id)
	case "Invoice":
		impl, ok := w.Concrete.(InvoiceRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Invoice")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadInvoice(ctx, id)
	case "Library":
		impl, ok := w.Concrete.(LibraryRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Library")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadLibrary(ctx, id)
	case "Linkage":
		impl, ok := w.Concrete.(LinkageRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Linkage")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadLinkage(ctx, id)
	case "List":
		impl, ok := w.Concrete.(ListRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for List")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadList(ctx, id)
	case "Location":
		impl, ok := w.Concrete.(LocationRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Location")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadLocation(ctx, id)
	case "Measure":
		impl, ok := w.Concrete.(MeasureRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Measure")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMeasure(ctx, id)
	case "MeasureReport":
		impl, ok := w.Concrete.(MeasureReportRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for MeasureReport")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMeasureReport(ctx, id)
	case "Media":
		impl, ok := w.Concrete.(MediaRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Media")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMedia(ctx, id)
	case "Medication":
		impl, ok := w.Concrete.(MedicationRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Medication")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMedication(ctx, id)
	case "MedicationAdministration":
		impl, ok := w.Concrete.(MedicationAdministrationRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for MedicationAdministration")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMedicationAdministration(ctx, id)
	case "MedicationDispense":
		impl, ok := w.Concrete.(MedicationDispenseRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for MedicationDispense")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMedicationDispense(ctx, id)
	case "MedicationKnowledge":
		impl, ok := w.Concrete.(MedicationKnowledgeRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for MedicationKnowledge")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMedicationKnowledge(ctx, id)
	case "MedicationRequest":
		impl, ok := w.Concrete.(MedicationRequestRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for MedicationRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMedicationRequest(ctx, id)
	case "MedicationStatement":
		impl, ok := w.Concrete.(MedicationStatementRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for MedicationStatement")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMedicationStatement(ctx, id)
	case "MedicinalProduct":
		impl, ok := w.Concrete.(MedicinalProductRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for MedicinalProduct")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMedicinalProduct(ctx, id)
	case "MedicinalProductAuthorization":
		impl, ok := w.Concrete.(MedicinalProductAuthorizationRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for MedicinalProductAuthorization")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMedicinalProductAuthorization(ctx, id)
	case "MedicinalProductContraindication":
		impl, ok := w.Concrete.(MedicinalProductContraindicationRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for MedicinalProductContraindication")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMedicinalProductContraindication(ctx, id)
	case "MedicinalProductIndication":
		impl, ok := w.Concrete.(MedicinalProductIndicationRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for MedicinalProductIndication")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMedicinalProductIndication(ctx, id)
	case "MedicinalProductIngredient":
		impl, ok := w.Concrete.(MedicinalProductIngredientRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for MedicinalProductIngredient")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMedicinalProductIngredient(ctx, id)
	case "MedicinalProductInteraction":
		impl, ok := w.Concrete.(MedicinalProductInteractionRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for MedicinalProductInteraction")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMedicinalProductInteraction(ctx, id)
	case "MedicinalProductManufactured":
		impl, ok := w.Concrete.(MedicinalProductManufacturedRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for MedicinalProductManufactured")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMedicinalProductManufactured(ctx, id)
	case "MedicinalProductPackaged":
		impl, ok := w.Concrete.(MedicinalProductPackagedRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for MedicinalProductPackaged")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMedicinalProductPackaged(ctx, id)
	case "MedicinalProductPharmaceutical":
		impl, ok := w.Concrete.(MedicinalProductPharmaceuticalRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for MedicinalProductPharmaceutical")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMedicinalProductPharmaceutical(ctx, id)
	case "MedicinalProductUndesirableEffect":
		impl, ok := w.Concrete.(MedicinalProductUndesirableEffectRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for MedicinalProductUndesirableEffect")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMedicinalProductUndesirableEffect(ctx, id)
	case "MessageDefinition":
		impl, ok := w.Concrete.(MessageDefinitionRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for MessageDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMessageDefinition(ctx, id)
	case "MessageHeader":
		impl, ok := w.Concrete.(MessageHeaderRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for MessageHeader")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMessageHeader(ctx, id)
	case "MolecularSequence":
		impl, ok := w.Concrete.(MolecularSequenceRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for MolecularSequence")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadMolecularSequence(ctx, id)
	case "NamingSystem":
		impl, ok := w.Concrete.(NamingSystemRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for NamingSystem")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadNamingSystem(ctx, id)
	case "NutritionOrder":
		impl, ok := w.Concrete.(NutritionOrderRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for NutritionOrder")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadNutritionOrder(ctx, id)
	case "Observation":
		impl, ok := w.Concrete.(ObservationRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Observation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadObservation(ctx, id)
	case "ObservationDefinition":
		impl, ok := w.Concrete.(ObservationDefinitionRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for ObservationDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadObservationDefinition(ctx, id)
	case "OperationDefinition":
		impl, ok := w.Concrete.(OperationDefinitionRead)
		if ok {
			return impl.ReadOperationDefinition(ctx, id)
		}
		cs, err := w.Concrete.CapabilityBase(ctx)
		if err != nil {
			return nil, err
		}
		var baseUrl string
		if cs.Implementation != nil && cs.Implementation.Url != nil && cs.Implementation.Url.Value != nil {
			baseUrl = *cs.Implementation.Url.Value
		}
		defs, err := operationDefinitionsByID(ctx, w.Concrete, baseUrl)
		if err != nil {
			return nil, err
		}
		if od, exists := defs[id]; exists {
			return od, nil
		}
		return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
			Code:        r4.Code{Value: ptr.To("not-found")},
			Diagnostics: &r4.String{Value: ptr.To("OperationDefinition with ID " + id + " not found")},
			Severity:    r4.Code{Value: ptr.To("error")},
		}}}
	case "OperationOutcome":
		impl, ok := w.Concrete.(OperationOutcomeRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for OperationOutcome")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadOperationOutcome(ctx, id)
	case "Organization":
		impl, ok := w.Concrete.(OrganizationRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Organization")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadOrganization(ctx, id)
	case "OrganizationAffiliation":
		impl, ok := w.Concrete.(OrganizationAffiliationRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for OrganizationAffiliation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadOrganizationAffiliation(ctx, id)
	case "Parameters":
		impl, ok := w.Concrete.(ParametersRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Parameters")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadParameters(ctx, id)
	case "Patient":
		impl, ok := w.Concrete.(PatientRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Patient")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadPatient(ctx, id)
	case "PaymentNotice":
		impl, ok := w.Concrete.(PaymentNoticeRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for PaymentNotice")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadPaymentNotice(ctx, id)
	case "PaymentReconciliation":
		impl, ok := w.Concrete.(PaymentReconciliationRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for PaymentReconciliation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadPaymentReconciliation(ctx, id)
	case "Person":
		impl, ok := w.Concrete.(PersonRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Person")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadPerson(ctx, id)
	case "PlanDefinition":
		impl, ok := w.Concrete.(PlanDefinitionRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for PlanDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadPlanDefinition(ctx, id)
	case "Practitioner":
		impl, ok := w.Concrete.(PractitionerRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Practitioner")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadPractitioner(ctx, id)
	case "PractitionerRole":
		impl, ok := w.Concrete.(PractitionerRoleRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for PractitionerRole")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadPractitionerRole(ctx, id)
	case "Procedure":
		impl, ok := w.Concrete.(ProcedureRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Procedure")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadProcedure(ctx, id)
	case "Provenance":
		impl, ok := w.Concrete.(ProvenanceRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Provenance")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadProvenance(ctx, id)
	case "Questionnaire":
		impl, ok := w.Concrete.(QuestionnaireRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Questionnaire")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadQuestionnaire(ctx, id)
	case "QuestionnaireResponse":
		impl, ok := w.Concrete.(QuestionnaireResponseRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for QuestionnaireResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadQuestionnaireResponse(ctx, id)
	case "RelatedPerson":
		impl, ok := w.Concrete.(RelatedPersonRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for RelatedPerson")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadRelatedPerson(ctx, id)
	case "RequestGroup":
		impl, ok := w.Concrete.(RequestGroupRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for RequestGroup")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadRequestGroup(ctx, id)
	case "ResearchDefinition":
		impl, ok := w.Concrete.(ResearchDefinitionRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for ResearchDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadResearchDefinition(ctx, id)
	case "ResearchElementDefinition":
		impl, ok := w.Concrete.(ResearchElementDefinitionRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for ResearchElementDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadResearchElementDefinition(ctx, id)
	case "ResearchStudy":
		impl, ok := w.Concrete.(ResearchStudyRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for ResearchStudy")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadResearchStudy(ctx, id)
	case "ResearchSubject":
		impl, ok := w.Concrete.(ResearchSubjectRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for ResearchSubject")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadResearchSubject(ctx, id)
	case "RiskAssessment":
		impl, ok := w.Concrete.(RiskAssessmentRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for RiskAssessment")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadRiskAssessment(ctx, id)
	case "RiskEvidenceSynthesis":
		impl, ok := w.Concrete.(RiskEvidenceSynthesisRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for RiskEvidenceSynthesis")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadRiskEvidenceSynthesis(ctx, id)
	case "Schedule":
		impl, ok := w.Concrete.(ScheduleRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Schedule")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSchedule(ctx, id)
	case "SearchParameter":
		impl, ok := w.Concrete.(SearchParameterRead)
		if ok {
			return impl.ReadSearchParameter(ctx, id)
		}
		// Fallback: gather SearchParameter from SearchCapabilities methods if ReadSearchParameter not implemented
		// Get base URL from CapabilityStatement for canonical references
		cs, err := w.Concrete.CapabilityBase(ctx)
		if err != nil {
			return nil, err
		}
		var baseUrl string
		if cs.Implementation != nil && cs.Implementation.Url != nil && cs.Implementation.Url.Value != nil {
			baseUrl = *cs.Implementation.Url.Value
		}
		searchParameters, err := searchParameters(ctx, w.Concrete, baseUrl)
		if err != nil {
			return nil, err
		}
		searchParam, exists := searchParameters[id]
		if exists {
			return searchParam, nil
		}
		return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
			Code:        r4.Code{Value: ptr.To("not-found")},
			Diagnostics: &r4.String{Value: ptr.To("SearchParameter with ID " + id + " not found")},
			Severity:    r4.Code{Value: ptr.To("error")},
		}}}
	case "ServiceRequest":
		impl, ok := w.Concrete.(ServiceRequestRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for ServiceRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadServiceRequest(ctx, id)
	case "Slot":
		impl, ok := w.Concrete.(SlotRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Slot")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSlot(ctx, id)
	case "Specimen":
		impl, ok := w.Concrete.(SpecimenRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Specimen")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSpecimen(ctx, id)
	case "SpecimenDefinition":
		impl, ok := w.Concrete.(SpecimenDefinitionRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for SpecimenDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSpecimenDefinition(ctx, id)
	case "StructureDefinition":
		impl, ok := w.Concrete.(StructureDefinitionRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for StructureDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadStructureDefinition(ctx, id)
	case "StructureMap":
		impl, ok := w.Concrete.(StructureMapRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for StructureMap")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadStructureMap(ctx, id)
	case "Subscription":
		impl, ok := w.Concrete.(SubscriptionRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Subscription")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSubscription(ctx, id)
	case "Substance":
		impl, ok := w.Concrete.(SubstanceRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Substance")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSubstance(ctx, id)
	case "SubstanceNucleicAcid":
		impl, ok := w.Concrete.(SubstanceNucleicAcidRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for SubstanceNucleicAcid")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSubstanceNucleicAcid(ctx, id)
	case "SubstancePolymer":
		impl, ok := w.Concrete.(SubstancePolymerRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for SubstancePolymer")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSubstancePolymer(ctx, id)
	case "SubstanceProtein":
		impl, ok := w.Concrete.(SubstanceProteinRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for SubstanceProtein")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSubstanceProtein(ctx, id)
	case "SubstanceReferenceInformation":
		impl, ok := w.Concrete.(SubstanceReferenceInformationRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for SubstanceReferenceInformation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSubstanceReferenceInformation(ctx, id)
	case "SubstanceSourceMaterial":
		impl, ok := w.Concrete.(SubstanceSourceMaterialRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for SubstanceSourceMaterial")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSubstanceSourceMaterial(ctx, id)
	case "SubstanceSpecification":
		impl, ok := w.Concrete.(SubstanceSpecificationRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for SubstanceSpecification")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSubstanceSpecification(ctx, id)
	case "SupplyDelivery":
		impl, ok := w.Concrete.(SupplyDeliveryRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for SupplyDelivery")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSupplyDelivery(ctx, id)
	case "SupplyRequest":
		impl, ok := w.Concrete.(SupplyRequestRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for SupplyRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadSupplyRequest(ctx, id)
	case "Task":
		impl, ok := w.Concrete.(TaskRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for Task")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadTask(ctx, id)
	case "TerminologyCapabilities":
		impl, ok := w.Concrete.(TerminologyCapabilitiesRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for TerminologyCapabilities")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadTerminologyCapabilities(ctx, id)
	case "TestReport":
		impl, ok := w.Concrete.(TestReportRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for TestReport")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadTestReport(ctx, id)
	case "TestScript":
		impl, ok := w.Concrete.(TestScriptRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for TestScript")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadTestScript(ctx, id)
	case "ValueSet":
		impl, ok := w.Concrete.(ValueSetRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for ValueSet")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadValueSet(ctx, id)
	case "VerificationResult":
		impl, ok := w.Concrete.(VerificationResultRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for VerificationResult")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadVerificationResult(ctx, id)
	case "VisionPrescription":
		impl, ok := w.Concrete.(VisionPrescriptionRead)
		if !ok {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("read not implemented for VisionPrescription")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.ReadVisionPrescription(ctx, id)
	default:
		return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
			Code:        r4.Code{Value: ptr.To("processing")},
			Diagnostics: &r4.String{Value: ptr.To("invalid resource type: " + resourceType)},
			Severity:    r4.Code{Value: ptr.To("fatal")},
		}}}
	}
}
func (w Generic) Update(ctx context.Context, resource model.Resource) (update.Result[model.Resource], error) {
	g, ok := w.Concrete.(capabilities.GenericUpdate)
	if ok {
		// shortcut for the case that the underlying implementation already implements the generic API
		return g.Update(ctx, resource)
	}
	switch r := resource.(type) {
	case r4.Account:
		impl, ok := w.Concrete.(AccountUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Account")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateAccount(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.ActivityDefinition:
		impl, ok := w.Concrete.(ActivityDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for ActivityDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateActivityDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.AdverseEvent:
		impl, ok := w.Concrete.(AdverseEventUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for AdverseEvent")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateAdverseEvent(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.AllergyIntolerance:
		impl, ok := w.Concrete.(AllergyIntoleranceUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for AllergyIntolerance")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateAllergyIntolerance(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Appointment:
		impl, ok := w.Concrete.(AppointmentUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Appointment")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateAppointment(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.AppointmentResponse:
		impl, ok := w.Concrete.(AppointmentResponseUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for AppointmentResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateAppointmentResponse(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.AuditEvent:
		impl, ok := w.Concrete.(AuditEventUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for AuditEvent")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateAuditEvent(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Basic:
		impl, ok := w.Concrete.(BasicUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Basic")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateBasic(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Binary:
		impl, ok := w.Concrete.(BinaryUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Binary")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateBinary(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.BiologicallyDerivedProduct:
		impl, ok := w.Concrete.(BiologicallyDerivedProductUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for BiologicallyDerivedProduct")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateBiologicallyDerivedProduct(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.BodyStructure:
		impl, ok := w.Concrete.(BodyStructureUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for BodyStructure")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateBodyStructure(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Bundle:
		impl, ok := w.Concrete.(BundleUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Bundle")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateBundle(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.CapabilityStatement:
		impl, ok := w.Concrete.(CapabilityStatementUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for CapabilityStatement")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateCapabilityStatement(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.CarePlan:
		impl, ok := w.Concrete.(CarePlanUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for CarePlan")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateCarePlan(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.CareTeam:
		impl, ok := w.Concrete.(CareTeamUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for CareTeam")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateCareTeam(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.CatalogEntry:
		impl, ok := w.Concrete.(CatalogEntryUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for CatalogEntry")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateCatalogEntry(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.ChargeItem:
		impl, ok := w.Concrete.(ChargeItemUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for ChargeItem")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateChargeItem(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.ChargeItemDefinition:
		impl, ok := w.Concrete.(ChargeItemDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for ChargeItemDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateChargeItemDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Claim:
		impl, ok := w.Concrete.(ClaimUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Claim")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateClaim(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.ClaimResponse:
		impl, ok := w.Concrete.(ClaimResponseUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for ClaimResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateClaimResponse(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.ClinicalImpression:
		impl, ok := w.Concrete.(ClinicalImpressionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for ClinicalImpression")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateClinicalImpression(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.CodeSystem:
		impl, ok := w.Concrete.(CodeSystemUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for CodeSystem")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateCodeSystem(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Communication:
		impl, ok := w.Concrete.(CommunicationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Communication")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateCommunication(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.CommunicationRequest:
		impl, ok := w.Concrete.(CommunicationRequestUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for CommunicationRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateCommunicationRequest(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.CompartmentDefinition:
		impl, ok := w.Concrete.(CompartmentDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for CompartmentDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateCompartmentDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Composition:
		impl, ok := w.Concrete.(CompositionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Composition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateComposition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.ConceptMap:
		impl, ok := w.Concrete.(ConceptMapUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for ConceptMap")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateConceptMap(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Condition:
		impl, ok := w.Concrete.(ConditionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Condition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateCondition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Consent:
		impl, ok := w.Concrete.(ConsentUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Consent")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateConsent(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Contract:
		impl, ok := w.Concrete.(ContractUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Contract")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateContract(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Coverage:
		impl, ok := w.Concrete.(CoverageUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Coverage")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateCoverage(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.CoverageEligibilityRequest:
		impl, ok := w.Concrete.(CoverageEligibilityRequestUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for CoverageEligibilityRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateCoverageEligibilityRequest(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.CoverageEligibilityResponse:
		impl, ok := w.Concrete.(CoverageEligibilityResponseUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for CoverageEligibilityResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateCoverageEligibilityResponse(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.DetectedIssue:
		impl, ok := w.Concrete.(DetectedIssueUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for DetectedIssue")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateDetectedIssue(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Device:
		impl, ok := w.Concrete.(DeviceUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Device")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateDevice(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.DeviceDefinition:
		impl, ok := w.Concrete.(DeviceDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for DeviceDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateDeviceDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.DeviceMetric:
		impl, ok := w.Concrete.(DeviceMetricUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for DeviceMetric")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateDeviceMetric(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.DeviceRequest:
		impl, ok := w.Concrete.(DeviceRequestUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for DeviceRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateDeviceRequest(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.DeviceUseStatement:
		impl, ok := w.Concrete.(DeviceUseStatementUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for DeviceUseStatement")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateDeviceUseStatement(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.DiagnosticReport:
		impl, ok := w.Concrete.(DiagnosticReportUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for DiagnosticReport")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateDiagnosticReport(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.DocumentManifest:
		impl, ok := w.Concrete.(DocumentManifestUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for DocumentManifest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateDocumentManifest(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.DocumentReference:
		impl, ok := w.Concrete.(DocumentReferenceUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for DocumentReference")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateDocumentReference(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.EffectEvidenceSynthesis:
		impl, ok := w.Concrete.(EffectEvidenceSynthesisUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for EffectEvidenceSynthesis")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateEffectEvidenceSynthesis(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Encounter:
		impl, ok := w.Concrete.(EncounterUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Encounter")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateEncounter(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Endpoint:
		impl, ok := w.Concrete.(EndpointUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Endpoint")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateEndpoint(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.EnrollmentRequest:
		impl, ok := w.Concrete.(EnrollmentRequestUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for EnrollmentRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateEnrollmentRequest(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.EnrollmentResponse:
		impl, ok := w.Concrete.(EnrollmentResponseUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for EnrollmentResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateEnrollmentResponse(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.EpisodeOfCare:
		impl, ok := w.Concrete.(EpisodeOfCareUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for EpisodeOfCare")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateEpisodeOfCare(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.EventDefinition:
		impl, ok := w.Concrete.(EventDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for EventDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateEventDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Evidence:
		impl, ok := w.Concrete.(EvidenceUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Evidence")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateEvidence(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.EvidenceVariable:
		impl, ok := w.Concrete.(EvidenceVariableUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for EvidenceVariable")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateEvidenceVariable(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.ExampleScenario:
		impl, ok := w.Concrete.(ExampleScenarioUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for ExampleScenario")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateExampleScenario(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.ExplanationOfBenefit:
		impl, ok := w.Concrete.(ExplanationOfBenefitUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for ExplanationOfBenefit")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateExplanationOfBenefit(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.FamilyMemberHistory:
		impl, ok := w.Concrete.(FamilyMemberHistoryUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for FamilyMemberHistory")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateFamilyMemberHistory(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Flag:
		impl, ok := w.Concrete.(FlagUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Flag")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateFlag(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Goal:
		impl, ok := w.Concrete.(GoalUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Goal")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateGoal(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.GraphDefinition:
		impl, ok := w.Concrete.(GraphDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for GraphDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateGraphDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Group:
		impl, ok := w.Concrete.(GroupUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Group")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateGroup(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.GuidanceResponse:
		impl, ok := w.Concrete.(GuidanceResponseUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for GuidanceResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateGuidanceResponse(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.HealthcareService:
		impl, ok := w.Concrete.(HealthcareServiceUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for HealthcareService")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateHealthcareService(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.ImagingStudy:
		impl, ok := w.Concrete.(ImagingStudyUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for ImagingStudy")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateImagingStudy(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Immunization:
		impl, ok := w.Concrete.(ImmunizationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Immunization")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateImmunization(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.ImmunizationEvaluation:
		impl, ok := w.Concrete.(ImmunizationEvaluationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for ImmunizationEvaluation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateImmunizationEvaluation(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.ImmunizationRecommendation:
		impl, ok := w.Concrete.(ImmunizationRecommendationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for ImmunizationRecommendation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateImmunizationRecommendation(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.ImplementationGuide:
		impl, ok := w.Concrete.(ImplementationGuideUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for ImplementationGuide")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateImplementationGuide(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.InsurancePlan:
		impl, ok := w.Concrete.(InsurancePlanUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for InsurancePlan")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateInsurancePlan(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Invoice:
		impl, ok := w.Concrete.(InvoiceUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Invoice")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateInvoice(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Library:
		impl, ok := w.Concrete.(LibraryUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Library")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateLibrary(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Linkage:
		impl, ok := w.Concrete.(LinkageUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Linkage")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateLinkage(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.List:
		impl, ok := w.Concrete.(ListUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for List")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateList(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Location:
		impl, ok := w.Concrete.(LocationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Location")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateLocation(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Measure:
		impl, ok := w.Concrete.(MeasureUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Measure")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMeasure(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.MeasureReport:
		impl, ok := w.Concrete.(MeasureReportUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for MeasureReport")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMeasureReport(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Media:
		impl, ok := w.Concrete.(MediaUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Media")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMedia(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Medication:
		impl, ok := w.Concrete.(MedicationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Medication")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMedication(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.MedicationAdministration:
		impl, ok := w.Concrete.(MedicationAdministrationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for MedicationAdministration")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMedicationAdministration(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.MedicationDispense:
		impl, ok := w.Concrete.(MedicationDispenseUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for MedicationDispense")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMedicationDispense(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.MedicationKnowledge:
		impl, ok := w.Concrete.(MedicationKnowledgeUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for MedicationKnowledge")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMedicationKnowledge(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.MedicationRequest:
		impl, ok := w.Concrete.(MedicationRequestUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for MedicationRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMedicationRequest(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.MedicationStatement:
		impl, ok := w.Concrete.(MedicationStatementUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for MedicationStatement")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMedicationStatement(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.MedicinalProduct:
		impl, ok := w.Concrete.(MedicinalProductUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for MedicinalProduct")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMedicinalProduct(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.MedicinalProductAuthorization:
		impl, ok := w.Concrete.(MedicinalProductAuthorizationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for MedicinalProductAuthorization")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMedicinalProductAuthorization(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.MedicinalProductContraindication:
		impl, ok := w.Concrete.(MedicinalProductContraindicationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for MedicinalProductContraindication")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMedicinalProductContraindication(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.MedicinalProductIndication:
		impl, ok := w.Concrete.(MedicinalProductIndicationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for MedicinalProductIndication")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMedicinalProductIndication(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.MedicinalProductIngredient:
		impl, ok := w.Concrete.(MedicinalProductIngredientUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for MedicinalProductIngredient")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMedicinalProductIngredient(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.MedicinalProductInteraction:
		impl, ok := w.Concrete.(MedicinalProductInteractionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for MedicinalProductInteraction")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMedicinalProductInteraction(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.MedicinalProductManufactured:
		impl, ok := w.Concrete.(MedicinalProductManufacturedUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for MedicinalProductManufactured")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMedicinalProductManufactured(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.MedicinalProductPackaged:
		impl, ok := w.Concrete.(MedicinalProductPackagedUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for MedicinalProductPackaged")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMedicinalProductPackaged(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.MedicinalProductPharmaceutical:
		impl, ok := w.Concrete.(MedicinalProductPharmaceuticalUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for MedicinalProductPharmaceutical")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMedicinalProductPharmaceutical(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.MedicinalProductUndesirableEffect:
		impl, ok := w.Concrete.(MedicinalProductUndesirableEffectUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for MedicinalProductUndesirableEffect")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMedicinalProductUndesirableEffect(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.MessageDefinition:
		impl, ok := w.Concrete.(MessageDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for MessageDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMessageDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.MessageHeader:
		impl, ok := w.Concrete.(MessageHeaderUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for MessageHeader")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMessageHeader(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.MolecularSequence:
		impl, ok := w.Concrete.(MolecularSequenceUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for MolecularSequence")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateMolecularSequence(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.NamingSystem:
		impl, ok := w.Concrete.(NamingSystemUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for NamingSystem")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateNamingSystem(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.NutritionOrder:
		impl, ok := w.Concrete.(NutritionOrderUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for NutritionOrder")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateNutritionOrder(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Observation:
		impl, ok := w.Concrete.(ObservationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Observation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateObservation(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.ObservationDefinition:
		impl, ok := w.Concrete.(ObservationDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for ObservationDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateObservationDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.OperationDefinition:
		impl, ok := w.Concrete.(OperationDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for OperationDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateOperationDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.OperationOutcome:
		impl, ok := w.Concrete.(OperationOutcomeUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for OperationOutcome")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateOperationOutcome(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Organization:
		impl, ok := w.Concrete.(OrganizationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Organization")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateOrganization(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.OrganizationAffiliation:
		impl, ok := w.Concrete.(OrganizationAffiliationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for OrganizationAffiliation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateOrganizationAffiliation(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Parameters:
		impl, ok := w.Concrete.(ParametersUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Parameters")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateParameters(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Patient:
		impl, ok := w.Concrete.(PatientUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Patient")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdatePatient(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.PaymentNotice:
		impl, ok := w.Concrete.(PaymentNoticeUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for PaymentNotice")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdatePaymentNotice(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.PaymentReconciliation:
		impl, ok := w.Concrete.(PaymentReconciliationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for PaymentReconciliation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdatePaymentReconciliation(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Person:
		impl, ok := w.Concrete.(PersonUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Person")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdatePerson(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.PlanDefinition:
		impl, ok := w.Concrete.(PlanDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for PlanDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdatePlanDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Practitioner:
		impl, ok := w.Concrete.(PractitionerUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Practitioner")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdatePractitioner(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.PractitionerRole:
		impl, ok := w.Concrete.(PractitionerRoleUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for PractitionerRole")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdatePractitionerRole(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Procedure:
		impl, ok := w.Concrete.(ProcedureUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Procedure")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateProcedure(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Provenance:
		impl, ok := w.Concrete.(ProvenanceUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Provenance")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateProvenance(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Questionnaire:
		impl, ok := w.Concrete.(QuestionnaireUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Questionnaire")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateQuestionnaire(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.QuestionnaireResponse:
		impl, ok := w.Concrete.(QuestionnaireResponseUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for QuestionnaireResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateQuestionnaireResponse(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.RelatedPerson:
		impl, ok := w.Concrete.(RelatedPersonUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for RelatedPerson")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateRelatedPerson(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.RequestGroup:
		impl, ok := w.Concrete.(RequestGroupUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for RequestGroup")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateRequestGroup(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.ResearchDefinition:
		impl, ok := w.Concrete.(ResearchDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for ResearchDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateResearchDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.ResearchElementDefinition:
		impl, ok := w.Concrete.(ResearchElementDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for ResearchElementDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateResearchElementDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.ResearchStudy:
		impl, ok := w.Concrete.(ResearchStudyUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for ResearchStudy")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateResearchStudy(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.ResearchSubject:
		impl, ok := w.Concrete.(ResearchSubjectUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for ResearchSubject")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateResearchSubject(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.RiskAssessment:
		impl, ok := w.Concrete.(RiskAssessmentUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for RiskAssessment")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateRiskAssessment(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.RiskEvidenceSynthesis:
		impl, ok := w.Concrete.(RiskEvidenceSynthesisUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for RiskEvidenceSynthesis")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateRiskEvidenceSynthesis(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Schedule:
		impl, ok := w.Concrete.(ScheduleUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Schedule")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSchedule(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.SearchParameter:
		impl, ok := w.Concrete.(SearchParameterUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for SearchParameter")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSearchParameter(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.ServiceRequest:
		impl, ok := w.Concrete.(ServiceRequestUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for ServiceRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateServiceRequest(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Slot:
		impl, ok := w.Concrete.(SlotUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Slot")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSlot(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Specimen:
		impl, ok := w.Concrete.(SpecimenUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Specimen")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSpecimen(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.SpecimenDefinition:
		impl, ok := w.Concrete.(SpecimenDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for SpecimenDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSpecimenDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.StructureDefinition:
		impl, ok := w.Concrete.(StructureDefinitionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for StructureDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateStructureDefinition(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.StructureMap:
		impl, ok := w.Concrete.(StructureMapUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for StructureMap")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateStructureMap(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Subscription:
		impl, ok := w.Concrete.(SubscriptionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Subscription")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSubscription(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Substance:
		impl, ok := w.Concrete.(SubstanceUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Substance")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSubstance(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.SubstanceNucleicAcid:
		impl, ok := w.Concrete.(SubstanceNucleicAcidUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for SubstanceNucleicAcid")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSubstanceNucleicAcid(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.SubstancePolymer:
		impl, ok := w.Concrete.(SubstancePolymerUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for SubstancePolymer")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSubstancePolymer(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.SubstanceProtein:
		impl, ok := w.Concrete.(SubstanceProteinUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for SubstanceProtein")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSubstanceProtein(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.SubstanceReferenceInformation:
		impl, ok := w.Concrete.(SubstanceReferenceInformationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for SubstanceReferenceInformation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSubstanceReferenceInformation(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.SubstanceSourceMaterial:
		impl, ok := w.Concrete.(SubstanceSourceMaterialUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for SubstanceSourceMaterial")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSubstanceSourceMaterial(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.SubstanceSpecification:
		impl, ok := w.Concrete.(SubstanceSpecificationUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for SubstanceSpecification")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSubstanceSpecification(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.SupplyDelivery:
		impl, ok := w.Concrete.(SupplyDeliveryUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for SupplyDelivery")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSupplyDelivery(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.SupplyRequest:
		impl, ok := w.Concrete.(SupplyRequestUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for SupplyRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateSupplyRequest(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.Task:
		impl, ok := w.Concrete.(TaskUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for Task")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateTask(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.TerminologyCapabilities:
		impl, ok := w.Concrete.(TerminologyCapabilitiesUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for TerminologyCapabilities")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateTerminologyCapabilities(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.TestReport:
		impl, ok := w.Concrete.(TestReportUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for TestReport")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateTestReport(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.TestScript:
		impl, ok := w.Concrete.(TestScriptUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for TestScript")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateTestScript(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.ValueSet:
		impl, ok := w.Concrete.(ValueSetUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for ValueSet")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateValueSet(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.VerificationResult:
		impl, ok := w.Concrete.(VerificationResultUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for VerificationResult")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateVerificationResult(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	case r4.VisionPrescription:
		impl, ok := w.Concrete.(VisionPrescriptionUpdate)
		if !ok {
			return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("update not implemented for VisionPrescription")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.UpdateVisionPrescription(ctx, r)
		if err != nil {
			return update.Result[model.Resource]{}, err
		}
		return update.Result[model.Resource]{

			Created:  result.Created,
			Resource: result.Resource,
		}, nil
	default:
		return update.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
			Code:        r4.Code{Value: ptr.To("processing")},
			Diagnostics: &r4.String{Value: ptr.To("invalid resource type: " + resource.ResourceType())},
			Severity:    r4.Code{Value: ptr.To("fatal")},
		}}}
	}
}
func (w Generic) Delete(ctx context.Context, resourceType string, id string) error {
	g, ok := w.Concrete.(capabilities.GenericDelete)
	if ok {
		// shortcut for the case that the underlying implementation already implements the generic API
		return g.Delete(ctx, resourceType, id)
	}
	switch resourceType {
	case "Account":
		impl, ok := w.Concrete.(AccountDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Account")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteAccount(ctx, id)
	case "ActivityDefinition":
		impl, ok := w.Concrete.(ActivityDefinitionDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for ActivityDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteActivityDefinition(ctx, id)
	case "AdverseEvent":
		impl, ok := w.Concrete.(AdverseEventDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for AdverseEvent")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteAdverseEvent(ctx, id)
	case "AllergyIntolerance":
		impl, ok := w.Concrete.(AllergyIntoleranceDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for AllergyIntolerance")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteAllergyIntolerance(ctx, id)
	case "Appointment":
		impl, ok := w.Concrete.(AppointmentDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Appointment")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteAppointment(ctx, id)
	case "AppointmentResponse":
		impl, ok := w.Concrete.(AppointmentResponseDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for AppointmentResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteAppointmentResponse(ctx, id)
	case "AuditEvent":
		impl, ok := w.Concrete.(AuditEventDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for AuditEvent")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteAuditEvent(ctx, id)
	case "Basic":
		impl, ok := w.Concrete.(BasicDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Basic")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteBasic(ctx, id)
	case "Binary":
		impl, ok := w.Concrete.(BinaryDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Binary")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteBinary(ctx, id)
	case "BiologicallyDerivedProduct":
		impl, ok := w.Concrete.(BiologicallyDerivedProductDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for BiologicallyDerivedProduct")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteBiologicallyDerivedProduct(ctx, id)
	case "BodyStructure":
		impl, ok := w.Concrete.(BodyStructureDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for BodyStructure")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteBodyStructure(ctx, id)
	case "Bundle":
		impl, ok := w.Concrete.(BundleDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Bundle")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteBundle(ctx, id)
	case "CapabilityStatement":
		impl, ok := w.Concrete.(CapabilityStatementDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for CapabilityStatement")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteCapabilityStatement(ctx, id)
	case "CarePlan":
		impl, ok := w.Concrete.(CarePlanDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for CarePlan")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteCarePlan(ctx, id)
	case "CareTeam":
		impl, ok := w.Concrete.(CareTeamDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for CareTeam")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteCareTeam(ctx, id)
	case "CatalogEntry":
		impl, ok := w.Concrete.(CatalogEntryDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for CatalogEntry")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteCatalogEntry(ctx, id)
	case "ChargeItem":
		impl, ok := w.Concrete.(ChargeItemDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for ChargeItem")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteChargeItem(ctx, id)
	case "ChargeItemDefinition":
		impl, ok := w.Concrete.(ChargeItemDefinitionDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for ChargeItemDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteChargeItemDefinition(ctx, id)
	case "Claim":
		impl, ok := w.Concrete.(ClaimDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Claim")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteClaim(ctx, id)
	case "ClaimResponse":
		impl, ok := w.Concrete.(ClaimResponseDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for ClaimResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteClaimResponse(ctx, id)
	case "ClinicalImpression":
		impl, ok := w.Concrete.(ClinicalImpressionDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for ClinicalImpression")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteClinicalImpression(ctx, id)
	case "CodeSystem":
		impl, ok := w.Concrete.(CodeSystemDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for CodeSystem")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteCodeSystem(ctx, id)
	case "Communication":
		impl, ok := w.Concrete.(CommunicationDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Communication")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteCommunication(ctx, id)
	case "CommunicationRequest":
		impl, ok := w.Concrete.(CommunicationRequestDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for CommunicationRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteCommunicationRequest(ctx, id)
	case "CompartmentDefinition":
		impl, ok := w.Concrete.(CompartmentDefinitionDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for CompartmentDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteCompartmentDefinition(ctx, id)
	case "Composition":
		impl, ok := w.Concrete.(CompositionDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Composition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteComposition(ctx, id)
	case "ConceptMap":
		impl, ok := w.Concrete.(ConceptMapDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for ConceptMap")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteConceptMap(ctx, id)
	case "Condition":
		impl, ok := w.Concrete.(ConditionDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Condition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteCondition(ctx, id)
	case "Consent":
		impl, ok := w.Concrete.(ConsentDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Consent")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteConsent(ctx, id)
	case "Contract":
		impl, ok := w.Concrete.(ContractDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Contract")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteContract(ctx, id)
	case "Coverage":
		impl, ok := w.Concrete.(CoverageDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Coverage")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteCoverage(ctx, id)
	case "CoverageEligibilityRequest":
		impl, ok := w.Concrete.(CoverageEligibilityRequestDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for CoverageEligibilityRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteCoverageEligibilityRequest(ctx, id)
	case "CoverageEligibilityResponse":
		impl, ok := w.Concrete.(CoverageEligibilityResponseDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for CoverageEligibilityResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteCoverageEligibilityResponse(ctx, id)
	case "DetectedIssue":
		impl, ok := w.Concrete.(DetectedIssueDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for DetectedIssue")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteDetectedIssue(ctx, id)
	case "Device":
		impl, ok := w.Concrete.(DeviceDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Device")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteDevice(ctx, id)
	case "DeviceDefinition":
		impl, ok := w.Concrete.(DeviceDefinitionDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for DeviceDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteDeviceDefinition(ctx, id)
	case "DeviceMetric":
		impl, ok := w.Concrete.(DeviceMetricDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for DeviceMetric")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteDeviceMetric(ctx, id)
	case "DeviceRequest":
		impl, ok := w.Concrete.(DeviceRequestDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for DeviceRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteDeviceRequest(ctx, id)
	case "DeviceUseStatement":
		impl, ok := w.Concrete.(DeviceUseStatementDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for DeviceUseStatement")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteDeviceUseStatement(ctx, id)
	case "DiagnosticReport":
		impl, ok := w.Concrete.(DiagnosticReportDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for DiagnosticReport")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteDiagnosticReport(ctx, id)
	case "DocumentManifest":
		impl, ok := w.Concrete.(DocumentManifestDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for DocumentManifest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteDocumentManifest(ctx, id)
	case "DocumentReference":
		impl, ok := w.Concrete.(DocumentReferenceDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for DocumentReference")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteDocumentReference(ctx, id)
	case "EffectEvidenceSynthesis":
		impl, ok := w.Concrete.(EffectEvidenceSynthesisDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for EffectEvidenceSynthesis")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteEffectEvidenceSynthesis(ctx, id)
	case "Encounter":
		impl, ok := w.Concrete.(EncounterDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Encounter")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteEncounter(ctx, id)
	case "Endpoint":
		impl, ok := w.Concrete.(EndpointDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Endpoint")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteEndpoint(ctx, id)
	case "EnrollmentRequest":
		impl, ok := w.Concrete.(EnrollmentRequestDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for EnrollmentRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteEnrollmentRequest(ctx, id)
	case "EnrollmentResponse":
		impl, ok := w.Concrete.(EnrollmentResponseDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for EnrollmentResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteEnrollmentResponse(ctx, id)
	case "EpisodeOfCare":
		impl, ok := w.Concrete.(EpisodeOfCareDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for EpisodeOfCare")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteEpisodeOfCare(ctx, id)
	case "EventDefinition":
		impl, ok := w.Concrete.(EventDefinitionDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for EventDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteEventDefinition(ctx, id)
	case "Evidence":
		impl, ok := w.Concrete.(EvidenceDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Evidence")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteEvidence(ctx, id)
	case "EvidenceVariable":
		impl, ok := w.Concrete.(EvidenceVariableDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for EvidenceVariable")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteEvidenceVariable(ctx, id)
	case "ExampleScenario":
		impl, ok := w.Concrete.(ExampleScenarioDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for ExampleScenario")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteExampleScenario(ctx, id)
	case "ExplanationOfBenefit":
		impl, ok := w.Concrete.(ExplanationOfBenefitDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for ExplanationOfBenefit")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteExplanationOfBenefit(ctx, id)
	case "FamilyMemberHistory":
		impl, ok := w.Concrete.(FamilyMemberHistoryDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for FamilyMemberHistory")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteFamilyMemberHistory(ctx, id)
	case "Flag":
		impl, ok := w.Concrete.(FlagDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Flag")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteFlag(ctx, id)
	case "Goal":
		impl, ok := w.Concrete.(GoalDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Goal")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteGoal(ctx, id)
	case "GraphDefinition":
		impl, ok := w.Concrete.(GraphDefinitionDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for GraphDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteGraphDefinition(ctx, id)
	case "Group":
		impl, ok := w.Concrete.(GroupDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Group")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteGroup(ctx, id)
	case "GuidanceResponse":
		impl, ok := w.Concrete.(GuidanceResponseDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for GuidanceResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteGuidanceResponse(ctx, id)
	case "HealthcareService":
		impl, ok := w.Concrete.(HealthcareServiceDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for HealthcareService")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteHealthcareService(ctx, id)
	case "ImagingStudy":
		impl, ok := w.Concrete.(ImagingStudyDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for ImagingStudy")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteImagingStudy(ctx, id)
	case "Immunization":
		impl, ok := w.Concrete.(ImmunizationDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Immunization")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteImmunization(ctx, id)
	case "ImmunizationEvaluation":
		impl, ok := w.Concrete.(ImmunizationEvaluationDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for ImmunizationEvaluation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteImmunizationEvaluation(ctx, id)
	case "ImmunizationRecommendation":
		impl, ok := w.Concrete.(ImmunizationRecommendationDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for ImmunizationRecommendation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteImmunizationRecommendation(ctx, id)
	case "ImplementationGuide":
		impl, ok := w.Concrete.(ImplementationGuideDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for ImplementationGuide")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteImplementationGuide(ctx, id)
	case "InsurancePlan":
		impl, ok := w.Concrete.(InsurancePlanDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for InsurancePlan")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteInsurancePlan(ctx, id)
	case "Invoice":
		impl, ok := w.Concrete.(InvoiceDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Invoice")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteInvoice(ctx, id)
	case "Library":
		impl, ok := w.Concrete.(LibraryDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Library")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteLibrary(ctx, id)
	case "Linkage":
		impl, ok := w.Concrete.(LinkageDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Linkage")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteLinkage(ctx, id)
	case "List":
		impl, ok := w.Concrete.(ListDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for List")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteList(ctx, id)
	case "Location":
		impl, ok := w.Concrete.(LocationDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Location")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteLocation(ctx, id)
	case "Measure":
		impl, ok := w.Concrete.(MeasureDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Measure")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMeasure(ctx, id)
	case "MeasureReport":
		impl, ok := w.Concrete.(MeasureReportDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for MeasureReport")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMeasureReport(ctx, id)
	case "Media":
		impl, ok := w.Concrete.(MediaDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Media")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMedia(ctx, id)
	case "Medication":
		impl, ok := w.Concrete.(MedicationDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Medication")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMedication(ctx, id)
	case "MedicationAdministration":
		impl, ok := w.Concrete.(MedicationAdministrationDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for MedicationAdministration")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMedicationAdministration(ctx, id)
	case "MedicationDispense":
		impl, ok := w.Concrete.(MedicationDispenseDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for MedicationDispense")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMedicationDispense(ctx, id)
	case "MedicationKnowledge":
		impl, ok := w.Concrete.(MedicationKnowledgeDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for MedicationKnowledge")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMedicationKnowledge(ctx, id)
	case "MedicationRequest":
		impl, ok := w.Concrete.(MedicationRequestDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for MedicationRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMedicationRequest(ctx, id)
	case "MedicationStatement":
		impl, ok := w.Concrete.(MedicationStatementDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for MedicationStatement")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMedicationStatement(ctx, id)
	case "MedicinalProduct":
		impl, ok := w.Concrete.(MedicinalProductDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for MedicinalProduct")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMedicinalProduct(ctx, id)
	case "MedicinalProductAuthorization":
		impl, ok := w.Concrete.(MedicinalProductAuthorizationDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for MedicinalProductAuthorization")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMedicinalProductAuthorization(ctx, id)
	case "MedicinalProductContraindication":
		impl, ok := w.Concrete.(MedicinalProductContraindicationDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for MedicinalProductContraindication")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMedicinalProductContraindication(ctx, id)
	case "MedicinalProductIndication":
		impl, ok := w.Concrete.(MedicinalProductIndicationDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for MedicinalProductIndication")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMedicinalProductIndication(ctx, id)
	case "MedicinalProductIngredient":
		impl, ok := w.Concrete.(MedicinalProductIngredientDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for MedicinalProductIngredient")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMedicinalProductIngredient(ctx, id)
	case "MedicinalProductInteraction":
		impl, ok := w.Concrete.(MedicinalProductInteractionDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for MedicinalProductInteraction")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMedicinalProductInteraction(ctx, id)
	case "MedicinalProductManufactured":
		impl, ok := w.Concrete.(MedicinalProductManufacturedDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for MedicinalProductManufactured")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMedicinalProductManufactured(ctx, id)
	case "MedicinalProductPackaged":
		impl, ok := w.Concrete.(MedicinalProductPackagedDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for MedicinalProductPackaged")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMedicinalProductPackaged(ctx, id)
	case "MedicinalProductPharmaceutical":
		impl, ok := w.Concrete.(MedicinalProductPharmaceuticalDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for MedicinalProductPharmaceutical")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMedicinalProductPharmaceutical(ctx, id)
	case "MedicinalProductUndesirableEffect":
		impl, ok := w.Concrete.(MedicinalProductUndesirableEffectDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for MedicinalProductUndesirableEffect")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMedicinalProductUndesirableEffect(ctx, id)
	case "MessageDefinition":
		impl, ok := w.Concrete.(MessageDefinitionDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for MessageDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMessageDefinition(ctx, id)
	case "MessageHeader":
		impl, ok := w.Concrete.(MessageHeaderDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for MessageHeader")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMessageHeader(ctx, id)
	case "MolecularSequence":
		impl, ok := w.Concrete.(MolecularSequenceDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for MolecularSequence")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteMolecularSequence(ctx, id)
	case "NamingSystem":
		impl, ok := w.Concrete.(NamingSystemDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for NamingSystem")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteNamingSystem(ctx, id)
	case "NutritionOrder":
		impl, ok := w.Concrete.(NutritionOrderDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for NutritionOrder")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteNutritionOrder(ctx, id)
	case "Observation":
		impl, ok := w.Concrete.(ObservationDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Observation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteObservation(ctx, id)
	case "ObservationDefinition":
		impl, ok := w.Concrete.(ObservationDefinitionDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for ObservationDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteObservationDefinition(ctx, id)
	case "OperationDefinition":
		impl, ok := w.Concrete.(OperationDefinitionDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for OperationDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteOperationDefinition(ctx, id)
	case "OperationOutcome":
		impl, ok := w.Concrete.(OperationOutcomeDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for OperationOutcome")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteOperationOutcome(ctx, id)
	case "Organization":
		impl, ok := w.Concrete.(OrganizationDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Organization")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteOrganization(ctx, id)
	case "OrganizationAffiliation":
		impl, ok := w.Concrete.(OrganizationAffiliationDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for OrganizationAffiliation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteOrganizationAffiliation(ctx, id)
	case "Parameters":
		impl, ok := w.Concrete.(ParametersDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Parameters")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteParameters(ctx, id)
	case "Patient":
		impl, ok := w.Concrete.(PatientDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Patient")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeletePatient(ctx, id)
	case "PaymentNotice":
		impl, ok := w.Concrete.(PaymentNoticeDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for PaymentNotice")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeletePaymentNotice(ctx, id)
	case "PaymentReconciliation":
		impl, ok := w.Concrete.(PaymentReconciliationDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for PaymentReconciliation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeletePaymentReconciliation(ctx, id)
	case "Person":
		impl, ok := w.Concrete.(PersonDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Person")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeletePerson(ctx, id)
	case "PlanDefinition":
		impl, ok := w.Concrete.(PlanDefinitionDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for PlanDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeletePlanDefinition(ctx, id)
	case "Practitioner":
		impl, ok := w.Concrete.(PractitionerDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Practitioner")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeletePractitioner(ctx, id)
	case "PractitionerRole":
		impl, ok := w.Concrete.(PractitionerRoleDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for PractitionerRole")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeletePractitionerRole(ctx, id)
	case "Procedure":
		impl, ok := w.Concrete.(ProcedureDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Procedure")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteProcedure(ctx, id)
	case "Provenance":
		impl, ok := w.Concrete.(ProvenanceDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Provenance")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteProvenance(ctx, id)
	case "Questionnaire":
		impl, ok := w.Concrete.(QuestionnaireDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Questionnaire")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteQuestionnaire(ctx, id)
	case "QuestionnaireResponse":
		impl, ok := w.Concrete.(QuestionnaireResponseDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for QuestionnaireResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteQuestionnaireResponse(ctx, id)
	case "RelatedPerson":
		impl, ok := w.Concrete.(RelatedPersonDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for RelatedPerson")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteRelatedPerson(ctx, id)
	case "RequestGroup":
		impl, ok := w.Concrete.(RequestGroupDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for RequestGroup")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteRequestGroup(ctx, id)
	case "ResearchDefinition":
		impl, ok := w.Concrete.(ResearchDefinitionDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for ResearchDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteResearchDefinition(ctx, id)
	case "ResearchElementDefinition":
		impl, ok := w.Concrete.(ResearchElementDefinitionDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for ResearchElementDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteResearchElementDefinition(ctx, id)
	case "ResearchStudy":
		impl, ok := w.Concrete.(ResearchStudyDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for ResearchStudy")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteResearchStudy(ctx, id)
	case "ResearchSubject":
		impl, ok := w.Concrete.(ResearchSubjectDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for ResearchSubject")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteResearchSubject(ctx, id)
	case "RiskAssessment":
		impl, ok := w.Concrete.(RiskAssessmentDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for RiskAssessment")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteRiskAssessment(ctx, id)
	case "RiskEvidenceSynthesis":
		impl, ok := w.Concrete.(RiskEvidenceSynthesisDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for RiskEvidenceSynthesis")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteRiskEvidenceSynthesis(ctx, id)
	case "Schedule":
		impl, ok := w.Concrete.(ScheduleDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Schedule")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSchedule(ctx, id)
	case "SearchParameter":
		impl, ok := w.Concrete.(SearchParameterDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for SearchParameter")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSearchParameter(ctx, id)
	case "ServiceRequest":
		impl, ok := w.Concrete.(ServiceRequestDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for ServiceRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteServiceRequest(ctx, id)
	case "Slot":
		impl, ok := w.Concrete.(SlotDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Slot")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSlot(ctx, id)
	case "Specimen":
		impl, ok := w.Concrete.(SpecimenDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Specimen")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSpecimen(ctx, id)
	case "SpecimenDefinition":
		impl, ok := w.Concrete.(SpecimenDefinitionDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for SpecimenDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSpecimenDefinition(ctx, id)
	case "StructureDefinition":
		impl, ok := w.Concrete.(StructureDefinitionDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for StructureDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteStructureDefinition(ctx, id)
	case "StructureMap":
		impl, ok := w.Concrete.(StructureMapDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for StructureMap")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteStructureMap(ctx, id)
	case "Subscription":
		impl, ok := w.Concrete.(SubscriptionDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Subscription")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSubscription(ctx, id)
	case "Substance":
		impl, ok := w.Concrete.(SubstanceDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Substance")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSubstance(ctx, id)
	case "SubstanceNucleicAcid":
		impl, ok := w.Concrete.(SubstanceNucleicAcidDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for SubstanceNucleicAcid")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSubstanceNucleicAcid(ctx, id)
	case "SubstancePolymer":
		impl, ok := w.Concrete.(SubstancePolymerDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for SubstancePolymer")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSubstancePolymer(ctx, id)
	case "SubstanceProtein":
		impl, ok := w.Concrete.(SubstanceProteinDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for SubstanceProtein")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSubstanceProtein(ctx, id)
	case "SubstanceReferenceInformation":
		impl, ok := w.Concrete.(SubstanceReferenceInformationDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for SubstanceReferenceInformation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSubstanceReferenceInformation(ctx, id)
	case "SubstanceSourceMaterial":
		impl, ok := w.Concrete.(SubstanceSourceMaterialDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for SubstanceSourceMaterial")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSubstanceSourceMaterial(ctx, id)
	case "SubstanceSpecification":
		impl, ok := w.Concrete.(SubstanceSpecificationDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for SubstanceSpecification")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSubstanceSpecification(ctx, id)
	case "SupplyDelivery":
		impl, ok := w.Concrete.(SupplyDeliveryDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for SupplyDelivery")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSupplyDelivery(ctx, id)
	case "SupplyRequest":
		impl, ok := w.Concrete.(SupplyRequestDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for SupplyRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteSupplyRequest(ctx, id)
	case "Task":
		impl, ok := w.Concrete.(TaskDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for Task")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteTask(ctx, id)
	case "TerminologyCapabilities":
		impl, ok := w.Concrete.(TerminologyCapabilitiesDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for TerminologyCapabilities")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteTerminologyCapabilities(ctx, id)
	case "TestReport":
		impl, ok := w.Concrete.(TestReportDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for TestReport")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteTestReport(ctx, id)
	case "TestScript":
		impl, ok := w.Concrete.(TestScriptDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for TestScript")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteTestScript(ctx, id)
	case "ValueSet":
		impl, ok := w.Concrete.(ValueSetDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for ValueSet")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteValueSet(ctx, id)
	case "VerificationResult":
		impl, ok := w.Concrete.(VerificationResultDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for VerificationResult")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteVerificationResult(ctx, id)
	case "VisionPrescription":
		impl, ok := w.Concrete.(VisionPrescriptionDelete)
		if !ok {
			return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("delete not implemented for VisionPrescription")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		return impl.DeleteVisionPrescription(ctx, id)
	default:
		return r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
			Code:        r4.Code{Value: ptr.To("processing")},
			Diagnostics: &r4.String{Value: ptr.To("invalid resource type: " + resourceType)},
			Severity:    r4.Code{Value: ptr.To("fatal")},
		}}}
	}
}
func (w Generic) Search(ctx context.Context, resourceType string, parameters search.Parameters, options search.Options) (search.Result[model.Resource], error) {
	g, ok := w.Concrete.(capabilities.GenericSearch)
	if ok {
		// shortcut for the case that the underlying implementation already implements the generic API
		return g.Search(ctx, resourceType, parameters, options)
	}
	switch resourceType {
	case "Account":
		impl, ok := w.Concrete.(AccountSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Account")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchAccount(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ActivityDefinition":
		impl, ok := w.Concrete.(ActivityDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for ActivityDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchActivityDefinition(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "AdverseEvent":
		impl, ok := w.Concrete.(AdverseEventSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for AdverseEvent")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchAdverseEvent(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "AllergyIntolerance":
		impl, ok := w.Concrete.(AllergyIntoleranceSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for AllergyIntolerance")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchAllergyIntolerance(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Appointment":
		impl, ok := w.Concrete.(AppointmentSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Appointment")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchAppointment(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "AppointmentResponse":
		impl, ok := w.Concrete.(AppointmentResponseSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for AppointmentResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchAppointmentResponse(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "AuditEvent":
		impl, ok := w.Concrete.(AuditEventSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for AuditEvent")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchAuditEvent(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Basic":
		impl, ok := w.Concrete.(BasicSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Basic")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchBasic(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Binary":
		impl, ok := w.Concrete.(BinarySearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Binary")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchBinary(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "BiologicallyDerivedProduct":
		impl, ok := w.Concrete.(BiologicallyDerivedProductSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for BiologicallyDerivedProduct")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchBiologicallyDerivedProduct(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "BodyStructure":
		impl, ok := w.Concrete.(BodyStructureSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for BodyStructure")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchBodyStructure(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Bundle":
		impl, ok := w.Concrete.(BundleSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Bundle")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchBundle(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "CapabilityStatement":
		impl, ok := w.Concrete.(CapabilityStatementSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for CapabilityStatement")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchCapabilityStatement(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "CarePlan":
		impl, ok := w.Concrete.(CarePlanSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for CarePlan")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchCarePlan(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "CareTeam":
		impl, ok := w.Concrete.(CareTeamSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for CareTeam")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchCareTeam(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "CatalogEntry":
		impl, ok := w.Concrete.(CatalogEntrySearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for CatalogEntry")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchCatalogEntry(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ChargeItem":
		impl, ok := w.Concrete.(ChargeItemSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for ChargeItem")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchChargeItem(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ChargeItemDefinition":
		impl, ok := w.Concrete.(ChargeItemDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for ChargeItemDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchChargeItemDefinition(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Claim":
		impl, ok := w.Concrete.(ClaimSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Claim")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchClaim(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ClaimResponse":
		impl, ok := w.Concrete.(ClaimResponseSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for ClaimResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchClaimResponse(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ClinicalImpression":
		impl, ok := w.Concrete.(ClinicalImpressionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for ClinicalImpression")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchClinicalImpression(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "CodeSystem":
		impl, ok := w.Concrete.(CodeSystemSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for CodeSystem")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchCodeSystem(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Communication":
		impl, ok := w.Concrete.(CommunicationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Communication")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchCommunication(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "CommunicationRequest":
		impl, ok := w.Concrete.(CommunicationRequestSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for CommunicationRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchCommunicationRequest(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "CompartmentDefinition":
		impl, ok := w.Concrete.(CompartmentDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for CompartmentDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchCompartmentDefinition(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Composition":
		impl, ok := w.Concrete.(CompositionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Composition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchComposition(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ConceptMap":
		impl, ok := w.Concrete.(ConceptMapSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for ConceptMap")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchConceptMap(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Condition":
		impl, ok := w.Concrete.(ConditionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Condition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchCondition(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Consent":
		impl, ok := w.Concrete.(ConsentSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Consent")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchConsent(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Contract":
		impl, ok := w.Concrete.(ContractSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Contract")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchContract(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Coverage":
		impl, ok := w.Concrete.(CoverageSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Coverage")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchCoverage(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "CoverageEligibilityRequest":
		impl, ok := w.Concrete.(CoverageEligibilityRequestSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for CoverageEligibilityRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchCoverageEligibilityRequest(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "CoverageEligibilityResponse":
		impl, ok := w.Concrete.(CoverageEligibilityResponseSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for CoverageEligibilityResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchCoverageEligibilityResponse(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "DetectedIssue":
		impl, ok := w.Concrete.(DetectedIssueSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for DetectedIssue")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchDetectedIssue(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Device":
		impl, ok := w.Concrete.(DeviceSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Device")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchDevice(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "DeviceDefinition":
		impl, ok := w.Concrete.(DeviceDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for DeviceDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchDeviceDefinition(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "DeviceMetric":
		impl, ok := w.Concrete.(DeviceMetricSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for DeviceMetric")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchDeviceMetric(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "DeviceRequest":
		impl, ok := w.Concrete.(DeviceRequestSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for DeviceRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchDeviceRequest(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "DeviceUseStatement":
		impl, ok := w.Concrete.(DeviceUseStatementSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for DeviceUseStatement")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchDeviceUseStatement(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "DiagnosticReport":
		impl, ok := w.Concrete.(DiagnosticReportSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for DiagnosticReport")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchDiagnosticReport(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "DocumentManifest":
		impl, ok := w.Concrete.(DocumentManifestSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for DocumentManifest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchDocumentManifest(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "DocumentReference":
		impl, ok := w.Concrete.(DocumentReferenceSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for DocumentReference")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchDocumentReference(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "EffectEvidenceSynthesis":
		impl, ok := w.Concrete.(EffectEvidenceSynthesisSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for EffectEvidenceSynthesis")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchEffectEvidenceSynthesis(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Encounter":
		impl, ok := w.Concrete.(EncounterSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Encounter")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchEncounter(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Endpoint":
		impl, ok := w.Concrete.(EndpointSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Endpoint")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchEndpoint(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "EnrollmentRequest":
		impl, ok := w.Concrete.(EnrollmentRequestSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for EnrollmentRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchEnrollmentRequest(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "EnrollmentResponse":
		impl, ok := w.Concrete.(EnrollmentResponseSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for EnrollmentResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchEnrollmentResponse(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "EpisodeOfCare":
		impl, ok := w.Concrete.(EpisodeOfCareSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for EpisodeOfCare")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchEpisodeOfCare(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "EventDefinition":
		impl, ok := w.Concrete.(EventDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for EventDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchEventDefinition(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Evidence":
		impl, ok := w.Concrete.(EvidenceSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Evidence")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchEvidence(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "EvidenceVariable":
		impl, ok := w.Concrete.(EvidenceVariableSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for EvidenceVariable")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchEvidenceVariable(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ExampleScenario":
		impl, ok := w.Concrete.(ExampleScenarioSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for ExampleScenario")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchExampleScenario(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ExplanationOfBenefit":
		impl, ok := w.Concrete.(ExplanationOfBenefitSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for ExplanationOfBenefit")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchExplanationOfBenefit(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "FamilyMemberHistory":
		impl, ok := w.Concrete.(FamilyMemberHistorySearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for FamilyMemberHistory")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchFamilyMemberHistory(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Flag":
		impl, ok := w.Concrete.(FlagSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Flag")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchFlag(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Goal":
		impl, ok := w.Concrete.(GoalSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Goal")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchGoal(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "GraphDefinition":
		impl, ok := w.Concrete.(GraphDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for GraphDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchGraphDefinition(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Group":
		impl, ok := w.Concrete.(GroupSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Group")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchGroup(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "GuidanceResponse":
		impl, ok := w.Concrete.(GuidanceResponseSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for GuidanceResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchGuidanceResponse(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "HealthcareService":
		impl, ok := w.Concrete.(HealthcareServiceSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for HealthcareService")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchHealthcareService(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ImagingStudy":
		impl, ok := w.Concrete.(ImagingStudySearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for ImagingStudy")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchImagingStudy(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Immunization":
		impl, ok := w.Concrete.(ImmunizationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Immunization")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchImmunization(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ImmunizationEvaluation":
		impl, ok := w.Concrete.(ImmunizationEvaluationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for ImmunizationEvaluation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchImmunizationEvaluation(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ImmunizationRecommendation":
		impl, ok := w.Concrete.(ImmunizationRecommendationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for ImmunizationRecommendation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchImmunizationRecommendation(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ImplementationGuide":
		impl, ok := w.Concrete.(ImplementationGuideSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for ImplementationGuide")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchImplementationGuide(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "InsurancePlan":
		impl, ok := w.Concrete.(InsurancePlanSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for InsurancePlan")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchInsurancePlan(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Invoice":
		impl, ok := w.Concrete.(InvoiceSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Invoice")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchInvoice(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Library":
		impl, ok := w.Concrete.(LibrarySearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Library")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchLibrary(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Linkage":
		impl, ok := w.Concrete.(LinkageSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Linkage")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchLinkage(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "List":
		impl, ok := w.Concrete.(ListSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for List")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchList(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Location":
		impl, ok := w.Concrete.(LocationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Location")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchLocation(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Measure":
		impl, ok := w.Concrete.(MeasureSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Measure")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMeasure(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MeasureReport":
		impl, ok := w.Concrete.(MeasureReportSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for MeasureReport")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMeasureReport(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Media":
		impl, ok := w.Concrete.(MediaSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Media")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMedia(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Medication":
		impl, ok := w.Concrete.(MedicationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Medication")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMedication(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MedicationAdministration":
		impl, ok := w.Concrete.(MedicationAdministrationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for MedicationAdministration")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMedicationAdministration(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MedicationDispense":
		impl, ok := w.Concrete.(MedicationDispenseSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for MedicationDispense")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMedicationDispense(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MedicationKnowledge":
		impl, ok := w.Concrete.(MedicationKnowledgeSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for MedicationKnowledge")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMedicationKnowledge(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MedicationRequest":
		impl, ok := w.Concrete.(MedicationRequestSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for MedicationRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMedicationRequest(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MedicationStatement":
		impl, ok := w.Concrete.(MedicationStatementSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for MedicationStatement")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMedicationStatement(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MedicinalProduct":
		impl, ok := w.Concrete.(MedicinalProductSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for MedicinalProduct")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMedicinalProduct(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MedicinalProductAuthorization":
		impl, ok := w.Concrete.(MedicinalProductAuthorizationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for MedicinalProductAuthorization")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMedicinalProductAuthorization(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MedicinalProductContraindication":
		impl, ok := w.Concrete.(MedicinalProductContraindicationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for MedicinalProductContraindication")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMedicinalProductContraindication(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MedicinalProductIndication":
		impl, ok := w.Concrete.(MedicinalProductIndicationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for MedicinalProductIndication")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMedicinalProductIndication(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MedicinalProductIngredient":
		impl, ok := w.Concrete.(MedicinalProductIngredientSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for MedicinalProductIngredient")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMedicinalProductIngredient(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MedicinalProductInteraction":
		impl, ok := w.Concrete.(MedicinalProductInteractionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for MedicinalProductInteraction")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMedicinalProductInteraction(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MedicinalProductManufactured":
		impl, ok := w.Concrete.(MedicinalProductManufacturedSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for MedicinalProductManufactured")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMedicinalProductManufactured(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MedicinalProductPackaged":
		impl, ok := w.Concrete.(MedicinalProductPackagedSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for MedicinalProductPackaged")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMedicinalProductPackaged(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MedicinalProductPharmaceutical":
		impl, ok := w.Concrete.(MedicinalProductPharmaceuticalSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for MedicinalProductPharmaceutical")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMedicinalProductPharmaceutical(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MedicinalProductUndesirableEffect":
		impl, ok := w.Concrete.(MedicinalProductUndesirableEffectSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for MedicinalProductUndesirableEffect")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMedicinalProductUndesirableEffect(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MessageDefinition":
		impl, ok := w.Concrete.(MessageDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for MessageDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMessageDefinition(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MessageHeader":
		impl, ok := w.Concrete.(MessageHeaderSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for MessageHeader")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMessageHeader(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "MolecularSequence":
		impl, ok := w.Concrete.(MolecularSequenceSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for MolecularSequence")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchMolecularSequence(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "NamingSystem":
		impl, ok := w.Concrete.(NamingSystemSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for NamingSystem")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchNamingSystem(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "NutritionOrder":
		impl, ok := w.Concrete.(NutritionOrderSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for NutritionOrder")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchNutritionOrder(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Observation":
		impl, ok := w.Concrete.(ObservationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Observation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchObservation(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ObservationDefinition":
		impl, ok := w.Concrete.(ObservationDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for ObservationDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchObservationDefinition(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "OperationDefinition":
		impl, ok := w.Concrete.(OperationDefinitionSearch)
		if ok {
			result, err := impl.SearchOperationDefinition(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		cs, err := w.Concrete.CapabilityBase(ctx)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		var baseUrl string
		if cs.Implementation != nil && cs.Implementation.Url != nil && cs.Implementation.Url.Value != nil {
			baseUrl = *cs.Implementation.Url.Value
		}
		defs, err := operationDefinitionsByID(ctx, w.Concrete, baseUrl)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		filtered := make(map[string]r4.OperationDefinition)
		for id, od := range defs {
			filtered[id] = od
		}
		if idParams, ok := parameters.Map()[search.ParameterKey{Name: "_id"}]; ok {
			filtered = make(map[string]r4.OperationDefinition)
			for _, idValues := range idParams {
				for _, idValue := range idValues {
					idStr := idValue.String()
					if od, exists := defs[idStr]; exists {
						filtered[idStr] = od
					}
				}
			}
		}
		sortedIds := make([]string, 0, len(filtered))
		for id, _ := range filtered {
			sortedIds = append(sortedIds, id)
		}
		sort.Strings(sortedIds)
		allResources := make([]model.Resource, 0, len(filtered))
		for _, id := range sortedIds {
			allResources = append(allResources, filtered[id])
		}
		var offset int
		opts := options
		if opts.Cursor != "" {
			parsedOffset, err := strconv.Atoi(string(opts.Cursor))
			if err != nil {
				return search.Result[model.Resource]{}, fmt.Errorf("invalid cursor: %w", err)
			}
			if parsedOffset < 0 {
				return search.Result[model.Resource]{}, fmt.Errorf("invalid cursor: offset must be non-negative")
			}
			offset = parsedOffset
		}
		var resources []model.Resource
		if offset < len(allResources) {
			resources = allResources[offset:]
		}
		var nextCursor search.Cursor
		if opts.Count > 0 && len(resources) > opts.Count {
			resources = resources[:opts.Count]
			nextOffset := offset + opts.Count
			if nextOffset < len(allResources) {
				nextCursor = search.Cursor(strconv.Itoa(nextOffset))
			}
		}
		return search.Result[model.Resource]{

			Included:  []model.Resource{},
			Next:      nextCursor,
			Resources: resources,
		}, nil
	case "OperationOutcome":
		impl, ok := w.Concrete.(OperationOutcomeSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for OperationOutcome")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchOperationOutcome(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Organization":
		impl, ok := w.Concrete.(OrganizationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Organization")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchOrganization(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "OrganizationAffiliation":
		impl, ok := w.Concrete.(OrganizationAffiliationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for OrganizationAffiliation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchOrganizationAffiliation(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Parameters":
		impl, ok := w.Concrete.(ParametersSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Parameters")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchParameters(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Patient":
		impl, ok := w.Concrete.(PatientSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Patient")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchPatient(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "PaymentNotice":
		impl, ok := w.Concrete.(PaymentNoticeSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for PaymentNotice")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchPaymentNotice(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "PaymentReconciliation":
		impl, ok := w.Concrete.(PaymentReconciliationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for PaymentReconciliation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchPaymentReconciliation(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Person":
		impl, ok := w.Concrete.(PersonSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Person")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchPerson(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "PlanDefinition":
		impl, ok := w.Concrete.(PlanDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for PlanDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchPlanDefinition(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Practitioner":
		impl, ok := w.Concrete.(PractitionerSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Practitioner")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchPractitioner(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "PractitionerRole":
		impl, ok := w.Concrete.(PractitionerRoleSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for PractitionerRole")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchPractitionerRole(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Procedure":
		impl, ok := w.Concrete.(ProcedureSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Procedure")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchProcedure(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Provenance":
		impl, ok := w.Concrete.(ProvenanceSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Provenance")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchProvenance(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Questionnaire":
		impl, ok := w.Concrete.(QuestionnaireSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Questionnaire")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchQuestionnaire(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "QuestionnaireResponse":
		impl, ok := w.Concrete.(QuestionnaireResponseSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for QuestionnaireResponse")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchQuestionnaireResponse(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "RelatedPerson":
		impl, ok := w.Concrete.(RelatedPersonSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for RelatedPerson")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchRelatedPerson(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "RequestGroup":
		impl, ok := w.Concrete.(RequestGroupSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for RequestGroup")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchRequestGroup(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ResearchDefinition":
		impl, ok := w.Concrete.(ResearchDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for ResearchDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchResearchDefinition(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ResearchElementDefinition":
		impl, ok := w.Concrete.(ResearchElementDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for ResearchElementDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchResearchElementDefinition(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ResearchStudy":
		impl, ok := w.Concrete.(ResearchStudySearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for ResearchStudy")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchResearchStudy(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ResearchSubject":
		impl, ok := w.Concrete.(ResearchSubjectSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for ResearchSubject")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchResearchSubject(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "RiskAssessment":
		impl, ok := w.Concrete.(RiskAssessmentSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for RiskAssessment")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchRiskAssessment(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "RiskEvidenceSynthesis":
		impl, ok := w.Concrete.(RiskEvidenceSynthesisSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for RiskEvidenceSynthesis")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchRiskEvidenceSynthesis(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Schedule":
		impl, ok := w.Concrete.(ScheduleSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Schedule")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSchedule(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "SearchParameter":
		impl, ok := w.Concrete.(SearchParameterSearch)
		if ok {
			result, err := impl.SearchSearchParameter(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		// Fallback: gather SearchParameter from SearchCapabilities methods if SearchSearchParameter not implemented
		// Get base URL from CapabilityStatement for canonical references
		cs, err := w.Concrete.CapabilityBase(ctx)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		var baseUrl string
		if cs.Implementation != nil && cs.Implementation.Url != nil && cs.Implementation.Url.Value != nil {
			baseUrl = *cs.Implementation.Url.Value
		}
		searchParameters, err := searchParameters(ctx, w.Concrete, baseUrl)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		filteredParameters := make(map[string]r4.SearchParameter)
		for id, searchParam := range searchParameters {
			filteredParameters[id] = searchParam
		}
		if idParams, ok := parameters.Map()[search.ParameterKey{Name: "_id"}]; ok {
			filteredParameters = make(map[string]r4.SearchParameter)
			for _, idValues := range idParams {
				for _, idValue := range idValues {
					idStr := idValue.String()
					if searchParam, exists := searchParameters[idStr]; exists {
						filteredParameters[idStr] = searchParam
					}
				}
			}
		}
		// Sort IDs for deterministic ordering
		sortedIds := make([]string, 0, len(filteredParameters))
		for id, _ := range filteredParameters {
			sortedIds = append(sortedIds, id)
		}
		sort.Strings(sortedIds)
		allResources := make([]model.Resource, 0, len(filteredParameters))
		for _, id := range sortedIds {
			allResources = append(allResources, filteredParameters[id])
		}
		var offset int
		opts := options
		if opts.Cursor != "" {
			parsedOffset, err := strconv.Atoi(string(opts.Cursor))
			if err != nil {
				return search.Result[model.Resource]{}, fmt.Errorf("invalid cursor: %w", err)
			}
			if parsedOffset < 0 {
				return search.Result[model.Resource]{}, fmt.Errorf("invalid cursor: offset must be non-negative")
			}
			offset = parsedOffset
		}
		var resources []model.Resource
		if offset < len(allResources) {
			resources = allResources[offset:]
		}
		var nextCursor search.Cursor
		if opts.Count > 0 && len(resources) > opts.Count {
			resources = resources[:opts.Count]
			nextOffset := offset + opts.Count
			if nextOffset < len(allResources) {
				nextCursor = search.Cursor(strconv.Itoa(nextOffset))
			}
		}
		return search.Result[model.Resource]{

			Included:  []model.Resource{},
			Next:      nextCursor,
			Resources: resources,
		}, nil
	case "ServiceRequest":
		impl, ok := w.Concrete.(ServiceRequestSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for ServiceRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchServiceRequest(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Slot":
		impl, ok := w.Concrete.(SlotSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Slot")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSlot(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Specimen":
		impl, ok := w.Concrete.(SpecimenSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Specimen")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSpecimen(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "SpecimenDefinition":
		impl, ok := w.Concrete.(SpecimenDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for SpecimenDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSpecimenDefinition(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "StructureDefinition":
		impl, ok := w.Concrete.(StructureDefinitionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for StructureDefinition")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchStructureDefinition(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "StructureMap":
		impl, ok := w.Concrete.(StructureMapSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for StructureMap")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchStructureMap(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Subscription":
		impl, ok := w.Concrete.(SubscriptionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Subscription")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSubscription(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Substance":
		impl, ok := w.Concrete.(SubstanceSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Substance")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSubstance(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "SubstanceNucleicAcid":
		impl, ok := w.Concrete.(SubstanceNucleicAcidSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for SubstanceNucleicAcid")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSubstanceNucleicAcid(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "SubstancePolymer":
		impl, ok := w.Concrete.(SubstancePolymerSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for SubstancePolymer")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSubstancePolymer(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "SubstanceProtein":
		impl, ok := w.Concrete.(SubstanceProteinSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for SubstanceProtein")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSubstanceProtein(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "SubstanceReferenceInformation":
		impl, ok := w.Concrete.(SubstanceReferenceInformationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for SubstanceReferenceInformation")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSubstanceReferenceInformation(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "SubstanceSourceMaterial":
		impl, ok := w.Concrete.(SubstanceSourceMaterialSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for SubstanceSourceMaterial")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSubstanceSourceMaterial(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "SubstanceSpecification":
		impl, ok := w.Concrete.(SubstanceSpecificationSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for SubstanceSpecification")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSubstanceSpecification(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "SupplyDelivery":
		impl, ok := w.Concrete.(SupplyDeliverySearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for SupplyDelivery")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSupplyDelivery(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "SupplyRequest":
		impl, ok := w.Concrete.(SupplyRequestSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for SupplyRequest")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchSupplyRequest(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "Task":
		impl, ok := w.Concrete.(TaskSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for Task")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchTask(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "TerminologyCapabilities":
		impl, ok := w.Concrete.(TerminologyCapabilitiesSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for TerminologyCapabilities")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchTerminologyCapabilities(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "TestReport":
		impl, ok := w.Concrete.(TestReportSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for TestReport")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchTestReport(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "TestScript":
		impl, ok := w.Concrete.(TestScriptSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for TestScript")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchTestScript(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "ValueSet":
		impl, ok := w.Concrete.(ValueSetSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for ValueSet")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchValueSet(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "VerificationResult":
		impl, ok := w.Concrete.(VerificationResultSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for VerificationResult")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchVerificationResult(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	case "VisionPrescription":
		impl, ok := w.Concrete.(VisionPrescriptionSearch)
		if !ok {
			return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("search not implemented for VisionPrescription")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		result, err := impl.SearchVisionPrescription(ctx, parameters, options)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		genericResources := make([]model.Resource, len(result.Resources))
		for i, r := range result.Resources {
			genericResources[i] = r
		}
		return search.Result[model.Resource]{

			Included:  result.Included,
			Next:      result.Next,
			Resources: genericResources,
		}, nil
	default:
		return search.Result[model.Resource]{}, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
			Code:        r4.Code{Value: ptr.To("processing")},
			Diagnostics: &r4.String{Value: ptr.To("invalid resource type: " + resourceType)},
			Severity:    r4.Code{Value: ptr.To("fatal")},
		}}}
	}
}
func (w Generic) Invoke(ctx context.Context, resourceType string, resourceID string, code string, parameters model.Parameters) (model.Resource, error) {
	crp, okCrp := parameters.(r4.ContainedResource)
	if okCrp {
		parameters = crp.Resource
	}
	typedParams, _ := parameters.(r4.Parameters)
	op, ok := w.Concrete.(capabilities.GenericOperation)
	if ok {
		return op.Invoke(ctx, resourceType, resourceID, code, parameters)
	}
	t := reflect.TypeOf(w.Concrete)
	v := reflect.ValueOf(w.Concrete)
	codeKey := strings.ToLower(code)
	matchBase := ""
	var opDef r4.OperationDefinition
	defs := operationDefinitionsByCode(ctx, w.Concrete)
	entry, found := defs[codeKey]
	if found {
		matchBase = entry.Base
		opDef = entry.Def
	}
	if !found {
		return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
			Code:        r4.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4.String{Value: ptr.To("OperationDefinition not found for code ")},
			Severity:    r4.Code{Value: ptr.To("fatal")},
		}}}
	}
	if matchBase != "" {
		if resourceType == "" && (opDef.System.Value == nil || !*opDef.System.Value) {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("operation not allowed at system level")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		if resourceType != "" && resourceID == "" && (opDef.Type.Value == nil || !*opDef.Type.Value) {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("operation not allowed at type level")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		if resourceType != "" && resourceID != "" && (opDef.Instance.Value == nil || !*opDef.Instance.Value) {
			return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
				Code:        r4.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4.String{Value: ptr.To("operation not allowed at instance level")},
				Severity:    r4.Code{Value: ptr.To("fatal")},
			}}}
		}
		if resourceType != "" {
			allowed := false
			for _, rt := range opDef.Resource {
				if rt.Value != nil && *rt.Value == resourceType {
					allowed = true
					break
				}
			}
			if (len(opDef.Resource) != 0) && !allowed {
				return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
					Code:        r4.Code{Value: ptr.To("not-supported")},
					Diagnostics: &r4.String{Value: ptr.To("operation not allowed for resource type")},
					Severity:    r4.Code{Value: ptr.To("fatal")},
				}}}
			}
		}
	}
	need := 2
	if resourceType != "" {
		need = 3
		if resourceID != "" {
			need = 4
		}
	}
	ctxT := reflect.TypeOf((*context.Context)(nil)).Elem()
	paramT := reflect.TypeOf(r4.Parameters{})
	var tryList []int
	if need == 2 {
		tryList = []int{2, 3, 4}
	} else if need == 3 {
		tryList = []int{3, 4}
	} else {
		tryList = []int{4}
	}
	for _, tryN := range tryList {
		for i := 0; i < t.NumMethod(); i++ {
			m := t.Method(i)
			name := m.Name
			if !strings.HasPrefix(name, "Invoke") {
				continue
			}
			base := strings.TrimPrefix(name, "Invoke")
			base = strings.TrimSuffix(base, "Operation")
			if base != matchBase {
				continue
			}
			mv := v.Method(i)
			mt := mv.Type()
			if mt.NumIn() != tryN {
				continue
			}
			if mt.NumOut() != 2 {
				continue
			}
			errorT := reflect.TypeOf((*error)(nil)).Elem()
			if !mt.Out(1).Implements(errorT) {
				continue
			}
			if mt.In(0) != ctxT {
				continue
			}
			if tryN == 2 {
				if mt.In(1) != paramT {
					continue
				}
			} else if tryN == 3 {
				if mt.In(1).Kind() != reflect.String {
					continue
				}
				if mt.In(2) != paramT {
					continue
				}
			} else {
				if mt.In(1).Kind() != reflect.String {
					continue
				}
				if mt.In(2).Kind() != reflect.String {
					continue
				}
				if mt.In(3) != paramT {
					continue
				}
			}
			args := []reflect.Value{reflect.ValueOf(ctx)}
			if tryN == 2 {
				args = append(args, reflect.ValueOf(typedParams))
			} else if tryN == 3 {
				args = append(args, reflect.ValueOf(resourceType))
				args = append(args, reflect.ValueOf(typedParams))
			} else {
				args = append(args, reflect.ValueOf(resourceType))
				args = append(args, reflect.ValueOf(resourceID))
				args = append(args, reflect.ValueOf(typedParams))
			}
			out := mv.Call(args)
			rv := out[0].Interface()
			errv := out[1].Interface()
			if errv != nil {
				return nil, errv.(error)
			}
			cr, ok := rv.(r4.ContainedResource)
			if ok {
				return cr.Resource, nil
			}
			res, ok := rv.(model.Resource)
			if ok {
				return res, nil
			}
		}
	}
	return nil, r4.OperationOutcome{Issue: []r4.OperationOutcomeIssue{{
		Code:        r4.Code{Value: ptr.To("not-supported")},
		Diagnostics: &r4.String{Value: ptr.To("OperationDefinition but no implementation found")},
		Severity:    r4.Code{Value: ptr.To("fatal")},
	}}}
}
