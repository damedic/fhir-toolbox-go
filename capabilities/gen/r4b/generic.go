// DO NOT EDIT!
// Code generated by "github.com/damedic/fhir-toolbox-go/internal/generate";
// use `make generate` to regenerate.

package capabilitiesR4B

import (
	"cmp"
	"context"
	"errors"
	"fmt"
	capabilities "github.com/damedic/fhir-toolbox-go/capabilities"
	search "github.com/damedic/fhir-toolbox-go/capabilities/search"
	update "github.com/damedic/fhir-toolbox-go/capabilities/update"
	fhirpath "github.com/damedic/fhir-toolbox-go/fhirpath"
	model "github.com/damedic/fhir-toolbox-go/model"
	r4b "github.com/damedic/fhir-toolbox-go/model/gen/r4b"
	ptr "github.com/damedic/fhir-toolbox-go/utils/ptr"
	"reflect"
	"slices"
	"sort"
	"strconv"
	"strings"
)

type Generic struct {
	Concrete capabilities.ConcreteCapabilities[r4b.CapabilityStatement]
}

func (w Generic) CapabilityStatement(ctx context.Context) (model.CapabilityStatement, error) {
	gen, ok := w.Concrete.(capabilities.GenericCapabilities)
	if ok {
		// shortcut for the case that the underlying implementation already implements the generic API
		return gen.CapabilityStatement(ctx)
	}
	// Generate CapabilityStatement from concrete implementation
	baseCapabilityStatement, err := w.Concrete.CapabilityBase(ctx)
	if err != nil {
		return nil, err
	}
	var baseUrl string
	if baseCapabilityStatement.Implementation == nil || baseCapabilityStatement.Implementation.Url == nil || baseCapabilityStatement.Implementation.Url.Value == nil {
		return r4b.CapabilityStatement{}, fmt.Errorf("base CapabilityStatement must have implementation.url set for canonical SearchParameter references")
	}
	baseUrl = *baseCapabilityStatement.Implementation.Url.Value
	resourcesMap := make(map[string]r4b.CapabilityStatementRestResource)
	for _, rest := range baseCapabilityStatement.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil {
				resourcesMap[*resource.Type.Value] = resource
			}
		}
	}
	var errs []error
	addInteraction := func(name string, interactionCode string) r4b.CapabilityStatementRestResource {
		r, ok := resourcesMap[name]
		if !ok {
			r = r4b.CapabilityStatementRestResource{Type: r4b.Code{Value: &name}}
		}
		r.Interaction = append(r.Interaction, r4b.CapabilityStatementRestResourceInteraction{Code: r4b.Code{Value: ptr.To(interactionCode)}})
		return r
	}
	if _, ok := w.Concrete.(AccountCreate); ok {
		resourcesMap["Account"] = addInteraction("Account", "create")
	}
	if _, ok := w.Concrete.(AccountRead); ok {
		resourcesMap["Account"] = addInteraction("Account", "read")
	}
	if _, ok := w.Concrete.(AccountDelete); ok {
		resourcesMap["Account"] = addInteraction("Account", "delete")
	}
	if c, ok := w.Concrete.(AccountUpdate); ok {
		r := addInteraction("Account", "update")
		c, ok := c.(AccountUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesAccount(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Account"] = r
	}
	if c, ok := w.Concrete.(AccountSearch); ok {
		c, err := c.SearchCapabilitiesAccount(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Account", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Account-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Account"] = r
		}
	}
	if _, ok := w.Concrete.(ActivityDefinitionCreate); ok {
		resourcesMap["ActivityDefinition"] = addInteraction("ActivityDefinition", "create")
	}
	if _, ok := w.Concrete.(ActivityDefinitionRead); ok {
		resourcesMap["ActivityDefinition"] = addInteraction("ActivityDefinition", "read")
	}
	if _, ok := w.Concrete.(ActivityDefinitionDelete); ok {
		resourcesMap["ActivityDefinition"] = addInteraction("ActivityDefinition", "delete")
	}
	if c, ok := w.Concrete.(ActivityDefinitionUpdate); ok {
		r := addInteraction("ActivityDefinition", "update")
		c, ok := c.(ActivityDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesActivityDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ActivityDefinition"] = r
	}
	if c, ok := w.Concrete.(ActivityDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesActivityDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ActivityDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ActivityDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ActivityDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(AdministrableProductDefinitionCreate); ok {
		resourcesMap["AdministrableProductDefinition"] = addInteraction("AdministrableProductDefinition", "create")
	}
	if _, ok := w.Concrete.(AdministrableProductDefinitionRead); ok {
		resourcesMap["AdministrableProductDefinition"] = addInteraction("AdministrableProductDefinition", "read")
	}
	if _, ok := w.Concrete.(AdministrableProductDefinitionDelete); ok {
		resourcesMap["AdministrableProductDefinition"] = addInteraction("AdministrableProductDefinition", "delete")
	}
	if c, ok := w.Concrete.(AdministrableProductDefinitionUpdate); ok {
		r := addInteraction("AdministrableProductDefinition", "update")
		c, ok := c.(AdministrableProductDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesAdministrableProductDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["AdministrableProductDefinition"] = r
	}
	if c, ok := w.Concrete.(AdministrableProductDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesAdministrableProductDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("AdministrableProductDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("AdministrableProductDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["AdministrableProductDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(AdverseEventCreate); ok {
		resourcesMap["AdverseEvent"] = addInteraction("AdverseEvent", "create")
	}
	if _, ok := w.Concrete.(AdverseEventRead); ok {
		resourcesMap["AdverseEvent"] = addInteraction("AdverseEvent", "read")
	}
	if _, ok := w.Concrete.(AdverseEventDelete); ok {
		resourcesMap["AdverseEvent"] = addInteraction("AdverseEvent", "delete")
	}
	if c, ok := w.Concrete.(AdverseEventUpdate); ok {
		r := addInteraction("AdverseEvent", "update")
		c, ok := c.(AdverseEventUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesAdverseEvent(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["AdverseEvent"] = r
	}
	if c, ok := w.Concrete.(AdverseEventSearch); ok {
		c, err := c.SearchCapabilitiesAdverseEvent(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("AdverseEvent", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("AdverseEvent-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["AdverseEvent"] = r
		}
	}
	if _, ok := w.Concrete.(AllergyIntoleranceCreate); ok {
		resourcesMap["AllergyIntolerance"] = addInteraction("AllergyIntolerance", "create")
	}
	if _, ok := w.Concrete.(AllergyIntoleranceRead); ok {
		resourcesMap["AllergyIntolerance"] = addInteraction("AllergyIntolerance", "read")
	}
	if _, ok := w.Concrete.(AllergyIntoleranceDelete); ok {
		resourcesMap["AllergyIntolerance"] = addInteraction("AllergyIntolerance", "delete")
	}
	if c, ok := w.Concrete.(AllergyIntoleranceUpdate); ok {
		r := addInteraction("AllergyIntolerance", "update")
		c, ok := c.(AllergyIntoleranceUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesAllergyIntolerance(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["AllergyIntolerance"] = r
	}
	if c, ok := w.Concrete.(AllergyIntoleranceSearch); ok {
		c, err := c.SearchCapabilitiesAllergyIntolerance(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("AllergyIntolerance", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("AllergyIntolerance-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["AllergyIntolerance"] = r
		}
	}
	if _, ok := w.Concrete.(AppointmentCreate); ok {
		resourcesMap["Appointment"] = addInteraction("Appointment", "create")
	}
	if _, ok := w.Concrete.(AppointmentRead); ok {
		resourcesMap["Appointment"] = addInteraction("Appointment", "read")
	}
	if _, ok := w.Concrete.(AppointmentDelete); ok {
		resourcesMap["Appointment"] = addInteraction("Appointment", "delete")
	}
	if c, ok := w.Concrete.(AppointmentUpdate); ok {
		r := addInteraction("Appointment", "update")
		c, ok := c.(AppointmentUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesAppointment(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Appointment"] = r
	}
	if c, ok := w.Concrete.(AppointmentSearch); ok {
		c, err := c.SearchCapabilitiesAppointment(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Appointment", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Appointment-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Appointment"] = r
		}
	}
	if _, ok := w.Concrete.(AppointmentResponseCreate); ok {
		resourcesMap["AppointmentResponse"] = addInteraction("AppointmentResponse", "create")
	}
	if _, ok := w.Concrete.(AppointmentResponseRead); ok {
		resourcesMap["AppointmentResponse"] = addInteraction("AppointmentResponse", "read")
	}
	if _, ok := w.Concrete.(AppointmentResponseDelete); ok {
		resourcesMap["AppointmentResponse"] = addInteraction("AppointmentResponse", "delete")
	}
	if c, ok := w.Concrete.(AppointmentResponseUpdate); ok {
		r := addInteraction("AppointmentResponse", "update")
		c, ok := c.(AppointmentResponseUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesAppointmentResponse(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["AppointmentResponse"] = r
	}
	if c, ok := w.Concrete.(AppointmentResponseSearch); ok {
		c, err := c.SearchCapabilitiesAppointmentResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("AppointmentResponse", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("AppointmentResponse-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["AppointmentResponse"] = r
		}
	}
	if _, ok := w.Concrete.(AuditEventCreate); ok {
		resourcesMap["AuditEvent"] = addInteraction("AuditEvent", "create")
	}
	if _, ok := w.Concrete.(AuditEventRead); ok {
		resourcesMap["AuditEvent"] = addInteraction("AuditEvent", "read")
	}
	if _, ok := w.Concrete.(AuditEventDelete); ok {
		resourcesMap["AuditEvent"] = addInteraction("AuditEvent", "delete")
	}
	if c, ok := w.Concrete.(AuditEventUpdate); ok {
		r := addInteraction("AuditEvent", "update")
		c, ok := c.(AuditEventUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesAuditEvent(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["AuditEvent"] = r
	}
	if c, ok := w.Concrete.(AuditEventSearch); ok {
		c, err := c.SearchCapabilitiesAuditEvent(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("AuditEvent", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("AuditEvent-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["AuditEvent"] = r
		}
	}
	if _, ok := w.Concrete.(BasicCreate); ok {
		resourcesMap["Basic"] = addInteraction("Basic", "create")
	}
	if _, ok := w.Concrete.(BasicRead); ok {
		resourcesMap["Basic"] = addInteraction("Basic", "read")
	}
	if _, ok := w.Concrete.(BasicDelete); ok {
		resourcesMap["Basic"] = addInteraction("Basic", "delete")
	}
	if c, ok := w.Concrete.(BasicUpdate); ok {
		r := addInteraction("Basic", "update")
		c, ok := c.(BasicUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesBasic(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Basic"] = r
	}
	if c, ok := w.Concrete.(BasicSearch); ok {
		c, err := c.SearchCapabilitiesBasic(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Basic", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Basic-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Basic"] = r
		}
	}
	if _, ok := w.Concrete.(BinaryCreate); ok {
		resourcesMap["Binary"] = addInteraction("Binary", "create")
	}
	if _, ok := w.Concrete.(BinaryRead); ok {
		resourcesMap["Binary"] = addInteraction("Binary", "read")
	}
	if _, ok := w.Concrete.(BinaryDelete); ok {
		resourcesMap["Binary"] = addInteraction("Binary", "delete")
	}
	if c, ok := w.Concrete.(BinaryUpdate); ok {
		r := addInteraction("Binary", "update")
		c, ok := c.(BinaryUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesBinary(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Binary"] = r
	}
	if c, ok := w.Concrete.(BinarySearch); ok {
		c, err := c.SearchCapabilitiesBinary(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Binary", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Binary-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Binary"] = r
		}
	}
	if _, ok := w.Concrete.(BiologicallyDerivedProductCreate); ok {
		resourcesMap["BiologicallyDerivedProduct"] = addInteraction("BiologicallyDerivedProduct", "create")
	}
	if _, ok := w.Concrete.(BiologicallyDerivedProductRead); ok {
		resourcesMap["BiologicallyDerivedProduct"] = addInteraction("BiologicallyDerivedProduct", "read")
	}
	if _, ok := w.Concrete.(BiologicallyDerivedProductDelete); ok {
		resourcesMap["BiologicallyDerivedProduct"] = addInteraction("BiologicallyDerivedProduct", "delete")
	}
	if c, ok := w.Concrete.(BiologicallyDerivedProductUpdate); ok {
		r := addInteraction("BiologicallyDerivedProduct", "update")
		c, ok := c.(BiologicallyDerivedProductUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesBiologicallyDerivedProduct(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["BiologicallyDerivedProduct"] = r
	}
	if c, ok := w.Concrete.(BiologicallyDerivedProductSearch); ok {
		c, err := c.SearchCapabilitiesBiologicallyDerivedProduct(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("BiologicallyDerivedProduct", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("BiologicallyDerivedProduct-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["BiologicallyDerivedProduct"] = r
		}
	}
	if _, ok := w.Concrete.(BodyStructureCreate); ok {
		resourcesMap["BodyStructure"] = addInteraction("BodyStructure", "create")
	}
	if _, ok := w.Concrete.(BodyStructureRead); ok {
		resourcesMap["BodyStructure"] = addInteraction("BodyStructure", "read")
	}
	if _, ok := w.Concrete.(BodyStructureDelete); ok {
		resourcesMap["BodyStructure"] = addInteraction("BodyStructure", "delete")
	}
	if c, ok := w.Concrete.(BodyStructureUpdate); ok {
		r := addInteraction("BodyStructure", "update")
		c, ok := c.(BodyStructureUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesBodyStructure(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["BodyStructure"] = r
	}
	if c, ok := w.Concrete.(BodyStructureSearch); ok {
		c, err := c.SearchCapabilitiesBodyStructure(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("BodyStructure", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("BodyStructure-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["BodyStructure"] = r
		}
	}
	if _, ok := w.Concrete.(BundleCreate); ok {
		resourcesMap["Bundle"] = addInteraction("Bundle", "create")
	}
	if _, ok := w.Concrete.(BundleRead); ok {
		resourcesMap["Bundle"] = addInteraction("Bundle", "read")
	}
	if _, ok := w.Concrete.(BundleDelete); ok {
		resourcesMap["Bundle"] = addInteraction("Bundle", "delete")
	}
	if c, ok := w.Concrete.(BundleUpdate); ok {
		r := addInteraction("Bundle", "update")
		c, ok := c.(BundleUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesBundle(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Bundle"] = r
	}
	if c, ok := w.Concrete.(BundleSearch); ok {
		c, err := c.SearchCapabilitiesBundle(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Bundle", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Bundle-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Bundle"] = r
		}
	}
	if _, ok := w.Concrete.(CapabilityStatementCreate); ok {
		resourcesMap["CapabilityStatement"] = addInteraction("CapabilityStatement", "create")
	}
	if _, ok := w.Concrete.(CapabilityStatementRead); ok {
		resourcesMap["CapabilityStatement"] = addInteraction("CapabilityStatement", "read")
	}
	if _, ok := w.Concrete.(CapabilityStatementDelete); ok {
		resourcesMap["CapabilityStatement"] = addInteraction("CapabilityStatement", "delete")
	}
	if c, ok := w.Concrete.(CapabilityStatementUpdate); ok {
		r := addInteraction("CapabilityStatement", "update")
		c, ok := c.(CapabilityStatementUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCapabilityStatement(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["CapabilityStatement"] = r
	}
	if c, ok := w.Concrete.(CapabilityStatementSearch); ok {
		c, err := c.SearchCapabilitiesCapabilityStatement(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("CapabilityStatement", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("CapabilityStatement-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["CapabilityStatement"] = r
		}
	}
	if _, ok := w.Concrete.(CarePlanCreate); ok {
		resourcesMap["CarePlan"] = addInteraction("CarePlan", "create")
	}
	if _, ok := w.Concrete.(CarePlanRead); ok {
		resourcesMap["CarePlan"] = addInteraction("CarePlan", "read")
	}
	if _, ok := w.Concrete.(CarePlanDelete); ok {
		resourcesMap["CarePlan"] = addInteraction("CarePlan", "delete")
	}
	if c, ok := w.Concrete.(CarePlanUpdate); ok {
		r := addInteraction("CarePlan", "update")
		c, ok := c.(CarePlanUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCarePlan(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["CarePlan"] = r
	}
	if c, ok := w.Concrete.(CarePlanSearch); ok {
		c, err := c.SearchCapabilitiesCarePlan(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("CarePlan", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("CarePlan-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["CarePlan"] = r
		}
	}
	if _, ok := w.Concrete.(CareTeamCreate); ok {
		resourcesMap["CareTeam"] = addInteraction("CareTeam", "create")
	}
	if _, ok := w.Concrete.(CareTeamRead); ok {
		resourcesMap["CareTeam"] = addInteraction("CareTeam", "read")
	}
	if _, ok := w.Concrete.(CareTeamDelete); ok {
		resourcesMap["CareTeam"] = addInteraction("CareTeam", "delete")
	}
	if c, ok := w.Concrete.(CareTeamUpdate); ok {
		r := addInteraction("CareTeam", "update")
		c, ok := c.(CareTeamUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCareTeam(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["CareTeam"] = r
	}
	if c, ok := w.Concrete.(CareTeamSearch); ok {
		c, err := c.SearchCapabilitiesCareTeam(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("CareTeam", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("CareTeam-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["CareTeam"] = r
		}
	}
	if _, ok := w.Concrete.(CatalogEntryCreate); ok {
		resourcesMap["CatalogEntry"] = addInteraction("CatalogEntry", "create")
	}
	if _, ok := w.Concrete.(CatalogEntryRead); ok {
		resourcesMap["CatalogEntry"] = addInteraction("CatalogEntry", "read")
	}
	if _, ok := w.Concrete.(CatalogEntryDelete); ok {
		resourcesMap["CatalogEntry"] = addInteraction("CatalogEntry", "delete")
	}
	if c, ok := w.Concrete.(CatalogEntryUpdate); ok {
		r := addInteraction("CatalogEntry", "update")
		c, ok := c.(CatalogEntryUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCatalogEntry(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["CatalogEntry"] = r
	}
	if c, ok := w.Concrete.(CatalogEntrySearch); ok {
		c, err := c.SearchCapabilitiesCatalogEntry(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("CatalogEntry", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("CatalogEntry-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["CatalogEntry"] = r
		}
	}
	if _, ok := w.Concrete.(ChargeItemCreate); ok {
		resourcesMap["ChargeItem"] = addInteraction("ChargeItem", "create")
	}
	if _, ok := w.Concrete.(ChargeItemRead); ok {
		resourcesMap["ChargeItem"] = addInteraction("ChargeItem", "read")
	}
	if _, ok := w.Concrete.(ChargeItemDelete); ok {
		resourcesMap["ChargeItem"] = addInteraction("ChargeItem", "delete")
	}
	if c, ok := w.Concrete.(ChargeItemUpdate); ok {
		r := addInteraction("ChargeItem", "update")
		c, ok := c.(ChargeItemUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesChargeItem(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ChargeItem"] = r
	}
	if c, ok := w.Concrete.(ChargeItemSearch); ok {
		c, err := c.SearchCapabilitiesChargeItem(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ChargeItem", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ChargeItem-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ChargeItem"] = r
		}
	}
	if _, ok := w.Concrete.(ChargeItemDefinitionCreate); ok {
		resourcesMap["ChargeItemDefinition"] = addInteraction("ChargeItemDefinition", "create")
	}
	if _, ok := w.Concrete.(ChargeItemDefinitionRead); ok {
		resourcesMap["ChargeItemDefinition"] = addInteraction("ChargeItemDefinition", "read")
	}
	if _, ok := w.Concrete.(ChargeItemDefinitionDelete); ok {
		resourcesMap["ChargeItemDefinition"] = addInteraction("ChargeItemDefinition", "delete")
	}
	if c, ok := w.Concrete.(ChargeItemDefinitionUpdate); ok {
		r := addInteraction("ChargeItemDefinition", "update")
		c, ok := c.(ChargeItemDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesChargeItemDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ChargeItemDefinition"] = r
	}
	if c, ok := w.Concrete.(ChargeItemDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesChargeItemDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ChargeItemDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ChargeItemDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ChargeItemDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(CitationCreate); ok {
		resourcesMap["Citation"] = addInteraction("Citation", "create")
	}
	if _, ok := w.Concrete.(CitationRead); ok {
		resourcesMap["Citation"] = addInteraction("Citation", "read")
	}
	if _, ok := w.Concrete.(CitationDelete); ok {
		resourcesMap["Citation"] = addInteraction("Citation", "delete")
	}
	if c, ok := w.Concrete.(CitationUpdate); ok {
		r := addInteraction("Citation", "update")
		c, ok := c.(CitationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCitation(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Citation"] = r
	}
	if c, ok := w.Concrete.(CitationSearch); ok {
		c, err := c.SearchCapabilitiesCitation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Citation", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Citation-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Citation"] = r
		}
	}
	if _, ok := w.Concrete.(ClaimCreate); ok {
		resourcesMap["Claim"] = addInteraction("Claim", "create")
	}
	if _, ok := w.Concrete.(ClaimRead); ok {
		resourcesMap["Claim"] = addInteraction("Claim", "read")
	}
	if _, ok := w.Concrete.(ClaimDelete); ok {
		resourcesMap["Claim"] = addInteraction("Claim", "delete")
	}
	if c, ok := w.Concrete.(ClaimUpdate); ok {
		r := addInteraction("Claim", "update")
		c, ok := c.(ClaimUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesClaim(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Claim"] = r
	}
	if c, ok := w.Concrete.(ClaimSearch); ok {
		c, err := c.SearchCapabilitiesClaim(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Claim", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Claim-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Claim"] = r
		}
	}
	if _, ok := w.Concrete.(ClaimResponseCreate); ok {
		resourcesMap["ClaimResponse"] = addInteraction("ClaimResponse", "create")
	}
	if _, ok := w.Concrete.(ClaimResponseRead); ok {
		resourcesMap["ClaimResponse"] = addInteraction("ClaimResponse", "read")
	}
	if _, ok := w.Concrete.(ClaimResponseDelete); ok {
		resourcesMap["ClaimResponse"] = addInteraction("ClaimResponse", "delete")
	}
	if c, ok := w.Concrete.(ClaimResponseUpdate); ok {
		r := addInteraction("ClaimResponse", "update")
		c, ok := c.(ClaimResponseUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesClaimResponse(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ClaimResponse"] = r
	}
	if c, ok := w.Concrete.(ClaimResponseSearch); ok {
		c, err := c.SearchCapabilitiesClaimResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ClaimResponse", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ClaimResponse-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ClaimResponse"] = r
		}
	}
	if _, ok := w.Concrete.(ClinicalImpressionCreate); ok {
		resourcesMap["ClinicalImpression"] = addInteraction("ClinicalImpression", "create")
	}
	if _, ok := w.Concrete.(ClinicalImpressionRead); ok {
		resourcesMap["ClinicalImpression"] = addInteraction("ClinicalImpression", "read")
	}
	if _, ok := w.Concrete.(ClinicalImpressionDelete); ok {
		resourcesMap["ClinicalImpression"] = addInteraction("ClinicalImpression", "delete")
	}
	if c, ok := w.Concrete.(ClinicalImpressionUpdate); ok {
		r := addInteraction("ClinicalImpression", "update")
		c, ok := c.(ClinicalImpressionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesClinicalImpression(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ClinicalImpression"] = r
	}
	if c, ok := w.Concrete.(ClinicalImpressionSearch); ok {
		c, err := c.SearchCapabilitiesClinicalImpression(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ClinicalImpression", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ClinicalImpression-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ClinicalImpression"] = r
		}
	}
	if _, ok := w.Concrete.(ClinicalUseDefinitionCreate); ok {
		resourcesMap["ClinicalUseDefinition"] = addInteraction("ClinicalUseDefinition", "create")
	}
	if _, ok := w.Concrete.(ClinicalUseDefinitionRead); ok {
		resourcesMap["ClinicalUseDefinition"] = addInteraction("ClinicalUseDefinition", "read")
	}
	if _, ok := w.Concrete.(ClinicalUseDefinitionDelete); ok {
		resourcesMap["ClinicalUseDefinition"] = addInteraction("ClinicalUseDefinition", "delete")
	}
	if c, ok := w.Concrete.(ClinicalUseDefinitionUpdate); ok {
		r := addInteraction("ClinicalUseDefinition", "update")
		c, ok := c.(ClinicalUseDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesClinicalUseDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ClinicalUseDefinition"] = r
	}
	if c, ok := w.Concrete.(ClinicalUseDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesClinicalUseDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ClinicalUseDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ClinicalUseDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ClinicalUseDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(CodeSystemCreate); ok {
		resourcesMap["CodeSystem"] = addInteraction("CodeSystem", "create")
	}
	if _, ok := w.Concrete.(CodeSystemRead); ok {
		resourcesMap["CodeSystem"] = addInteraction("CodeSystem", "read")
	}
	if _, ok := w.Concrete.(CodeSystemDelete); ok {
		resourcesMap["CodeSystem"] = addInteraction("CodeSystem", "delete")
	}
	if c, ok := w.Concrete.(CodeSystemUpdate); ok {
		r := addInteraction("CodeSystem", "update")
		c, ok := c.(CodeSystemUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCodeSystem(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["CodeSystem"] = r
	}
	if c, ok := w.Concrete.(CodeSystemSearch); ok {
		c, err := c.SearchCapabilitiesCodeSystem(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("CodeSystem", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("CodeSystem-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["CodeSystem"] = r
		}
	}
	if _, ok := w.Concrete.(CommunicationCreate); ok {
		resourcesMap["Communication"] = addInteraction("Communication", "create")
	}
	if _, ok := w.Concrete.(CommunicationRead); ok {
		resourcesMap["Communication"] = addInteraction("Communication", "read")
	}
	if _, ok := w.Concrete.(CommunicationDelete); ok {
		resourcesMap["Communication"] = addInteraction("Communication", "delete")
	}
	if c, ok := w.Concrete.(CommunicationUpdate); ok {
		r := addInteraction("Communication", "update")
		c, ok := c.(CommunicationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCommunication(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Communication"] = r
	}
	if c, ok := w.Concrete.(CommunicationSearch); ok {
		c, err := c.SearchCapabilitiesCommunication(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Communication", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Communication-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Communication"] = r
		}
	}
	if _, ok := w.Concrete.(CommunicationRequestCreate); ok {
		resourcesMap["CommunicationRequest"] = addInteraction("CommunicationRequest", "create")
	}
	if _, ok := w.Concrete.(CommunicationRequestRead); ok {
		resourcesMap["CommunicationRequest"] = addInteraction("CommunicationRequest", "read")
	}
	if _, ok := w.Concrete.(CommunicationRequestDelete); ok {
		resourcesMap["CommunicationRequest"] = addInteraction("CommunicationRequest", "delete")
	}
	if c, ok := w.Concrete.(CommunicationRequestUpdate); ok {
		r := addInteraction("CommunicationRequest", "update")
		c, ok := c.(CommunicationRequestUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCommunicationRequest(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["CommunicationRequest"] = r
	}
	if c, ok := w.Concrete.(CommunicationRequestSearch); ok {
		c, err := c.SearchCapabilitiesCommunicationRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("CommunicationRequest", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("CommunicationRequest-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["CommunicationRequest"] = r
		}
	}
	if _, ok := w.Concrete.(CompartmentDefinitionCreate); ok {
		resourcesMap["CompartmentDefinition"] = addInteraction("CompartmentDefinition", "create")
	}
	if _, ok := w.Concrete.(CompartmentDefinitionRead); ok {
		resourcesMap["CompartmentDefinition"] = addInteraction("CompartmentDefinition", "read")
	}
	if _, ok := w.Concrete.(CompartmentDefinitionDelete); ok {
		resourcesMap["CompartmentDefinition"] = addInteraction("CompartmentDefinition", "delete")
	}
	if c, ok := w.Concrete.(CompartmentDefinitionUpdate); ok {
		r := addInteraction("CompartmentDefinition", "update")
		c, ok := c.(CompartmentDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCompartmentDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["CompartmentDefinition"] = r
	}
	if c, ok := w.Concrete.(CompartmentDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesCompartmentDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("CompartmentDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("CompartmentDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["CompartmentDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(CompositionCreate); ok {
		resourcesMap["Composition"] = addInteraction("Composition", "create")
	}
	if _, ok := w.Concrete.(CompositionRead); ok {
		resourcesMap["Composition"] = addInteraction("Composition", "read")
	}
	if _, ok := w.Concrete.(CompositionDelete); ok {
		resourcesMap["Composition"] = addInteraction("Composition", "delete")
	}
	if c, ok := w.Concrete.(CompositionUpdate); ok {
		r := addInteraction("Composition", "update")
		c, ok := c.(CompositionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesComposition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Composition"] = r
	}
	if c, ok := w.Concrete.(CompositionSearch); ok {
		c, err := c.SearchCapabilitiesComposition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Composition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Composition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Composition"] = r
		}
	}
	if _, ok := w.Concrete.(ConceptMapCreate); ok {
		resourcesMap["ConceptMap"] = addInteraction("ConceptMap", "create")
	}
	if _, ok := w.Concrete.(ConceptMapRead); ok {
		resourcesMap["ConceptMap"] = addInteraction("ConceptMap", "read")
	}
	if _, ok := w.Concrete.(ConceptMapDelete); ok {
		resourcesMap["ConceptMap"] = addInteraction("ConceptMap", "delete")
	}
	if c, ok := w.Concrete.(ConceptMapUpdate); ok {
		r := addInteraction("ConceptMap", "update")
		c, ok := c.(ConceptMapUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesConceptMap(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ConceptMap"] = r
	}
	if c, ok := w.Concrete.(ConceptMapSearch); ok {
		c, err := c.SearchCapabilitiesConceptMap(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ConceptMap", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ConceptMap-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ConceptMap"] = r
		}
	}
	if _, ok := w.Concrete.(ConditionCreate); ok {
		resourcesMap["Condition"] = addInteraction("Condition", "create")
	}
	if _, ok := w.Concrete.(ConditionRead); ok {
		resourcesMap["Condition"] = addInteraction("Condition", "read")
	}
	if _, ok := w.Concrete.(ConditionDelete); ok {
		resourcesMap["Condition"] = addInteraction("Condition", "delete")
	}
	if c, ok := w.Concrete.(ConditionUpdate); ok {
		r := addInteraction("Condition", "update")
		c, ok := c.(ConditionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCondition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Condition"] = r
	}
	if c, ok := w.Concrete.(ConditionSearch); ok {
		c, err := c.SearchCapabilitiesCondition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Condition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Condition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Condition"] = r
		}
	}
	if _, ok := w.Concrete.(ConsentCreate); ok {
		resourcesMap["Consent"] = addInteraction("Consent", "create")
	}
	if _, ok := w.Concrete.(ConsentRead); ok {
		resourcesMap["Consent"] = addInteraction("Consent", "read")
	}
	if _, ok := w.Concrete.(ConsentDelete); ok {
		resourcesMap["Consent"] = addInteraction("Consent", "delete")
	}
	if c, ok := w.Concrete.(ConsentUpdate); ok {
		r := addInteraction("Consent", "update")
		c, ok := c.(ConsentUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesConsent(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Consent"] = r
	}
	if c, ok := w.Concrete.(ConsentSearch); ok {
		c, err := c.SearchCapabilitiesConsent(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Consent", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Consent-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Consent"] = r
		}
	}
	if _, ok := w.Concrete.(ContractCreate); ok {
		resourcesMap["Contract"] = addInteraction("Contract", "create")
	}
	if _, ok := w.Concrete.(ContractRead); ok {
		resourcesMap["Contract"] = addInteraction("Contract", "read")
	}
	if _, ok := w.Concrete.(ContractDelete); ok {
		resourcesMap["Contract"] = addInteraction("Contract", "delete")
	}
	if c, ok := w.Concrete.(ContractUpdate); ok {
		r := addInteraction("Contract", "update")
		c, ok := c.(ContractUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesContract(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Contract"] = r
	}
	if c, ok := w.Concrete.(ContractSearch); ok {
		c, err := c.SearchCapabilitiesContract(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Contract", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Contract-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Contract"] = r
		}
	}
	if _, ok := w.Concrete.(CoverageCreate); ok {
		resourcesMap["Coverage"] = addInteraction("Coverage", "create")
	}
	if _, ok := w.Concrete.(CoverageRead); ok {
		resourcesMap["Coverage"] = addInteraction("Coverage", "read")
	}
	if _, ok := w.Concrete.(CoverageDelete); ok {
		resourcesMap["Coverage"] = addInteraction("Coverage", "delete")
	}
	if c, ok := w.Concrete.(CoverageUpdate); ok {
		r := addInteraction("Coverage", "update")
		c, ok := c.(CoverageUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCoverage(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Coverage"] = r
	}
	if c, ok := w.Concrete.(CoverageSearch); ok {
		c, err := c.SearchCapabilitiesCoverage(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Coverage", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Coverage-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Coverage"] = r
		}
	}
	if _, ok := w.Concrete.(CoverageEligibilityRequestCreate); ok {
		resourcesMap["CoverageEligibilityRequest"] = addInteraction("CoverageEligibilityRequest", "create")
	}
	if _, ok := w.Concrete.(CoverageEligibilityRequestRead); ok {
		resourcesMap["CoverageEligibilityRequest"] = addInteraction("CoverageEligibilityRequest", "read")
	}
	if _, ok := w.Concrete.(CoverageEligibilityRequestDelete); ok {
		resourcesMap["CoverageEligibilityRequest"] = addInteraction("CoverageEligibilityRequest", "delete")
	}
	if c, ok := w.Concrete.(CoverageEligibilityRequestUpdate); ok {
		r := addInteraction("CoverageEligibilityRequest", "update")
		c, ok := c.(CoverageEligibilityRequestUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCoverageEligibilityRequest(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["CoverageEligibilityRequest"] = r
	}
	if c, ok := w.Concrete.(CoverageEligibilityRequestSearch); ok {
		c, err := c.SearchCapabilitiesCoverageEligibilityRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("CoverageEligibilityRequest", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("CoverageEligibilityRequest-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["CoverageEligibilityRequest"] = r
		}
	}
	if _, ok := w.Concrete.(CoverageEligibilityResponseCreate); ok {
		resourcesMap["CoverageEligibilityResponse"] = addInteraction("CoverageEligibilityResponse", "create")
	}
	if _, ok := w.Concrete.(CoverageEligibilityResponseRead); ok {
		resourcesMap["CoverageEligibilityResponse"] = addInteraction("CoverageEligibilityResponse", "read")
	}
	if _, ok := w.Concrete.(CoverageEligibilityResponseDelete); ok {
		resourcesMap["CoverageEligibilityResponse"] = addInteraction("CoverageEligibilityResponse", "delete")
	}
	if c, ok := w.Concrete.(CoverageEligibilityResponseUpdate); ok {
		r := addInteraction("CoverageEligibilityResponse", "update")
		c, ok := c.(CoverageEligibilityResponseUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesCoverageEligibilityResponse(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["CoverageEligibilityResponse"] = r
	}
	if c, ok := w.Concrete.(CoverageEligibilityResponseSearch); ok {
		c, err := c.SearchCapabilitiesCoverageEligibilityResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("CoverageEligibilityResponse", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("CoverageEligibilityResponse-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["CoverageEligibilityResponse"] = r
		}
	}
	if _, ok := w.Concrete.(DetectedIssueCreate); ok {
		resourcesMap["DetectedIssue"] = addInteraction("DetectedIssue", "create")
	}
	if _, ok := w.Concrete.(DetectedIssueRead); ok {
		resourcesMap["DetectedIssue"] = addInteraction("DetectedIssue", "read")
	}
	if _, ok := w.Concrete.(DetectedIssueDelete); ok {
		resourcesMap["DetectedIssue"] = addInteraction("DetectedIssue", "delete")
	}
	if c, ok := w.Concrete.(DetectedIssueUpdate); ok {
		r := addInteraction("DetectedIssue", "update")
		c, ok := c.(DetectedIssueUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDetectedIssue(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["DetectedIssue"] = r
	}
	if c, ok := w.Concrete.(DetectedIssueSearch); ok {
		c, err := c.SearchCapabilitiesDetectedIssue(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("DetectedIssue", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("DetectedIssue-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["DetectedIssue"] = r
		}
	}
	if _, ok := w.Concrete.(DeviceCreate); ok {
		resourcesMap["Device"] = addInteraction("Device", "create")
	}
	if _, ok := w.Concrete.(DeviceRead); ok {
		resourcesMap["Device"] = addInteraction("Device", "read")
	}
	if _, ok := w.Concrete.(DeviceDelete); ok {
		resourcesMap["Device"] = addInteraction("Device", "delete")
	}
	if c, ok := w.Concrete.(DeviceUpdate); ok {
		r := addInteraction("Device", "update")
		c, ok := c.(DeviceUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDevice(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Device"] = r
	}
	if c, ok := w.Concrete.(DeviceSearch); ok {
		c, err := c.SearchCapabilitiesDevice(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Device", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Device-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Device"] = r
		}
	}
	if _, ok := w.Concrete.(DeviceDefinitionCreate); ok {
		resourcesMap["DeviceDefinition"] = addInteraction("DeviceDefinition", "create")
	}
	if _, ok := w.Concrete.(DeviceDefinitionRead); ok {
		resourcesMap["DeviceDefinition"] = addInteraction("DeviceDefinition", "read")
	}
	if _, ok := w.Concrete.(DeviceDefinitionDelete); ok {
		resourcesMap["DeviceDefinition"] = addInteraction("DeviceDefinition", "delete")
	}
	if c, ok := w.Concrete.(DeviceDefinitionUpdate); ok {
		r := addInteraction("DeviceDefinition", "update")
		c, ok := c.(DeviceDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDeviceDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["DeviceDefinition"] = r
	}
	if c, ok := w.Concrete.(DeviceDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesDeviceDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("DeviceDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("DeviceDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["DeviceDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(DeviceMetricCreate); ok {
		resourcesMap["DeviceMetric"] = addInteraction("DeviceMetric", "create")
	}
	if _, ok := w.Concrete.(DeviceMetricRead); ok {
		resourcesMap["DeviceMetric"] = addInteraction("DeviceMetric", "read")
	}
	if _, ok := w.Concrete.(DeviceMetricDelete); ok {
		resourcesMap["DeviceMetric"] = addInteraction("DeviceMetric", "delete")
	}
	if c, ok := w.Concrete.(DeviceMetricUpdate); ok {
		r := addInteraction("DeviceMetric", "update")
		c, ok := c.(DeviceMetricUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDeviceMetric(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["DeviceMetric"] = r
	}
	if c, ok := w.Concrete.(DeviceMetricSearch); ok {
		c, err := c.SearchCapabilitiesDeviceMetric(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("DeviceMetric", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("DeviceMetric-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["DeviceMetric"] = r
		}
	}
	if _, ok := w.Concrete.(DeviceRequestCreate); ok {
		resourcesMap["DeviceRequest"] = addInteraction("DeviceRequest", "create")
	}
	if _, ok := w.Concrete.(DeviceRequestRead); ok {
		resourcesMap["DeviceRequest"] = addInteraction("DeviceRequest", "read")
	}
	if _, ok := w.Concrete.(DeviceRequestDelete); ok {
		resourcesMap["DeviceRequest"] = addInteraction("DeviceRequest", "delete")
	}
	if c, ok := w.Concrete.(DeviceRequestUpdate); ok {
		r := addInteraction("DeviceRequest", "update")
		c, ok := c.(DeviceRequestUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDeviceRequest(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["DeviceRequest"] = r
	}
	if c, ok := w.Concrete.(DeviceRequestSearch); ok {
		c, err := c.SearchCapabilitiesDeviceRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("DeviceRequest", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("DeviceRequest-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["DeviceRequest"] = r
		}
	}
	if _, ok := w.Concrete.(DeviceUseStatementCreate); ok {
		resourcesMap["DeviceUseStatement"] = addInteraction("DeviceUseStatement", "create")
	}
	if _, ok := w.Concrete.(DeviceUseStatementRead); ok {
		resourcesMap["DeviceUseStatement"] = addInteraction("DeviceUseStatement", "read")
	}
	if _, ok := w.Concrete.(DeviceUseStatementDelete); ok {
		resourcesMap["DeviceUseStatement"] = addInteraction("DeviceUseStatement", "delete")
	}
	if c, ok := w.Concrete.(DeviceUseStatementUpdate); ok {
		r := addInteraction("DeviceUseStatement", "update")
		c, ok := c.(DeviceUseStatementUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDeviceUseStatement(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["DeviceUseStatement"] = r
	}
	if c, ok := w.Concrete.(DeviceUseStatementSearch); ok {
		c, err := c.SearchCapabilitiesDeviceUseStatement(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("DeviceUseStatement", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("DeviceUseStatement-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["DeviceUseStatement"] = r
		}
	}
	if _, ok := w.Concrete.(DiagnosticReportCreate); ok {
		resourcesMap["DiagnosticReport"] = addInteraction("DiagnosticReport", "create")
	}
	if _, ok := w.Concrete.(DiagnosticReportRead); ok {
		resourcesMap["DiagnosticReport"] = addInteraction("DiagnosticReport", "read")
	}
	if _, ok := w.Concrete.(DiagnosticReportDelete); ok {
		resourcesMap["DiagnosticReport"] = addInteraction("DiagnosticReport", "delete")
	}
	if c, ok := w.Concrete.(DiagnosticReportUpdate); ok {
		r := addInteraction("DiagnosticReport", "update")
		c, ok := c.(DiagnosticReportUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDiagnosticReport(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["DiagnosticReport"] = r
	}
	if c, ok := w.Concrete.(DiagnosticReportSearch); ok {
		c, err := c.SearchCapabilitiesDiagnosticReport(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("DiagnosticReport", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("DiagnosticReport-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["DiagnosticReport"] = r
		}
	}
	if _, ok := w.Concrete.(DocumentManifestCreate); ok {
		resourcesMap["DocumentManifest"] = addInteraction("DocumentManifest", "create")
	}
	if _, ok := w.Concrete.(DocumentManifestRead); ok {
		resourcesMap["DocumentManifest"] = addInteraction("DocumentManifest", "read")
	}
	if _, ok := w.Concrete.(DocumentManifestDelete); ok {
		resourcesMap["DocumentManifest"] = addInteraction("DocumentManifest", "delete")
	}
	if c, ok := w.Concrete.(DocumentManifestUpdate); ok {
		r := addInteraction("DocumentManifest", "update")
		c, ok := c.(DocumentManifestUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDocumentManifest(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["DocumentManifest"] = r
	}
	if c, ok := w.Concrete.(DocumentManifestSearch); ok {
		c, err := c.SearchCapabilitiesDocumentManifest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("DocumentManifest", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("DocumentManifest-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["DocumentManifest"] = r
		}
	}
	if _, ok := w.Concrete.(DocumentReferenceCreate); ok {
		resourcesMap["DocumentReference"] = addInteraction("DocumentReference", "create")
	}
	if _, ok := w.Concrete.(DocumentReferenceRead); ok {
		resourcesMap["DocumentReference"] = addInteraction("DocumentReference", "read")
	}
	if _, ok := w.Concrete.(DocumentReferenceDelete); ok {
		resourcesMap["DocumentReference"] = addInteraction("DocumentReference", "delete")
	}
	if c, ok := w.Concrete.(DocumentReferenceUpdate); ok {
		r := addInteraction("DocumentReference", "update")
		c, ok := c.(DocumentReferenceUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesDocumentReference(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["DocumentReference"] = r
	}
	if c, ok := w.Concrete.(DocumentReferenceSearch); ok {
		c, err := c.SearchCapabilitiesDocumentReference(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("DocumentReference", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("DocumentReference-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["DocumentReference"] = r
		}
	}
	if _, ok := w.Concrete.(EncounterCreate); ok {
		resourcesMap["Encounter"] = addInteraction("Encounter", "create")
	}
	if _, ok := w.Concrete.(EncounterRead); ok {
		resourcesMap["Encounter"] = addInteraction("Encounter", "read")
	}
	if _, ok := w.Concrete.(EncounterDelete); ok {
		resourcesMap["Encounter"] = addInteraction("Encounter", "delete")
	}
	if c, ok := w.Concrete.(EncounterUpdate); ok {
		r := addInteraction("Encounter", "update")
		c, ok := c.(EncounterUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEncounter(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Encounter"] = r
	}
	if c, ok := w.Concrete.(EncounterSearch); ok {
		c, err := c.SearchCapabilitiesEncounter(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Encounter", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Encounter-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Encounter"] = r
		}
	}
	if _, ok := w.Concrete.(EndpointCreate); ok {
		resourcesMap["Endpoint"] = addInteraction("Endpoint", "create")
	}
	if _, ok := w.Concrete.(EndpointRead); ok {
		resourcesMap["Endpoint"] = addInteraction("Endpoint", "read")
	}
	if _, ok := w.Concrete.(EndpointDelete); ok {
		resourcesMap["Endpoint"] = addInteraction("Endpoint", "delete")
	}
	if c, ok := w.Concrete.(EndpointUpdate); ok {
		r := addInteraction("Endpoint", "update")
		c, ok := c.(EndpointUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEndpoint(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Endpoint"] = r
	}
	if c, ok := w.Concrete.(EndpointSearch); ok {
		c, err := c.SearchCapabilitiesEndpoint(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Endpoint", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Endpoint-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Endpoint"] = r
		}
	}
	if _, ok := w.Concrete.(EnrollmentRequestCreate); ok {
		resourcesMap["EnrollmentRequest"] = addInteraction("EnrollmentRequest", "create")
	}
	if _, ok := w.Concrete.(EnrollmentRequestRead); ok {
		resourcesMap["EnrollmentRequest"] = addInteraction("EnrollmentRequest", "read")
	}
	if _, ok := w.Concrete.(EnrollmentRequestDelete); ok {
		resourcesMap["EnrollmentRequest"] = addInteraction("EnrollmentRequest", "delete")
	}
	if c, ok := w.Concrete.(EnrollmentRequestUpdate); ok {
		r := addInteraction("EnrollmentRequest", "update")
		c, ok := c.(EnrollmentRequestUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEnrollmentRequest(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["EnrollmentRequest"] = r
	}
	if c, ok := w.Concrete.(EnrollmentRequestSearch); ok {
		c, err := c.SearchCapabilitiesEnrollmentRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("EnrollmentRequest", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("EnrollmentRequest-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["EnrollmentRequest"] = r
		}
	}
	if _, ok := w.Concrete.(EnrollmentResponseCreate); ok {
		resourcesMap["EnrollmentResponse"] = addInteraction("EnrollmentResponse", "create")
	}
	if _, ok := w.Concrete.(EnrollmentResponseRead); ok {
		resourcesMap["EnrollmentResponse"] = addInteraction("EnrollmentResponse", "read")
	}
	if _, ok := w.Concrete.(EnrollmentResponseDelete); ok {
		resourcesMap["EnrollmentResponse"] = addInteraction("EnrollmentResponse", "delete")
	}
	if c, ok := w.Concrete.(EnrollmentResponseUpdate); ok {
		r := addInteraction("EnrollmentResponse", "update")
		c, ok := c.(EnrollmentResponseUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEnrollmentResponse(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["EnrollmentResponse"] = r
	}
	if c, ok := w.Concrete.(EnrollmentResponseSearch); ok {
		c, err := c.SearchCapabilitiesEnrollmentResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("EnrollmentResponse", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("EnrollmentResponse-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["EnrollmentResponse"] = r
		}
	}
	if _, ok := w.Concrete.(EpisodeOfCareCreate); ok {
		resourcesMap["EpisodeOfCare"] = addInteraction("EpisodeOfCare", "create")
	}
	if _, ok := w.Concrete.(EpisodeOfCareRead); ok {
		resourcesMap["EpisodeOfCare"] = addInteraction("EpisodeOfCare", "read")
	}
	if _, ok := w.Concrete.(EpisodeOfCareDelete); ok {
		resourcesMap["EpisodeOfCare"] = addInteraction("EpisodeOfCare", "delete")
	}
	if c, ok := w.Concrete.(EpisodeOfCareUpdate); ok {
		r := addInteraction("EpisodeOfCare", "update")
		c, ok := c.(EpisodeOfCareUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEpisodeOfCare(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["EpisodeOfCare"] = r
	}
	if c, ok := w.Concrete.(EpisodeOfCareSearch); ok {
		c, err := c.SearchCapabilitiesEpisodeOfCare(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("EpisodeOfCare", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("EpisodeOfCare-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["EpisodeOfCare"] = r
		}
	}
	if _, ok := w.Concrete.(EventDefinitionCreate); ok {
		resourcesMap["EventDefinition"] = addInteraction("EventDefinition", "create")
	}
	if _, ok := w.Concrete.(EventDefinitionRead); ok {
		resourcesMap["EventDefinition"] = addInteraction("EventDefinition", "read")
	}
	if _, ok := w.Concrete.(EventDefinitionDelete); ok {
		resourcesMap["EventDefinition"] = addInteraction("EventDefinition", "delete")
	}
	if c, ok := w.Concrete.(EventDefinitionUpdate); ok {
		r := addInteraction("EventDefinition", "update")
		c, ok := c.(EventDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEventDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["EventDefinition"] = r
	}
	if c, ok := w.Concrete.(EventDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesEventDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("EventDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("EventDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["EventDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(EvidenceCreate); ok {
		resourcesMap["Evidence"] = addInteraction("Evidence", "create")
	}
	if _, ok := w.Concrete.(EvidenceRead); ok {
		resourcesMap["Evidence"] = addInteraction("Evidence", "read")
	}
	if _, ok := w.Concrete.(EvidenceDelete); ok {
		resourcesMap["Evidence"] = addInteraction("Evidence", "delete")
	}
	if c, ok := w.Concrete.(EvidenceUpdate); ok {
		r := addInteraction("Evidence", "update")
		c, ok := c.(EvidenceUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEvidence(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Evidence"] = r
	}
	if c, ok := w.Concrete.(EvidenceSearch); ok {
		c, err := c.SearchCapabilitiesEvidence(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Evidence", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Evidence-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Evidence"] = r
		}
	}
	if _, ok := w.Concrete.(EvidenceReportCreate); ok {
		resourcesMap["EvidenceReport"] = addInteraction("EvidenceReport", "create")
	}
	if _, ok := w.Concrete.(EvidenceReportRead); ok {
		resourcesMap["EvidenceReport"] = addInteraction("EvidenceReport", "read")
	}
	if _, ok := w.Concrete.(EvidenceReportDelete); ok {
		resourcesMap["EvidenceReport"] = addInteraction("EvidenceReport", "delete")
	}
	if c, ok := w.Concrete.(EvidenceReportUpdate); ok {
		r := addInteraction("EvidenceReport", "update")
		c, ok := c.(EvidenceReportUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEvidenceReport(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["EvidenceReport"] = r
	}
	if c, ok := w.Concrete.(EvidenceReportSearch); ok {
		c, err := c.SearchCapabilitiesEvidenceReport(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("EvidenceReport", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("EvidenceReport-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["EvidenceReport"] = r
		}
	}
	if _, ok := w.Concrete.(EvidenceVariableCreate); ok {
		resourcesMap["EvidenceVariable"] = addInteraction("EvidenceVariable", "create")
	}
	if _, ok := w.Concrete.(EvidenceVariableRead); ok {
		resourcesMap["EvidenceVariable"] = addInteraction("EvidenceVariable", "read")
	}
	if _, ok := w.Concrete.(EvidenceVariableDelete); ok {
		resourcesMap["EvidenceVariable"] = addInteraction("EvidenceVariable", "delete")
	}
	if c, ok := w.Concrete.(EvidenceVariableUpdate); ok {
		r := addInteraction("EvidenceVariable", "update")
		c, ok := c.(EvidenceVariableUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesEvidenceVariable(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["EvidenceVariable"] = r
	}
	if c, ok := w.Concrete.(EvidenceVariableSearch); ok {
		c, err := c.SearchCapabilitiesEvidenceVariable(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("EvidenceVariable", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("EvidenceVariable-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["EvidenceVariable"] = r
		}
	}
	if _, ok := w.Concrete.(ExampleScenarioCreate); ok {
		resourcesMap["ExampleScenario"] = addInteraction("ExampleScenario", "create")
	}
	if _, ok := w.Concrete.(ExampleScenarioRead); ok {
		resourcesMap["ExampleScenario"] = addInteraction("ExampleScenario", "read")
	}
	if _, ok := w.Concrete.(ExampleScenarioDelete); ok {
		resourcesMap["ExampleScenario"] = addInteraction("ExampleScenario", "delete")
	}
	if c, ok := w.Concrete.(ExampleScenarioUpdate); ok {
		r := addInteraction("ExampleScenario", "update")
		c, ok := c.(ExampleScenarioUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesExampleScenario(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ExampleScenario"] = r
	}
	if c, ok := w.Concrete.(ExampleScenarioSearch); ok {
		c, err := c.SearchCapabilitiesExampleScenario(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ExampleScenario", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ExampleScenario-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ExampleScenario"] = r
		}
	}
	if _, ok := w.Concrete.(ExplanationOfBenefitCreate); ok {
		resourcesMap["ExplanationOfBenefit"] = addInteraction("ExplanationOfBenefit", "create")
	}
	if _, ok := w.Concrete.(ExplanationOfBenefitRead); ok {
		resourcesMap["ExplanationOfBenefit"] = addInteraction("ExplanationOfBenefit", "read")
	}
	if _, ok := w.Concrete.(ExplanationOfBenefitDelete); ok {
		resourcesMap["ExplanationOfBenefit"] = addInteraction("ExplanationOfBenefit", "delete")
	}
	if c, ok := w.Concrete.(ExplanationOfBenefitUpdate); ok {
		r := addInteraction("ExplanationOfBenefit", "update")
		c, ok := c.(ExplanationOfBenefitUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesExplanationOfBenefit(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ExplanationOfBenefit"] = r
	}
	if c, ok := w.Concrete.(ExplanationOfBenefitSearch); ok {
		c, err := c.SearchCapabilitiesExplanationOfBenefit(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ExplanationOfBenefit", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ExplanationOfBenefit-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ExplanationOfBenefit"] = r
		}
	}
	if _, ok := w.Concrete.(FamilyMemberHistoryCreate); ok {
		resourcesMap["FamilyMemberHistory"] = addInteraction("FamilyMemberHistory", "create")
	}
	if _, ok := w.Concrete.(FamilyMemberHistoryRead); ok {
		resourcesMap["FamilyMemberHistory"] = addInteraction("FamilyMemberHistory", "read")
	}
	if _, ok := w.Concrete.(FamilyMemberHistoryDelete); ok {
		resourcesMap["FamilyMemberHistory"] = addInteraction("FamilyMemberHistory", "delete")
	}
	if c, ok := w.Concrete.(FamilyMemberHistoryUpdate); ok {
		r := addInteraction("FamilyMemberHistory", "update")
		c, ok := c.(FamilyMemberHistoryUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesFamilyMemberHistory(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["FamilyMemberHistory"] = r
	}
	if c, ok := w.Concrete.(FamilyMemberHistorySearch); ok {
		c, err := c.SearchCapabilitiesFamilyMemberHistory(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("FamilyMemberHistory", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("FamilyMemberHistory-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["FamilyMemberHistory"] = r
		}
	}
	if _, ok := w.Concrete.(FlagCreate); ok {
		resourcesMap["Flag"] = addInteraction("Flag", "create")
	}
	if _, ok := w.Concrete.(FlagRead); ok {
		resourcesMap["Flag"] = addInteraction("Flag", "read")
	}
	if _, ok := w.Concrete.(FlagDelete); ok {
		resourcesMap["Flag"] = addInteraction("Flag", "delete")
	}
	if c, ok := w.Concrete.(FlagUpdate); ok {
		r := addInteraction("Flag", "update")
		c, ok := c.(FlagUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesFlag(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Flag"] = r
	}
	if c, ok := w.Concrete.(FlagSearch); ok {
		c, err := c.SearchCapabilitiesFlag(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Flag", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Flag-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Flag"] = r
		}
	}
	if _, ok := w.Concrete.(GoalCreate); ok {
		resourcesMap["Goal"] = addInteraction("Goal", "create")
	}
	if _, ok := w.Concrete.(GoalRead); ok {
		resourcesMap["Goal"] = addInteraction("Goal", "read")
	}
	if _, ok := w.Concrete.(GoalDelete); ok {
		resourcesMap["Goal"] = addInteraction("Goal", "delete")
	}
	if c, ok := w.Concrete.(GoalUpdate); ok {
		r := addInteraction("Goal", "update")
		c, ok := c.(GoalUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesGoal(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Goal"] = r
	}
	if c, ok := w.Concrete.(GoalSearch); ok {
		c, err := c.SearchCapabilitiesGoal(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Goal", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Goal-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Goal"] = r
		}
	}
	if _, ok := w.Concrete.(GraphDefinitionCreate); ok {
		resourcesMap["GraphDefinition"] = addInteraction("GraphDefinition", "create")
	}
	if _, ok := w.Concrete.(GraphDefinitionRead); ok {
		resourcesMap["GraphDefinition"] = addInteraction("GraphDefinition", "read")
	}
	if _, ok := w.Concrete.(GraphDefinitionDelete); ok {
		resourcesMap["GraphDefinition"] = addInteraction("GraphDefinition", "delete")
	}
	if c, ok := w.Concrete.(GraphDefinitionUpdate); ok {
		r := addInteraction("GraphDefinition", "update")
		c, ok := c.(GraphDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesGraphDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["GraphDefinition"] = r
	}
	if c, ok := w.Concrete.(GraphDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesGraphDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("GraphDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("GraphDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["GraphDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(GroupCreate); ok {
		resourcesMap["Group"] = addInteraction("Group", "create")
	}
	if _, ok := w.Concrete.(GroupRead); ok {
		resourcesMap["Group"] = addInteraction("Group", "read")
	}
	if _, ok := w.Concrete.(GroupDelete); ok {
		resourcesMap["Group"] = addInteraction("Group", "delete")
	}
	if c, ok := w.Concrete.(GroupUpdate); ok {
		r := addInteraction("Group", "update")
		c, ok := c.(GroupUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesGroup(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Group"] = r
	}
	if c, ok := w.Concrete.(GroupSearch); ok {
		c, err := c.SearchCapabilitiesGroup(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Group", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Group-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Group"] = r
		}
	}
	if _, ok := w.Concrete.(GuidanceResponseCreate); ok {
		resourcesMap["GuidanceResponse"] = addInteraction("GuidanceResponse", "create")
	}
	if _, ok := w.Concrete.(GuidanceResponseRead); ok {
		resourcesMap["GuidanceResponse"] = addInteraction("GuidanceResponse", "read")
	}
	if _, ok := w.Concrete.(GuidanceResponseDelete); ok {
		resourcesMap["GuidanceResponse"] = addInteraction("GuidanceResponse", "delete")
	}
	if c, ok := w.Concrete.(GuidanceResponseUpdate); ok {
		r := addInteraction("GuidanceResponse", "update")
		c, ok := c.(GuidanceResponseUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesGuidanceResponse(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["GuidanceResponse"] = r
	}
	if c, ok := w.Concrete.(GuidanceResponseSearch); ok {
		c, err := c.SearchCapabilitiesGuidanceResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("GuidanceResponse", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("GuidanceResponse-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["GuidanceResponse"] = r
		}
	}
	if _, ok := w.Concrete.(HealthcareServiceCreate); ok {
		resourcesMap["HealthcareService"] = addInteraction("HealthcareService", "create")
	}
	if _, ok := w.Concrete.(HealthcareServiceRead); ok {
		resourcesMap["HealthcareService"] = addInteraction("HealthcareService", "read")
	}
	if _, ok := w.Concrete.(HealthcareServiceDelete); ok {
		resourcesMap["HealthcareService"] = addInteraction("HealthcareService", "delete")
	}
	if c, ok := w.Concrete.(HealthcareServiceUpdate); ok {
		r := addInteraction("HealthcareService", "update")
		c, ok := c.(HealthcareServiceUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesHealthcareService(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["HealthcareService"] = r
	}
	if c, ok := w.Concrete.(HealthcareServiceSearch); ok {
		c, err := c.SearchCapabilitiesHealthcareService(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("HealthcareService", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("HealthcareService-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["HealthcareService"] = r
		}
	}
	if _, ok := w.Concrete.(ImagingStudyCreate); ok {
		resourcesMap["ImagingStudy"] = addInteraction("ImagingStudy", "create")
	}
	if _, ok := w.Concrete.(ImagingStudyRead); ok {
		resourcesMap["ImagingStudy"] = addInteraction("ImagingStudy", "read")
	}
	if _, ok := w.Concrete.(ImagingStudyDelete); ok {
		resourcesMap["ImagingStudy"] = addInteraction("ImagingStudy", "delete")
	}
	if c, ok := w.Concrete.(ImagingStudyUpdate); ok {
		r := addInteraction("ImagingStudy", "update")
		c, ok := c.(ImagingStudyUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesImagingStudy(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ImagingStudy"] = r
	}
	if c, ok := w.Concrete.(ImagingStudySearch); ok {
		c, err := c.SearchCapabilitiesImagingStudy(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ImagingStudy", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ImagingStudy-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ImagingStudy"] = r
		}
	}
	if _, ok := w.Concrete.(ImmunizationCreate); ok {
		resourcesMap["Immunization"] = addInteraction("Immunization", "create")
	}
	if _, ok := w.Concrete.(ImmunizationRead); ok {
		resourcesMap["Immunization"] = addInteraction("Immunization", "read")
	}
	if _, ok := w.Concrete.(ImmunizationDelete); ok {
		resourcesMap["Immunization"] = addInteraction("Immunization", "delete")
	}
	if c, ok := w.Concrete.(ImmunizationUpdate); ok {
		r := addInteraction("Immunization", "update")
		c, ok := c.(ImmunizationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesImmunization(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Immunization"] = r
	}
	if c, ok := w.Concrete.(ImmunizationSearch); ok {
		c, err := c.SearchCapabilitiesImmunization(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Immunization", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Immunization-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Immunization"] = r
		}
	}
	if _, ok := w.Concrete.(ImmunizationEvaluationCreate); ok {
		resourcesMap["ImmunizationEvaluation"] = addInteraction("ImmunizationEvaluation", "create")
	}
	if _, ok := w.Concrete.(ImmunizationEvaluationRead); ok {
		resourcesMap["ImmunizationEvaluation"] = addInteraction("ImmunizationEvaluation", "read")
	}
	if _, ok := w.Concrete.(ImmunizationEvaluationDelete); ok {
		resourcesMap["ImmunizationEvaluation"] = addInteraction("ImmunizationEvaluation", "delete")
	}
	if c, ok := w.Concrete.(ImmunizationEvaluationUpdate); ok {
		r := addInteraction("ImmunizationEvaluation", "update")
		c, ok := c.(ImmunizationEvaluationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesImmunizationEvaluation(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ImmunizationEvaluation"] = r
	}
	if c, ok := w.Concrete.(ImmunizationEvaluationSearch); ok {
		c, err := c.SearchCapabilitiesImmunizationEvaluation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ImmunizationEvaluation", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ImmunizationEvaluation-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ImmunizationEvaluation"] = r
		}
	}
	if _, ok := w.Concrete.(ImmunizationRecommendationCreate); ok {
		resourcesMap["ImmunizationRecommendation"] = addInteraction("ImmunizationRecommendation", "create")
	}
	if _, ok := w.Concrete.(ImmunizationRecommendationRead); ok {
		resourcesMap["ImmunizationRecommendation"] = addInteraction("ImmunizationRecommendation", "read")
	}
	if _, ok := w.Concrete.(ImmunizationRecommendationDelete); ok {
		resourcesMap["ImmunizationRecommendation"] = addInteraction("ImmunizationRecommendation", "delete")
	}
	if c, ok := w.Concrete.(ImmunizationRecommendationUpdate); ok {
		r := addInteraction("ImmunizationRecommendation", "update")
		c, ok := c.(ImmunizationRecommendationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesImmunizationRecommendation(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ImmunizationRecommendation"] = r
	}
	if c, ok := w.Concrete.(ImmunizationRecommendationSearch); ok {
		c, err := c.SearchCapabilitiesImmunizationRecommendation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ImmunizationRecommendation", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ImmunizationRecommendation-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ImmunizationRecommendation"] = r
		}
	}
	if _, ok := w.Concrete.(ImplementationGuideCreate); ok {
		resourcesMap["ImplementationGuide"] = addInteraction("ImplementationGuide", "create")
	}
	if _, ok := w.Concrete.(ImplementationGuideRead); ok {
		resourcesMap["ImplementationGuide"] = addInteraction("ImplementationGuide", "read")
	}
	if _, ok := w.Concrete.(ImplementationGuideDelete); ok {
		resourcesMap["ImplementationGuide"] = addInteraction("ImplementationGuide", "delete")
	}
	if c, ok := w.Concrete.(ImplementationGuideUpdate); ok {
		r := addInteraction("ImplementationGuide", "update")
		c, ok := c.(ImplementationGuideUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesImplementationGuide(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ImplementationGuide"] = r
	}
	if c, ok := w.Concrete.(ImplementationGuideSearch); ok {
		c, err := c.SearchCapabilitiesImplementationGuide(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ImplementationGuide", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ImplementationGuide-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ImplementationGuide"] = r
		}
	}
	if _, ok := w.Concrete.(IngredientCreate); ok {
		resourcesMap["Ingredient"] = addInteraction("Ingredient", "create")
	}
	if _, ok := w.Concrete.(IngredientRead); ok {
		resourcesMap["Ingredient"] = addInteraction("Ingredient", "read")
	}
	if _, ok := w.Concrete.(IngredientDelete); ok {
		resourcesMap["Ingredient"] = addInteraction("Ingredient", "delete")
	}
	if c, ok := w.Concrete.(IngredientUpdate); ok {
		r := addInteraction("Ingredient", "update")
		c, ok := c.(IngredientUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesIngredient(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Ingredient"] = r
	}
	if c, ok := w.Concrete.(IngredientSearch); ok {
		c, err := c.SearchCapabilitiesIngredient(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Ingredient", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Ingredient-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Ingredient"] = r
		}
	}
	if _, ok := w.Concrete.(InsurancePlanCreate); ok {
		resourcesMap["InsurancePlan"] = addInteraction("InsurancePlan", "create")
	}
	if _, ok := w.Concrete.(InsurancePlanRead); ok {
		resourcesMap["InsurancePlan"] = addInteraction("InsurancePlan", "read")
	}
	if _, ok := w.Concrete.(InsurancePlanDelete); ok {
		resourcesMap["InsurancePlan"] = addInteraction("InsurancePlan", "delete")
	}
	if c, ok := w.Concrete.(InsurancePlanUpdate); ok {
		r := addInteraction("InsurancePlan", "update")
		c, ok := c.(InsurancePlanUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesInsurancePlan(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["InsurancePlan"] = r
	}
	if c, ok := w.Concrete.(InsurancePlanSearch); ok {
		c, err := c.SearchCapabilitiesInsurancePlan(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("InsurancePlan", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("InsurancePlan-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["InsurancePlan"] = r
		}
	}
	if _, ok := w.Concrete.(InvoiceCreate); ok {
		resourcesMap["Invoice"] = addInteraction("Invoice", "create")
	}
	if _, ok := w.Concrete.(InvoiceRead); ok {
		resourcesMap["Invoice"] = addInteraction("Invoice", "read")
	}
	if _, ok := w.Concrete.(InvoiceDelete); ok {
		resourcesMap["Invoice"] = addInteraction("Invoice", "delete")
	}
	if c, ok := w.Concrete.(InvoiceUpdate); ok {
		r := addInteraction("Invoice", "update")
		c, ok := c.(InvoiceUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesInvoice(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Invoice"] = r
	}
	if c, ok := w.Concrete.(InvoiceSearch); ok {
		c, err := c.SearchCapabilitiesInvoice(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Invoice", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Invoice-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Invoice"] = r
		}
	}
	if _, ok := w.Concrete.(LibraryCreate); ok {
		resourcesMap["Library"] = addInteraction("Library", "create")
	}
	if _, ok := w.Concrete.(LibraryRead); ok {
		resourcesMap["Library"] = addInteraction("Library", "read")
	}
	if _, ok := w.Concrete.(LibraryDelete); ok {
		resourcesMap["Library"] = addInteraction("Library", "delete")
	}
	if c, ok := w.Concrete.(LibraryUpdate); ok {
		r := addInteraction("Library", "update")
		c, ok := c.(LibraryUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesLibrary(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Library"] = r
	}
	if c, ok := w.Concrete.(LibrarySearch); ok {
		c, err := c.SearchCapabilitiesLibrary(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Library", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Library-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Library"] = r
		}
	}
	if _, ok := w.Concrete.(LinkageCreate); ok {
		resourcesMap["Linkage"] = addInteraction("Linkage", "create")
	}
	if _, ok := w.Concrete.(LinkageRead); ok {
		resourcesMap["Linkage"] = addInteraction("Linkage", "read")
	}
	if _, ok := w.Concrete.(LinkageDelete); ok {
		resourcesMap["Linkage"] = addInteraction("Linkage", "delete")
	}
	if c, ok := w.Concrete.(LinkageUpdate); ok {
		r := addInteraction("Linkage", "update")
		c, ok := c.(LinkageUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesLinkage(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Linkage"] = r
	}
	if c, ok := w.Concrete.(LinkageSearch); ok {
		c, err := c.SearchCapabilitiesLinkage(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Linkage", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Linkage-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Linkage"] = r
		}
	}
	if _, ok := w.Concrete.(ListCreate); ok {
		resourcesMap["List"] = addInteraction("List", "create")
	}
	if _, ok := w.Concrete.(ListRead); ok {
		resourcesMap["List"] = addInteraction("List", "read")
	}
	if _, ok := w.Concrete.(ListDelete); ok {
		resourcesMap["List"] = addInteraction("List", "delete")
	}
	if c, ok := w.Concrete.(ListUpdate); ok {
		r := addInteraction("List", "update")
		c, ok := c.(ListUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesList(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["List"] = r
	}
	if c, ok := w.Concrete.(ListSearch); ok {
		c, err := c.SearchCapabilitiesList(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("List", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("List-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["List"] = r
		}
	}
	if _, ok := w.Concrete.(LocationCreate); ok {
		resourcesMap["Location"] = addInteraction("Location", "create")
	}
	if _, ok := w.Concrete.(LocationRead); ok {
		resourcesMap["Location"] = addInteraction("Location", "read")
	}
	if _, ok := w.Concrete.(LocationDelete); ok {
		resourcesMap["Location"] = addInteraction("Location", "delete")
	}
	if c, ok := w.Concrete.(LocationUpdate); ok {
		r := addInteraction("Location", "update")
		c, ok := c.(LocationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesLocation(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Location"] = r
	}
	if c, ok := w.Concrete.(LocationSearch); ok {
		c, err := c.SearchCapabilitiesLocation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Location", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Location-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Location"] = r
		}
	}
	if _, ok := w.Concrete.(ManufacturedItemDefinitionCreate); ok {
		resourcesMap["ManufacturedItemDefinition"] = addInteraction("ManufacturedItemDefinition", "create")
	}
	if _, ok := w.Concrete.(ManufacturedItemDefinitionRead); ok {
		resourcesMap["ManufacturedItemDefinition"] = addInteraction("ManufacturedItemDefinition", "read")
	}
	if _, ok := w.Concrete.(ManufacturedItemDefinitionDelete); ok {
		resourcesMap["ManufacturedItemDefinition"] = addInteraction("ManufacturedItemDefinition", "delete")
	}
	if c, ok := w.Concrete.(ManufacturedItemDefinitionUpdate); ok {
		r := addInteraction("ManufacturedItemDefinition", "update")
		c, ok := c.(ManufacturedItemDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesManufacturedItemDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ManufacturedItemDefinition"] = r
	}
	if c, ok := w.Concrete.(ManufacturedItemDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesManufacturedItemDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ManufacturedItemDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ManufacturedItemDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ManufacturedItemDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(MeasureCreate); ok {
		resourcesMap["Measure"] = addInteraction("Measure", "create")
	}
	if _, ok := w.Concrete.(MeasureRead); ok {
		resourcesMap["Measure"] = addInteraction("Measure", "read")
	}
	if _, ok := w.Concrete.(MeasureDelete); ok {
		resourcesMap["Measure"] = addInteraction("Measure", "delete")
	}
	if c, ok := w.Concrete.(MeasureUpdate); ok {
		r := addInteraction("Measure", "update")
		c, ok := c.(MeasureUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMeasure(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Measure"] = r
	}
	if c, ok := w.Concrete.(MeasureSearch); ok {
		c, err := c.SearchCapabilitiesMeasure(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Measure", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Measure-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Measure"] = r
		}
	}
	if _, ok := w.Concrete.(MeasureReportCreate); ok {
		resourcesMap["MeasureReport"] = addInteraction("MeasureReport", "create")
	}
	if _, ok := w.Concrete.(MeasureReportRead); ok {
		resourcesMap["MeasureReport"] = addInteraction("MeasureReport", "read")
	}
	if _, ok := w.Concrete.(MeasureReportDelete); ok {
		resourcesMap["MeasureReport"] = addInteraction("MeasureReport", "delete")
	}
	if c, ok := w.Concrete.(MeasureReportUpdate); ok {
		r := addInteraction("MeasureReport", "update")
		c, ok := c.(MeasureReportUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMeasureReport(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MeasureReport"] = r
	}
	if c, ok := w.Concrete.(MeasureReportSearch); ok {
		c, err := c.SearchCapabilitiesMeasureReport(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MeasureReport", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MeasureReport-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MeasureReport"] = r
		}
	}
	if _, ok := w.Concrete.(MediaCreate); ok {
		resourcesMap["Media"] = addInteraction("Media", "create")
	}
	if _, ok := w.Concrete.(MediaRead); ok {
		resourcesMap["Media"] = addInteraction("Media", "read")
	}
	if _, ok := w.Concrete.(MediaDelete); ok {
		resourcesMap["Media"] = addInteraction("Media", "delete")
	}
	if c, ok := w.Concrete.(MediaUpdate); ok {
		r := addInteraction("Media", "update")
		c, ok := c.(MediaUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedia(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Media"] = r
	}
	if c, ok := w.Concrete.(MediaSearch); ok {
		c, err := c.SearchCapabilitiesMedia(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Media", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Media-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Media"] = r
		}
	}
	if _, ok := w.Concrete.(MedicationCreate); ok {
		resourcesMap["Medication"] = addInteraction("Medication", "create")
	}
	if _, ok := w.Concrete.(MedicationRead); ok {
		resourcesMap["Medication"] = addInteraction("Medication", "read")
	}
	if _, ok := w.Concrete.(MedicationDelete); ok {
		resourcesMap["Medication"] = addInteraction("Medication", "delete")
	}
	if c, ok := w.Concrete.(MedicationUpdate); ok {
		r := addInteraction("Medication", "update")
		c, ok := c.(MedicationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedication(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Medication"] = r
	}
	if c, ok := w.Concrete.(MedicationSearch); ok {
		c, err := c.SearchCapabilitiesMedication(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Medication", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Medication-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Medication"] = r
		}
	}
	if _, ok := w.Concrete.(MedicationAdministrationCreate); ok {
		resourcesMap["MedicationAdministration"] = addInteraction("MedicationAdministration", "create")
	}
	if _, ok := w.Concrete.(MedicationAdministrationRead); ok {
		resourcesMap["MedicationAdministration"] = addInteraction("MedicationAdministration", "read")
	}
	if _, ok := w.Concrete.(MedicationAdministrationDelete); ok {
		resourcesMap["MedicationAdministration"] = addInteraction("MedicationAdministration", "delete")
	}
	if c, ok := w.Concrete.(MedicationAdministrationUpdate); ok {
		r := addInteraction("MedicationAdministration", "update")
		c, ok := c.(MedicationAdministrationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedicationAdministration(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MedicationAdministration"] = r
	}
	if c, ok := w.Concrete.(MedicationAdministrationSearch); ok {
		c, err := c.SearchCapabilitiesMedicationAdministration(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MedicationAdministration", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MedicationAdministration-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MedicationAdministration"] = r
		}
	}
	if _, ok := w.Concrete.(MedicationDispenseCreate); ok {
		resourcesMap["MedicationDispense"] = addInteraction("MedicationDispense", "create")
	}
	if _, ok := w.Concrete.(MedicationDispenseRead); ok {
		resourcesMap["MedicationDispense"] = addInteraction("MedicationDispense", "read")
	}
	if _, ok := w.Concrete.(MedicationDispenseDelete); ok {
		resourcesMap["MedicationDispense"] = addInteraction("MedicationDispense", "delete")
	}
	if c, ok := w.Concrete.(MedicationDispenseUpdate); ok {
		r := addInteraction("MedicationDispense", "update")
		c, ok := c.(MedicationDispenseUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedicationDispense(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MedicationDispense"] = r
	}
	if c, ok := w.Concrete.(MedicationDispenseSearch); ok {
		c, err := c.SearchCapabilitiesMedicationDispense(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MedicationDispense", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MedicationDispense-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MedicationDispense"] = r
		}
	}
	if _, ok := w.Concrete.(MedicationKnowledgeCreate); ok {
		resourcesMap["MedicationKnowledge"] = addInteraction("MedicationKnowledge", "create")
	}
	if _, ok := w.Concrete.(MedicationKnowledgeRead); ok {
		resourcesMap["MedicationKnowledge"] = addInteraction("MedicationKnowledge", "read")
	}
	if _, ok := w.Concrete.(MedicationKnowledgeDelete); ok {
		resourcesMap["MedicationKnowledge"] = addInteraction("MedicationKnowledge", "delete")
	}
	if c, ok := w.Concrete.(MedicationKnowledgeUpdate); ok {
		r := addInteraction("MedicationKnowledge", "update")
		c, ok := c.(MedicationKnowledgeUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedicationKnowledge(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MedicationKnowledge"] = r
	}
	if c, ok := w.Concrete.(MedicationKnowledgeSearch); ok {
		c, err := c.SearchCapabilitiesMedicationKnowledge(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MedicationKnowledge", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MedicationKnowledge-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MedicationKnowledge"] = r
		}
	}
	if _, ok := w.Concrete.(MedicationRequestCreate); ok {
		resourcesMap["MedicationRequest"] = addInteraction("MedicationRequest", "create")
	}
	if _, ok := w.Concrete.(MedicationRequestRead); ok {
		resourcesMap["MedicationRequest"] = addInteraction("MedicationRequest", "read")
	}
	if _, ok := w.Concrete.(MedicationRequestDelete); ok {
		resourcesMap["MedicationRequest"] = addInteraction("MedicationRequest", "delete")
	}
	if c, ok := w.Concrete.(MedicationRequestUpdate); ok {
		r := addInteraction("MedicationRequest", "update")
		c, ok := c.(MedicationRequestUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedicationRequest(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MedicationRequest"] = r
	}
	if c, ok := w.Concrete.(MedicationRequestSearch); ok {
		c, err := c.SearchCapabilitiesMedicationRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MedicationRequest", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MedicationRequest-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MedicationRequest"] = r
		}
	}
	if _, ok := w.Concrete.(MedicationStatementCreate); ok {
		resourcesMap["MedicationStatement"] = addInteraction("MedicationStatement", "create")
	}
	if _, ok := w.Concrete.(MedicationStatementRead); ok {
		resourcesMap["MedicationStatement"] = addInteraction("MedicationStatement", "read")
	}
	if _, ok := w.Concrete.(MedicationStatementDelete); ok {
		resourcesMap["MedicationStatement"] = addInteraction("MedicationStatement", "delete")
	}
	if c, ok := w.Concrete.(MedicationStatementUpdate); ok {
		r := addInteraction("MedicationStatement", "update")
		c, ok := c.(MedicationStatementUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedicationStatement(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MedicationStatement"] = r
	}
	if c, ok := w.Concrete.(MedicationStatementSearch); ok {
		c, err := c.SearchCapabilitiesMedicationStatement(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MedicationStatement", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MedicationStatement-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MedicationStatement"] = r
		}
	}
	if _, ok := w.Concrete.(MedicinalProductDefinitionCreate); ok {
		resourcesMap["MedicinalProductDefinition"] = addInteraction("MedicinalProductDefinition", "create")
	}
	if _, ok := w.Concrete.(MedicinalProductDefinitionRead); ok {
		resourcesMap["MedicinalProductDefinition"] = addInteraction("MedicinalProductDefinition", "read")
	}
	if _, ok := w.Concrete.(MedicinalProductDefinitionDelete); ok {
		resourcesMap["MedicinalProductDefinition"] = addInteraction("MedicinalProductDefinition", "delete")
	}
	if c, ok := w.Concrete.(MedicinalProductDefinitionUpdate); ok {
		r := addInteraction("MedicinalProductDefinition", "update")
		c, ok := c.(MedicinalProductDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMedicinalProductDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MedicinalProductDefinition"] = r
	}
	if c, ok := w.Concrete.(MedicinalProductDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesMedicinalProductDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MedicinalProductDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MedicinalProductDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MedicinalProductDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(MessageDefinitionCreate); ok {
		resourcesMap["MessageDefinition"] = addInteraction("MessageDefinition", "create")
	}
	if _, ok := w.Concrete.(MessageDefinitionRead); ok {
		resourcesMap["MessageDefinition"] = addInteraction("MessageDefinition", "read")
	}
	if _, ok := w.Concrete.(MessageDefinitionDelete); ok {
		resourcesMap["MessageDefinition"] = addInteraction("MessageDefinition", "delete")
	}
	if c, ok := w.Concrete.(MessageDefinitionUpdate); ok {
		r := addInteraction("MessageDefinition", "update")
		c, ok := c.(MessageDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMessageDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MessageDefinition"] = r
	}
	if c, ok := w.Concrete.(MessageDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesMessageDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MessageDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MessageDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MessageDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(MessageHeaderCreate); ok {
		resourcesMap["MessageHeader"] = addInteraction("MessageHeader", "create")
	}
	if _, ok := w.Concrete.(MessageHeaderRead); ok {
		resourcesMap["MessageHeader"] = addInteraction("MessageHeader", "read")
	}
	if _, ok := w.Concrete.(MessageHeaderDelete); ok {
		resourcesMap["MessageHeader"] = addInteraction("MessageHeader", "delete")
	}
	if c, ok := w.Concrete.(MessageHeaderUpdate); ok {
		r := addInteraction("MessageHeader", "update")
		c, ok := c.(MessageHeaderUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMessageHeader(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MessageHeader"] = r
	}
	if c, ok := w.Concrete.(MessageHeaderSearch); ok {
		c, err := c.SearchCapabilitiesMessageHeader(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MessageHeader", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MessageHeader-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MessageHeader"] = r
		}
	}
	if _, ok := w.Concrete.(MolecularSequenceCreate); ok {
		resourcesMap["MolecularSequence"] = addInteraction("MolecularSequence", "create")
	}
	if _, ok := w.Concrete.(MolecularSequenceRead); ok {
		resourcesMap["MolecularSequence"] = addInteraction("MolecularSequence", "read")
	}
	if _, ok := w.Concrete.(MolecularSequenceDelete); ok {
		resourcesMap["MolecularSequence"] = addInteraction("MolecularSequence", "delete")
	}
	if c, ok := w.Concrete.(MolecularSequenceUpdate); ok {
		r := addInteraction("MolecularSequence", "update")
		c, ok := c.(MolecularSequenceUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesMolecularSequence(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["MolecularSequence"] = r
	}
	if c, ok := w.Concrete.(MolecularSequenceSearch); ok {
		c, err := c.SearchCapabilitiesMolecularSequence(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("MolecularSequence", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("MolecularSequence-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["MolecularSequence"] = r
		}
	}
	if _, ok := w.Concrete.(NamingSystemCreate); ok {
		resourcesMap["NamingSystem"] = addInteraction("NamingSystem", "create")
	}
	if _, ok := w.Concrete.(NamingSystemRead); ok {
		resourcesMap["NamingSystem"] = addInteraction("NamingSystem", "read")
	}
	if _, ok := w.Concrete.(NamingSystemDelete); ok {
		resourcesMap["NamingSystem"] = addInteraction("NamingSystem", "delete")
	}
	if c, ok := w.Concrete.(NamingSystemUpdate); ok {
		r := addInteraction("NamingSystem", "update")
		c, ok := c.(NamingSystemUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesNamingSystem(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["NamingSystem"] = r
	}
	if c, ok := w.Concrete.(NamingSystemSearch); ok {
		c, err := c.SearchCapabilitiesNamingSystem(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("NamingSystem", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("NamingSystem-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["NamingSystem"] = r
		}
	}
	if _, ok := w.Concrete.(NutritionOrderCreate); ok {
		resourcesMap["NutritionOrder"] = addInteraction("NutritionOrder", "create")
	}
	if _, ok := w.Concrete.(NutritionOrderRead); ok {
		resourcesMap["NutritionOrder"] = addInteraction("NutritionOrder", "read")
	}
	if _, ok := w.Concrete.(NutritionOrderDelete); ok {
		resourcesMap["NutritionOrder"] = addInteraction("NutritionOrder", "delete")
	}
	if c, ok := w.Concrete.(NutritionOrderUpdate); ok {
		r := addInteraction("NutritionOrder", "update")
		c, ok := c.(NutritionOrderUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesNutritionOrder(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["NutritionOrder"] = r
	}
	if c, ok := w.Concrete.(NutritionOrderSearch); ok {
		c, err := c.SearchCapabilitiesNutritionOrder(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("NutritionOrder", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("NutritionOrder-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["NutritionOrder"] = r
		}
	}
	if _, ok := w.Concrete.(NutritionProductCreate); ok {
		resourcesMap["NutritionProduct"] = addInteraction("NutritionProduct", "create")
	}
	if _, ok := w.Concrete.(NutritionProductRead); ok {
		resourcesMap["NutritionProduct"] = addInteraction("NutritionProduct", "read")
	}
	if _, ok := w.Concrete.(NutritionProductDelete); ok {
		resourcesMap["NutritionProduct"] = addInteraction("NutritionProduct", "delete")
	}
	if c, ok := w.Concrete.(NutritionProductUpdate); ok {
		r := addInteraction("NutritionProduct", "update")
		c, ok := c.(NutritionProductUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesNutritionProduct(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["NutritionProduct"] = r
	}
	if c, ok := w.Concrete.(NutritionProductSearch); ok {
		c, err := c.SearchCapabilitiesNutritionProduct(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("NutritionProduct", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("NutritionProduct-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["NutritionProduct"] = r
		}
	}
	if _, ok := w.Concrete.(ObservationCreate); ok {
		resourcesMap["Observation"] = addInteraction("Observation", "create")
	}
	if _, ok := w.Concrete.(ObservationRead); ok {
		resourcesMap["Observation"] = addInteraction("Observation", "read")
	}
	if _, ok := w.Concrete.(ObservationDelete); ok {
		resourcesMap["Observation"] = addInteraction("Observation", "delete")
	}
	if c, ok := w.Concrete.(ObservationUpdate); ok {
		r := addInteraction("Observation", "update")
		c, ok := c.(ObservationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesObservation(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Observation"] = r
	}
	if c, ok := w.Concrete.(ObservationSearch); ok {
		c, err := c.SearchCapabilitiesObservation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Observation", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Observation-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Observation"] = r
		}
	}
	if _, ok := w.Concrete.(ObservationDefinitionCreate); ok {
		resourcesMap["ObservationDefinition"] = addInteraction("ObservationDefinition", "create")
	}
	if _, ok := w.Concrete.(ObservationDefinitionRead); ok {
		resourcesMap["ObservationDefinition"] = addInteraction("ObservationDefinition", "read")
	}
	if _, ok := w.Concrete.(ObservationDefinitionDelete); ok {
		resourcesMap["ObservationDefinition"] = addInteraction("ObservationDefinition", "delete")
	}
	if c, ok := w.Concrete.(ObservationDefinitionUpdate); ok {
		r := addInteraction("ObservationDefinition", "update")
		c, ok := c.(ObservationDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesObservationDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ObservationDefinition"] = r
	}
	if c, ok := w.Concrete.(ObservationDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesObservationDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ObservationDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ObservationDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ObservationDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(OperationDefinitionCreate); ok {
		resourcesMap["OperationDefinition"] = addInteraction("OperationDefinition", "create")
	}
	if _, ok := w.Concrete.(OperationDefinitionRead); ok {
		resourcesMap["OperationDefinition"] = addInteraction("OperationDefinition", "read")
	}
	if _, ok := w.Concrete.(OperationDefinitionDelete); ok {
		resourcesMap["OperationDefinition"] = addInteraction("OperationDefinition", "delete")
	}
	if c, ok := w.Concrete.(OperationDefinitionUpdate); ok {
		r := addInteraction("OperationDefinition", "update")
		c, ok := c.(OperationDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesOperationDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["OperationDefinition"] = r
	}
	if c, ok := w.Concrete.(OperationDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesOperationDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("OperationDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("OperationDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["OperationDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(OperationOutcomeCreate); ok {
		resourcesMap["OperationOutcome"] = addInteraction("OperationOutcome", "create")
	}
	if _, ok := w.Concrete.(OperationOutcomeRead); ok {
		resourcesMap["OperationOutcome"] = addInteraction("OperationOutcome", "read")
	}
	if _, ok := w.Concrete.(OperationOutcomeDelete); ok {
		resourcesMap["OperationOutcome"] = addInteraction("OperationOutcome", "delete")
	}
	if c, ok := w.Concrete.(OperationOutcomeUpdate); ok {
		r := addInteraction("OperationOutcome", "update")
		c, ok := c.(OperationOutcomeUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesOperationOutcome(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["OperationOutcome"] = r
	}
	if c, ok := w.Concrete.(OperationOutcomeSearch); ok {
		c, err := c.SearchCapabilitiesOperationOutcome(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("OperationOutcome", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("OperationOutcome-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["OperationOutcome"] = r
		}
	}
	if _, ok := w.Concrete.(OrganizationCreate); ok {
		resourcesMap["Organization"] = addInteraction("Organization", "create")
	}
	if _, ok := w.Concrete.(OrganizationRead); ok {
		resourcesMap["Organization"] = addInteraction("Organization", "read")
	}
	if _, ok := w.Concrete.(OrganizationDelete); ok {
		resourcesMap["Organization"] = addInteraction("Organization", "delete")
	}
	if c, ok := w.Concrete.(OrganizationUpdate); ok {
		r := addInteraction("Organization", "update")
		c, ok := c.(OrganizationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesOrganization(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Organization"] = r
	}
	if c, ok := w.Concrete.(OrganizationSearch); ok {
		c, err := c.SearchCapabilitiesOrganization(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Organization", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Organization-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Organization"] = r
		}
	}
	if _, ok := w.Concrete.(OrganizationAffiliationCreate); ok {
		resourcesMap["OrganizationAffiliation"] = addInteraction("OrganizationAffiliation", "create")
	}
	if _, ok := w.Concrete.(OrganizationAffiliationRead); ok {
		resourcesMap["OrganizationAffiliation"] = addInteraction("OrganizationAffiliation", "read")
	}
	if _, ok := w.Concrete.(OrganizationAffiliationDelete); ok {
		resourcesMap["OrganizationAffiliation"] = addInteraction("OrganizationAffiliation", "delete")
	}
	if c, ok := w.Concrete.(OrganizationAffiliationUpdate); ok {
		r := addInteraction("OrganizationAffiliation", "update")
		c, ok := c.(OrganizationAffiliationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesOrganizationAffiliation(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["OrganizationAffiliation"] = r
	}
	if c, ok := w.Concrete.(OrganizationAffiliationSearch); ok {
		c, err := c.SearchCapabilitiesOrganizationAffiliation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("OrganizationAffiliation", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("OrganizationAffiliation-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["OrganizationAffiliation"] = r
		}
	}
	if _, ok := w.Concrete.(PackagedProductDefinitionCreate); ok {
		resourcesMap["PackagedProductDefinition"] = addInteraction("PackagedProductDefinition", "create")
	}
	if _, ok := w.Concrete.(PackagedProductDefinitionRead); ok {
		resourcesMap["PackagedProductDefinition"] = addInteraction("PackagedProductDefinition", "read")
	}
	if _, ok := w.Concrete.(PackagedProductDefinitionDelete); ok {
		resourcesMap["PackagedProductDefinition"] = addInteraction("PackagedProductDefinition", "delete")
	}
	if c, ok := w.Concrete.(PackagedProductDefinitionUpdate); ok {
		r := addInteraction("PackagedProductDefinition", "update")
		c, ok := c.(PackagedProductDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesPackagedProductDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["PackagedProductDefinition"] = r
	}
	if c, ok := w.Concrete.(PackagedProductDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesPackagedProductDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("PackagedProductDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("PackagedProductDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["PackagedProductDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(ParametersCreate); ok {
		resourcesMap["Parameters"] = addInteraction("Parameters", "create")
	}
	if _, ok := w.Concrete.(ParametersRead); ok {
		resourcesMap["Parameters"] = addInteraction("Parameters", "read")
	}
	if _, ok := w.Concrete.(ParametersDelete); ok {
		resourcesMap["Parameters"] = addInteraction("Parameters", "delete")
	}
	if c, ok := w.Concrete.(ParametersUpdate); ok {
		r := addInteraction("Parameters", "update")
		c, ok := c.(ParametersUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesParameters(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Parameters"] = r
	}
	if c, ok := w.Concrete.(ParametersSearch); ok {
		c, err := c.SearchCapabilitiesParameters(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Parameters", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Parameters-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Parameters"] = r
		}
	}
	if _, ok := w.Concrete.(PatientCreate); ok {
		resourcesMap["Patient"] = addInteraction("Patient", "create")
	}
	if _, ok := w.Concrete.(PatientRead); ok {
		resourcesMap["Patient"] = addInteraction("Patient", "read")
	}
	if _, ok := w.Concrete.(PatientDelete); ok {
		resourcesMap["Patient"] = addInteraction("Patient", "delete")
	}
	if c, ok := w.Concrete.(PatientUpdate); ok {
		r := addInteraction("Patient", "update")
		c, ok := c.(PatientUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesPatient(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Patient"] = r
	}
	if c, ok := w.Concrete.(PatientSearch); ok {
		c, err := c.SearchCapabilitiesPatient(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Patient", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Patient-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Patient"] = r
		}
	}
	if _, ok := w.Concrete.(PaymentNoticeCreate); ok {
		resourcesMap["PaymentNotice"] = addInteraction("PaymentNotice", "create")
	}
	if _, ok := w.Concrete.(PaymentNoticeRead); ok {
		resourcesMap["PaymentNotice"] = addInteraction("PaymentNotice", "read")
	}
	if _, ok := w.Concrete.(PaymentNoticeDelete); ok {
		resourcesMap["PaymentNotice"] = addInteraction("PaymentNotice", "delete")
	}
	if c, ok := w.Concrete.(PaymentNoticeUpdate); ok {
		r := addInteraction("PaymentNotice", "update")
		c, ok := c.(PaymentNoticeUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesPaymentNotice(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["PaymentNotice"] = r
	}
	if c, ok := w.Concrete.(PaymentNoticeSearch); ok {
		c, err := c.SearchCapabilitiesPaymentNotice(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("PaymentNotice", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("PaymentNotice-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["PaymentNotice"] = r
		}
	}
	if _, ok := w.Concrete.(PaymentReconciliationCreate); ok {
		resourcesMap["PaymentReconciliation"] = addInteraction("PaymentReconciliation", "create")
	}
	if _, ok := w.Concrete.(PaymentReconciliationRead); ok {
		resourcesMap["PaymentReconciliation"] = addInteraction("PaymentReconciliation", "read")
	}
	if _, ok := w.Concrete.(PaymentReconciliationDelete); ok {
		resourcesMap["PaymentReconciliation"] = addInteraction("PaymentReconciliation", "delete")
	}
	if c, ok := w.Concrete.(PaymentReconciliationUpdate); ok {
		r := addInteraction("PaymentReconciliation", "update")
		c, ok := c.(PaymentReconciliationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesPaymentReconciliation(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["PaymentReconciliation"] = r
	}
	if c, ok := w.Concrete.(PaymentReconciliationSearch); ok {
		c, err := c.SearchCapabilitiesPaymentReconciliation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("PaymentReconciliation", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("PaymentReconciliation-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["PaymentReconciliation"] = r
		}
	}
	if _, ok := w.Concrete.(PersonCreate); ok {
		resourcesMap["Person"] = addInteraction("Person", "create")
	}
	if _, ok := w.Concrete.(PersonRead); ok {
		resourcesMap["Person"] = addInteraction("Person", "read")
	}
	if _, ok := w.Concrete.(PersonDelete); ok {
		resourcesMap["Person"] = addInteraction("Person", "delete")
	}
	if c, ok := w.Concrete.(PersonUpdate); ok {
		r := addInteraction("Person", "update")
		c, ok := c.(PersonUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesPerson(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Person"] = r
	}
	if c, ok := w.Concrete.(PersonSearch); ok {
		c, err := c.SearchCapabilitiesPerson(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Person", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Person-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Person"] = r
		}
	}
	if _, ok := w.Concrete.(PlanDefinitionCreate); ok {
		resourcesMap["PlanDefinition"] = addInteraction("PlanDefinition", "create")
	}
	if _, ok := w.Concrete.(PlanDefinitionRead); ok {
		resourcesMap["PlanDefinition"] = addInteraction("PlanDefinition", "read")
	}
	if _, ok := w.Concrete.(PlanDefinitionDelete); ok {
		resourcesMap["PlanDefinition"] = addInteraction("PlanDefinition", "delete")
	}
	if c, ok := w.Concrete.(PlanDefinitionUpdate); ok {
		r := addInteraction("PlanDefinition", "update")
		c, ok := c.(PlanDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesPlanDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["PlanDefinition"] = r
	}
	if c, ok := w.Concrete.(PlanDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesPlanDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("PlanDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("PlanDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["PlanDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(PractitionerCreate); ok {
		resourcesMap["Practitioner"] = addInteraction("Practitioner", "create")
	}
	if _, ok := w.Concrete.(PractitionerRead); ok {
		resourcesMap["Practitioner"] = addInteraction("Practitioner", "read")
	}
	if _, ok := w.Concrete.(PractitionerDelete); ok {
		resourcesMap["Practitioner"] = addInteraction("Practitioner", "delete")
	}
	if c, ok := w.Concrete.(PractitionerUpdate); ok {
		r := addInteraction("Practitioner", "update")
		c, ok := c.(PractitionerUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesPractitioner(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Practitioner"] = r
	}
	if c, ok := w.Concrete.(PractitionerSearch); ok {
		c, err := c.SearchCapabilitiesPractitioner(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Practitioner", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Practitioner-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Practitioner"] = r
		}
	}
	if _, ok := w.Concrete.(PractitionerRoleCreate); ok {
		resourcesMap["PractitionerRole"] = addInteraction("PractitionerRole", "create")
	}
	if _, ok := w.Concrete.(PractitionerRoleRead); ok {
		resourcesMap["PractitionerRole"] = addInteraction("PractitionerRole", "read")
	}
	if _, ok := w.Concrete.(PractitionerRoleDelete); ok {
		resourcesMap["PractitionerRole"] = addInteraction("PractitionerRole", "delete")
	}
	if c, ok := w.Concrete.(PractitionerRoleUpdate); ok {
		r := addInteraction("PractitionerRole", "update")
		c, ok := c.(PractitionerRoleUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesPractitionerRole(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["PractitionerRole"] = r
	}
	if c, ok := w.Concrete.(PractitionerRoleSearch); ok {
		c, err := c.SearchCapabilitiesPractitionerRole(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("PractitionerRole", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("PractitionerRole-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["PractitionerRole"] = r
		}
	}
	if _, ok := w.Concrete.(ProcedureCreate); ok {
		resourcesMap["Procedure"] = addInteraction("Procedure", "create")
	}
	if _, ok := w.Concrete.(ProcedureRead); ok {
		resourcesMap["Procedure"] = addInteraction("Procedure", "read")
	}
	if _, ok := w.Concrete.(ProcedureDelete); ok {
		resourcesMap["Procedure"] = addInteraction("Procedure", "delete")
	}
	if c, ok := w.Concrete.(ProcedureUpdate); ok {
		r := addInteraction("Procedure", "update")
		c, ok := c.(ProcedureUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesProcedure(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Procedure"] = r
	}
	if c, ok := w.Concrete.(ProcedureSearch); ok {
		c, err := c.SearchCapabilitiesProcedure(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Procedure", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Procedure-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Procedure"] = r
		}
	}
	if _, ok := w.Concrete.(ProvenanceCreate); ok {
		resourcesMap["Provenance"] = addInteraction("Provenance", "create")
	}
	if _, ok := w.Concrete.(ProvenanceRead); ok {
		resourcesMap["Provenance"] = addInteraction("Provenance", "read")
	}
	if _, ok := w.Concrete.(ProvenanceDelete); ok {
		resourcesMap["Provenance"] = addInteraction("Provenance", "delete")
	}
	if c, ok := w.Concrete.(ProvenanceUpdate); ok {
		r := addInteraction("Provenance", "update")
		c, ok := c.(ProvenanceUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesProvenance(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Provenance"] = r
	}
	if c, ok := w.Concrete.(ProvenanceSearch); ok {
		c, err := c.SearchCapabilitiesProvenance(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Provenance", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Provenance-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Provenance"] = r
		}
	}
	if _, ok := w.Concrete.(QuestionnaireCreate); ok {
		resourcesMap["Questionnaire"] = addInteraction("Questionnaire", "create")
	}
	if _, ok := w.Concrete.(QuestionnaireRead); ok {
		resourcesMap["Questionnaire"] = addInteraction("Questionnaire", "read")
	}
	if _, ok := w.Concrete.(QuestionnaireDelete); ok {
		resourcesMap["Questionnaire"] = addInteraction("Questionnaire", "delete")
	}
	if c, ok := w.Concrete.(QuestionnaireUpdate); ok {
		r := addInteraction("Questionnaire", "update")
		c, ok := c.(QuestionnaireUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesQuestionnaire(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Questionnaire"] = r
	}
	if c, ok := w.Concrete.(QuestionnaireSearch); ok {
		c, err := c.SearchCapabilitiesQuestionnaire(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Questionnaire", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Questionnaire-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Questionnaire"] = r
		}
	}
	if _, ok := w.Concrete.(QuestionnaireResponseCreate); ok {
		resourcesMap["QuestionnaireResponse"] = addInteraction("QuestionnaireResponse", "create")
	}
	if _, ok := w.Concrete.(QuestionnaireResponseRead); ok {
		resourcesMap["QuestionnaireResponse"] = addInteraction("QuestionnaireResponse", "read")
	}
	if _, ok := w.Concrete.(QuestionnaireResponseDelete); ok {
		resourcesMap["QuestionnaireResponse"] = addInteraction("QuestionnaireResponse", "delete")
	}
	if c, ok := w.Concrete.(QuestionnaireResponseUpdate); ok {
		r := addInteraction("QuestionnaireResponse", "update")
		c, ok := c.(QuestionnaireResponseUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesQuestionnaireResponse(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["QuestionnaireResponse"] = r
	}
	if c, ok := w.Concrete.(QuestionnaireResponseSearch); ok {
		c, err := c.SearchCapabilitiesQuestionnaireResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("QuestionnaireResponse", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("QuestionnaireResponse-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["QuestionnaireResponse"] = r
		}
	}
	if _, ok := w.Concrete.(RegulatedAuthorizationCreate); ok {
		resourcesMap["RegulatedAuthorization"] = addInteraction("RegulatedAuthorization", "create")
	}
	if _, ok := w.Concrete.(RegulatedAuthorizationRead); ok {
		resourcesMap["RegulatedAuthorization"] = addInteraction("RegulatedAuthorization", "read")
	}
	if _, ok := w.Concrete.(RegulatedAuthorizationDelete); ok {
		resourcesMap["RegulatedAuthorization"] = addInteraction("RegulatedAuthorization", "delete")
	}
	if c, ok := w.Concrete.(RegulatedAuthorizationUpdate); ok {
		r := addInteraction("RegulatedAuthorization", "update")
		c, ok := c.(RegulatedAuthorizationUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesRegulatedAuthorization(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["RegulatedAuthorization"] = r
	}
	if c, ok := w.Concrete.(RegulatedAuthorizationSearch); ok {
		c, err := c.SearchCapabilitiesRegulatedAuthorization(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("RegulatedAuthorization", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("RegulatedAuthorization-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["RegulatedAuthorization"] = r
		}
	}
	if _, ok := w.Concrete.(RelatedPersonCreate); ok {
		resourcesMap["RelatedPerson"] = addInteraction("RelatedPerson", "create")
	}
	if _, ok := w.Concrete.(RelatedPersonRead); ok {
		resourcesMap["RelatedPerson"] = addInteraction("RelatedPerson", "read")
	}
	if _, ok := w.Concrete.(RelatedPersonDelete); ok {
		resourcesMap["RelatedPerson"] = addInteraction("RelatedPerson", "delete")
	}
	if c, ok := w.Concrete.(RelatedPersonUpdate); ok {
		r := addInteraction("RelatedPerson", "update")
		c, ok := c.(RelatedPersonUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesRelatedPerson(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["RelatedPerson"] = r
	}
	if c, ok := w.Concrete.(RelatedPersonSearch); ok {
		c, err := c.SearchCapabilitiesRelatedPerson(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("RelatedPerson", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("RelatedPerson-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["RelatedPerson"] = r
		}
	}
	if _, ok := w.Concrete.(RequestGroupCreate); ok {
		resourcesMap["RequestGroup"] = addInteraction("RequestGroup", "create")
	}
	if _, ok := w.Concrete.(RequestGroupRead); ok {
		resourcesMap["RequestGroup"] = addInteraction("RequestGroup", "read")
	}
	if _, ok := w.Concrete.(RequestGroupDelete); ok {
		resourcesMap["RequestGroup"] = addInteraction("RequestGroup", "delete")
	}
	if c, ok := w.Concrete.(RequestGroupUpdate); ok {
		r := addInteraction("RequestGroup", "update")
		c, ok := c.(RequestGroupUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesRequestGroup(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["RequestGroup"] = r
	}
	if c, ok := w.Concrete.(RequestGroupSearch); ok {
		c, err := c.SearchCapabilitiesRequestGroup(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("RequestGroup", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("RequestGroup-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["RequestGroup"] = r
		}
	}
	if _, ok := w.Concrete.(ResearchDefinitionCreate); ok {
		resourcesMap["ResearchDefinition"] = addInteraction("ResearchDefinition", "create")
	}
	if _, ok := w.Concrete.(ResearchDefinitionRead); ok {
		resourcesMap["ResearchDefinition"] = addInteraction("ResearchDefinition", "read")
	}
	if _, ok := w.Concrete.(ResearchDefinitionDelete); ok {
		resourcesMap["ResearchDefinition"] = addInteraction("ResearchDefinition", "delete")
	}
	if c, ok := w.Concrete.(ResearchDefinitionUpdate); ok {
		r := addInteraction("ResearchDefinition", "update")
		c, ok := c.(ResearchDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesResearchDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ResearchDefinition"] = r
	}
	if c, ok := w.Concrete.(ResearchDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesResearchDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ResearchDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ResearchDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ResearchDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(ResearchElementDefinitionCreate); ok {
		resourcesMap["ResearchElementDefinition"] = addInteraction("ResearchElementDefinition", "create")
	}
	if _, ok := w.Concrete.(ResearchElementDefinitionRead); ok {
		resourcesMap["ResearchElementDefinition"] = addInteraction("ResearchElementDefinition", "read")
	}
	if _, ok := w.Concrete.(ResearchElementDefinitionDelete); ok {
		resourcesMap["ResearchElementDefinition"] = addInteraction("ResearchElementDefinition", "delete")
	}
	if c, ok := w.Concrete.(ResearchElementDefinitionUpdate); ok {
		r := addInteraction("ResearchElementDefinition", "update")
		c, ok := c.(ResearchElementDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesResearchElementDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ResearchElementDefinition"] = r
	}
	if c, ok := w.Concrete.(ResearchElementDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesResearchElementDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ResearchElementDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ResearchElementDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ResearchElementDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(ResearchStudyCreate); ok {
		resourcesMap["ResearchStudy"] = addInteraction("ResearchStudy", "create")
	}
	if _, ok := w.Concrete.(ResearchStudyRead); ok {
		resourcesMap["ResearchStudy"] = addInteraction("ResearchStudy", "read")
	}
	if _, ok := w.Concrete.(ResearchStudyDelete); ok {
		resourcesMap["ResearchStudy"] = addInteraction("ResearchStudy", "delete")
	}
	if c, ok := w.Concrete.(ResearchStudyUpdate); ok {
		r := addInteraction("ResearchStudy", "update")
		c, ok := c.(ResearchStudyUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesResearchStudy(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ResearchStudy"] = r
	}
	if c, ok := w.Concrete.(ResearchStudySearch); ok {
		c, err := c.SearchCapabilitiesResearchStudy(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ResearchStudy", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ResearchStudy-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ResearchStudy"] = r
		}
	}
	if _, ok := w.Concrete.(ResearchSubjectCreate); ok {
		resourcesMap["ResearchSubject"] = addInteraction("ResearchSubject", "create")
	}
	if _, ok := w.Concrete.(ResearchSubjectRead); ok {
		resourcesMap["ResearchSubject"] = addInteraction("ResearchSubject", "read")
	}
	if _, ok := w.Concrete.(ResearchSubjectDelete); ok {
		resourcesMap["ResearchSubject"] = addInteraction("ResearchSubject", "delete")
	}
	if c, ok := w.Concrete.(ResearchSubjectUpdate); ok {
		r := addInteraction("ResearchSubject", "update")
		c, ok := c.(ResearchSubjectUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesResearchSubject(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ResearchSubject"] = r
	}
	if c, ok := w.Concrete.(ResearchSubjectSearch); ok {
		c, err := c.SearchCapabilitiesResearchSubject(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ResearchSubject", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ResearchSubject-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ResearchSubject"] = r
		}
	}
	if _, ok := w.Concrete.(RiskAssessmentCreate); ok {
		resourcesMap["RiskAssessment"] = addInteraction("RiskAssessment", "create")
	}
	if _, ok := w.Concrete.(RiskAssessmentRead); ok {
		resourcesMap["RiskAssessment"] = addInteraction("RiskAssessment", "read")
	}
	if _, ok := w.Concrete.(RiskAssessmentDelete); ok {
		resourcesMap["RiskAssessment"] = addInteraction("RiskAssessment", "delete")
	}
	if c, ok := w.Concrete.(RiskAssessmentUpdate); ok {
		r := addInteraction("RiskAssessment", "update")
		c, ok := c.(RiskAssessmentUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesRiskAssessment(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["RiskAssessment"] = r
	}
	if c, ok := w.Concrete.(RiskAssessmentSearch); ok {
		c, err := c.SearchCapabilitiesRiskAssessment(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("RiskAssessment", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("RiskAssessment-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["RiskAssessment"] = r
		}
	}
	if _, ok := w.Concrete.(ScheduleCreate); ok {
		resourcesMap["Schedule"] = addInteraction("Schedule", "create")
	}
	if _, ok := w.Concrete.(ScheduleRead); ok {
		resourcesMap["Schedule"] = addInteraction("Schedule", "read")
	}
	if _, ok := w.Concrete.(ScheduleDelete); ok {
		resourcesMap["Schedule"] = addInteraction("Schedule", "delete")
	}
	if c, ok := w.Concrete.(ScheduleUpdate); ok {
		r := addInteraction("Schedule", "update")
		c, ok := c.(ScheduleUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSchedule(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Schedule"] = r
	}
	if c, ok := w.Concrete.(ScheduleSearch); ok {
		c, err := c.SearchCapabilitiesSchedule(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Schedule", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Schedule-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Schedule"] = r
		}
	}
	if _, ok := w.Concrete.(SearchParameterCreate); ok {
		resourcesMap["SearchParameter"] = addInteraction("SearchParameter", "create")
	}
	if _, ok := w.Concrete.(SearchParameterRead); ok {
		resourcesMap["SearchParameter"] = addInteraction("SearchParameter", "read")
	}
	if _, ok := w.Concrete.(SearchParameterDelete); ok {
		resourcesMap["SearchParameter"] = addInteraction("SearchParameter", "delete")
	}
	if c, ok := w.Concrete.(SearchParameterUpdate); ok {
		r := addInteraction("SearchParameter", "update")
		c, ok := c.(SearchParameterUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSearchParameter(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SearchParameter"] = r
	}
	if c, ok := w.Concrete.(SearchParameterSearch); ok {
		c, err := c.SearchCapabilitiesSearchParameter(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SearchParameter", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SearchParameter-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SearchParameter"] = r
		}
	}
	if _, ok := w.Concrete.(ServiceRequestCreate); ok {
		resourcesMap["ServiceRequest"] = addInteraction("ServiceRequest", "create")
	}
	if _, ok := w.Concrete.(ServiceRequestRead); ok {
		resourcesMap["ServiceRequest"] = addInteraction("ServiceRequest", "read")
	}
	if _, ok := w.Concrete.(ServiceRequestDelete); ok {
		resourcesMap["ServiceRequest"] = addInteraction("ServiceRequest", "delete")
	}
	if c, ok := w.Concrete.(ServiceRequestUpdate); ok {
		r := addInteraction("ServiceRequest", "update")
		c, ok := c.(ServiceRequestUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesServiceRequest(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ServiceRequest"] = r
	}
	if c, ok := w.Concrete.(ServiceRequestSearch); ok {
		c, err := c.SearchCapabilitiesServiceRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ServiceRequest", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ServiceRequest-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ServiceRequest"] = r
		}
	}
	if _, ok := w.Concrete.(SlotCreate); ok {
		resourcesMap["Slot"] = addInteraction("Slot", "create")
	}
	if _, ok := w.Concrete.(SlotRead); ok {
		resourcesMap["Slot"] = addInteraction("Slot", "read")
	}
	if _, ok := w.Concrete.(SlotDelete); ok {
		resourcesMap["Slot"] = addInteraction("Slot", "delete")
	}
	if c, ok := w.Concrete.(SlotUpdate); ok {
		r := addInteraction("Slot", "update")
		c, ok := c.(SlotUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSlot(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Slot"] = r
	}
	if c, ok := w.Concrete.(SlotSearch); ok {
		c, err := c.SearchCapabilitiesSlot(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Slot", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Slot-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Slot"] = r
		}
	}
	if _, ok := w.Concrete.(SpecimenCreate); ok {
		resourcesMap["Specimen"] = addInteraction("Specimen", "create")
	}
	if _, ok := w.Concrete.(SpecimenRead); ok {
		resourcesMap["Specimen"] = addInteraction("Specimen", "read")
	}
	if _, ok := w.Concrete.(SpecimenDelete); ok {
		resourcesMap["Specimen"] = addInteraction("Specimen", "delete")
	}
	if c, ok := w.Concrete.(SpecimenUpdate); ok {
		r := addInteraction("Specimen", "update")
		c, ok := c.(SpecimenUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSpecimen(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Specimen"] = r
	}
	if c, ok := w.Concrete.(SpecimenSearch); ok {
		c, err := c.SearchCapabilitiesSpecimen(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Specimen", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Specimen-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Specimen"] = r
		}
	}
	if _, ok := w.Concrete.(SpecimenDefinitionCreate); ok {
		resourcesMap["SpecimenDefinition"] = addInteraction("SpecimenDefinition", "create")
	}
	if _, ok := w.Concrete.(SpecimenDefinitionRead); ok {
		resourcesMap["SpecimenDefinition"] = addInteraction("SpecimenDefinition", "read")
	}
	if _, ok := w.Concrete.(SpecimenDefinitionDelete); ok {
		resourcesMap["SpecimenDefinition"] = addInteraction("SpecimenDefinition", "delete")
	}
	if c, ok := w.Concrete.(SpecimenDefinitionUpdate); ok {
		r := addInteraction("SpecimenDefinition", "update")
		c, ok := c.(SpecimenDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSpecimenDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SpecimenDefinition"] = r
	}
	if c, ok := w.Concrete.(SpecimenDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesSpecimenDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SpecimenDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SpecimenDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SpecimenDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(StructureDefinitionCreate); ok {
		resourcesMap["StructureDefinition"] = addInteraction("StructureDefinition", "create")
	}
	if _, ok := w.Concrete.(StructureDefinitionRead); ok {
		resourcesMap["StructureDefinition"] = addInteraction("StructureDefinition", "read")
	}
	if _, ok := w.Concrete.(StructureDefinitionDelete); ok {
		resourcesMap["StructureDefinition"] = addInteraction("StructureDefinition", "delete")
	}
	if c, ok := w.Concrete.(StructureDefinitionUpdate); ok {
		r := addInteraction("StructureDefinition", "update")
		c, ok := c.(StructureDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesStructureDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["StructureDefinition"] = r
	}
	if c, ok := w.Concrete.(StructureDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesStructureDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("StructureDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("StructureDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["StructureDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(StructureMapCreate); ok {
		resourcesMap["StructureMap"] = addInteraction("StructureMap", "create")
	}
	if _, ok := w.Concrete.(StructureMapRead); ok {
		resourcesMap["StructureMap"] = addInteraction("StructureMap", "read")
	}
	if _, ok := w.Concrete.(StructureMapDelete); ok {
		resourcesMap["StructureMap"] = addInteraction("StructureMap", "delete")
	}
	if c, ok := w.Concrete.(StructureMapUpdate); ok {
		r := addInteraction("StructureMap", "update")
		c, ok := c.(StructureMapUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesStructureMap(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["StructureMap"] = r
	}
	if c, ok := w.Concrete.(StructureMapSearch); ok {
		c, err := c.SearchCapabilitiesStructureMap(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("StructureMap", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("StructureMap-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["StructureMap"] = r
		}
	}
	if _, ok := w.Concrete.(SubscriptionCreate); ok {
		resourcesMap["Subscription"] = addInteraction("Subscription", "create")
	}
	if _, ok := w.Concrete.(SubscriptionRead); ok {
		resourcesMap["Subscription"] = addInteraction("Subscription", "read")
	}
	if _, ok := w.Concrete.(SubscriptionDelete); ok {
		resourcesMap["Subscription"] = addInteraction("Subscription", "delete")
	}
	if c, ok := w.Concrete.(SubscriptionUpdate); ok {
		r := addInteraction("Subscription", "update")
		c, ok := c.(SubscriptionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSubscription(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Subscription"] = r
	}
	if c, ok := w.Concrete.(SubscriptionSearch); ok {
		c, err := c.SearchCapabilitiesSubscription(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Subscription", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Subscription-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Subscription"] = r
		}
	}
	if _, ok := w.Concrete.(SubscriptionStatusCreate); ok {
		resourcesMap["SubscriptionStatus"] = addInteraction("SubscriptionStatus", "create")
	}
	if _, ok := w.Concrete.(SubscriptionStatusRead); ok {
		resourcesMap["SubscriptionStatus"] = addInteraction("SubscriptionStatus", "read")
	}
	if _, ok := w.Concrete.(SubscriptionStatusDelete); ok {
		resourcesMap["SubscriptionStatus"] = addInteraction("SubscriptionStatus", "delete")
	}
	if c, ok := w.Concrete.(SubscriptionStatusUpdate); ok {
		r := addInteraction("SubscriptionStatus", "update")
		c, ok := c.(SubscriptionStatusUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSubscriptionStatus(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SubscriptionStatus"] = r
	}
	if c, ok := w.Concrete.(SubscriptionStatusSearch); ok {
		c, err := c.SearchCapabilitiesSubscriptionStatus(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SubscriptionStatus", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SubscriptionStatus-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SubscriptionStatus"] = r
		}
	}
	if _, ok := w.Concrete.(SubscriptionTopicCreate); ok {
		resourcesMap["SubscriptionTopic"] = addInteraction("SubscriptionTopic", "create")
	}
	if _, ok := w.Concrete.(SubscriptionTopicRead); ok {
		resourcesMap["SubscriptionTopic"] = addInteraction("SubscriptionTopic", "read")
	}
	if _, ok := w.Concrete.(SubscriptionTopicDelete); ok {
		resourcesMap["SubscriptionTopic"] = addInteraction("SubscriptionTopic", "delete")
	}
	if c, ok := w.Concrete.(SubscriptionTopicUpdate); ok {
		r := addInteraction("SubscriptionTopic", "update")
		c, ok := c.(SubscriptionTopicUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSubscriptionTopic(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SubscriptionTopic"] = r
	}
	if c, ok := w.Concrete.(SubscriptionTopicSearch); ok {
		c, err := c.SearchCapabilitiesSubscriptionTopic(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SubscriptionTopic", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SubscriptionTopic-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SubscriptionTopic"] = r
		}
	}
	if _, ok := w.Concrete.(SubstanceCreate); ok {
		resourcesMap["Substance"] = addInteraction("Substance", "create")
	}
	if _, ok := w.Concrete.(SubstanceRead); ok {
		resourcesMap["Substance"] = addInteraction("Substance", "read")
	}
	if _, ok := w.Concrete.(SubstanceDelete); ok {
		resourcesMap["Substance"] = addInteraction("Substance", "delete")
	}
	if c, ok := w.Concrete.(SubstanceUpdate); ok {
		r := addInteraction("Substance", "update")
		c, ok := c.(SubstanceUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSubstance(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Substance"] = r
	}
	if c, ok := w.Concrete.(SubstanceSearch); ok {
		c, err := c.SearchCapabilitiesSubstance(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Substance", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Substance-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Substance"] = r
		}
	}
	if _, ok := w.Concrete.(SubstanceDefinitionCreate); ok {
		resourcesMap["SubstanceDefinition"] = addInteraction("SubstanceDefinition", "create")
	}
	if _, ok := w.Concrete.(SubstanceDefinitionRead); ok {
		resourcesMap["SubstanceDefinition"] = addInteraction("SubstanceDefinition", "read")
	}
	if _, ok := w.Concrete.(SubstanceDefinitionDelete); ok {
		resourcesMap["SubstanceDefinition"] = addInteraction("SubstanceDefinition", "delete")
	}
	if c, ok := w.Concrete.(SubstanceDefinitionUpdate); ok {
		r := addInteraction("SubstanceDefinition", "update")
		c, ok := c.(SubstanceDefinitionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSubstanceDefinition(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SubstanceDefinition"] = r
	}
	if c, ok := w.Concrete.(SubstanceDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesSubstanceDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SubstanceDefinition", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SubstanceDefinition-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SubstanceDefinition"] = r
		}
	}
	if _, ok := w.Concrete.(SupplyDeliveryCreate); ok {
		resourcesMap["SupplyDelivery"] = addInteraction("SupplyDelivery", "create")
	}
	if _, ok := w.Concrete.(SupplyDeliveryRead); ok {
		resourcesMap["SupplyDelivery"] = addInteraction("SupplyDelivery", "read")
	}
	if _, ok := w.Concrete.(SupplyDeliveryDelete); ok {
		resourcesMap["SupplyDelivery"] = addInteraction("SupplyDelivery", "delete")
	}
	if c, ok := w.Concrete.(SupplyDeliveryUpdate); ok {
		r := addInteraction("SupplyDelivery", "update")
		c, ok := c.(SupplyDeliveryUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSupplyDelivery(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SupplyDelivery"] = r
	}
	if c, ok := w.Concrete.(SupplyDeliverySearch); ok {
		c, err := c.SearchCapabilitiesSupplyDelivery(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SupplyDelivery", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SupplyDelivery-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SupplyDelivery"] = r
		}
	}
	if _, ok := w.Concrete.(SupplyRequestCreate); ok {
		resourcesMap["SupplyRequest"] = addInteraction("SupplyRequest", "create")
	}
	if _, ok := w.Concrete.(SupplyRequestRead); ok {
		resourcesMap["SupplyRequest"] = addInteraction("SupplyRequest", "read")
	}
	if _, ok := w.Concrete.(SupplyRequestDelete); ok {
		resourcesMap["SupplyRequest"] = addInteraction("SupplyRequest", "delete")
	}
	if c, ok := w.Concrete.(SupplyRequestUpdate); ok {
		r := addInteraction("SupplyRequest", "update")
		c, ok := c.(SupplyRequestUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesSupplyRequest(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["SupplyRequest"] = r
	}
	if c, ok := w.Concrete.(SupplyRequestSearch); ok {
		c, err := c.SearchCapabilitiesSupplyRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("SupplyRequest", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("SupplyRequest-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["SupplyRequest"] = r
		}
	}
	if _, ok := w.Concrete.(TaskCreate); ok {
		resourcesMap["Task"] = addInteraction("Task", "create")
	}
	if _, ok := w.Concrete.(TaskRead); ok {
		resourcesMap["Task"] = addInteraction("Task", "read")
	}
	if _, ok := w.Concrete.(TaskDelete); ok {
		resourcesMap["Task"] = addInteraction("Task", "delete")
	}
	if c, ok := w.Concrete.(TaskUpdate); ok {
		r := addInteraction("Task", "update")
		c, ok := c.(TaskUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesTask(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["Task"] = r
	}
	if c, ok := w.Concrete.(TaskSearch); ok {
		c, err := c.SearchCapabilitiesTask(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("Task", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("Task-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["Task"] = r
		}
	}
	if _, ok := w.Concrete.(TerminologyCapabilitiesCreate); ok {
		resourcesMap["TerminologyCapabilities"] = addInteraction("TerminologyCapabilities", "create")
	}
	if _, ok := w.Concrete.(TerminologyCapabilitiesRead); ok {
		resourcesMap["TerminologyCapabilities"] = addInteraction("TerminologyCapabilities", "read")
	}
	if _, ok := w.Concrete.(TerminologyCapabilitiesDelete); ok {
		resourcesMap["TerminologyCapabilities"] = addInteraction("TerminologyCapabilities", "delete")
	}
	if c, ok := w.Concrete.(TerminologyCapabilitiesUpdate); ok {
		r := addInteraction("TerminologyCapabilities", "update")
		c, ok := c.(TerminologyCapabilitiesUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesTerminologyCapabilities(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["TerminologyCapabilities"] = r
	}
	if c, ok := w.Concrete.(TerminologyCapabilitiesSearch); ok {
		c, err := c.SearchCapabilitiesTerminologyCapabilities(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("TerminologyCapabilities", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("TerminologyCapabilities-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["TerminologyCapabilities"] = r
		}
	}
	if _, ok := w.Concrete.(TestReportCreate); ok {
		resourcesMap["TestReport"] = addInteraction("TestReport", "create")
	}
	if _, ok := w.Concrete.(TestReportRead); ok {
		resourcesMap["TestReport"] = addInteraction("TestReport", "read")
	}
	if _, ok := w.Concrete.(TestReportDelete); ok {
		resourcesMap["TestReport"] = addInteraction("TestReport", "delete")
	}
	if c, ok := w.Concrete.(TestReportUpdate); ok {
		r := addInteraction("TestReport", "update")
		c, ok := c.(TestReportUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesTestReport(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["TestReport"] = r
	}
	if c, ok := w.Concrete.(TestReportSearch); ok {
		c, err := c.SearchCapabilitiesTestReport(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("TestReport", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("TestReport-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["TestReport"] = r
		}
	}
	if _, ok := w.Concrete.(TestScriptCreate); ok {
		resourcesMap["TestScript"] = addInteraction("TestScript", "create")
	}
	if _, ok := w.Concrete.(TestScriptRead); ok {
		resourcesMap["TestScript"] = addInteraction("TestScript", "read")
	}
	if _, ok := w.Concrete.(TestScriptDelete); ok {
		resourcesMap["TestScript"] = addInteraction("TestScript", "delete")
	}
	if c, ok := w.Concrete.(TestScriptUpdate); ok {
		r := addInteraction("TestScript", "update")
		c, ok := c.(TestScriptUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesTestScript(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["TestScript"] = r
	}
	if c, ok := w.Concrete.(TestScriptSearch); ok {
		c, err := c.SearchCapabilitiesTestScript(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("TestScript", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("TestScript-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["TestScript"] = r
		}
	}
	if _, ok := w.Concrete.(ValueSetCreate); ok {
		resourcesMap["ValueSet"] = addInteraction("ValueSet", "create")
	}
	if _, ok := w.Concrete.(ValueSetRead); ok {
		resourcesMap["ValueSet"] = addInteraction("ValueSet", "read")
	}
	if _, ok := w.Concrete.(ValueSetDelete); ok {
		resourcesMap["ValueSet"] = addInteraction("ValueSet", "delete")
	}
	if c, ok := w.Concrete.(ValueSetUpdate); ok {
		r := addInteraction("ValueSet", "update")
		c, ok := c.(ValueSetUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesValueSet(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["ValueSet"] = r
	}
	if c, ok := w.Concrete.(ValueSetSearch); ok {
		c, err := c.SearchCapabilitiesValueSet(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("ValueSet", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("ValueSet-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["ValueSet"] = r
		}
	}
	if _, ok := w.Concrete.(VerificationResultCreate); ok {
		resourcesMap["VerificationResult"] = addInteraction("VerificationResult", "create")
	}
	if _, ok := w.Concrete.(VerificationResultRead); ok {
		resourcesMap["VerificationResult"] = addInteraction("VerificationResult", "read")
	}
	if _, ok := w.Concrete.(VerificationResultDelete); ok {
		resourcesMap["VerificationResult"] = addInteraction("VerificationResult", "delete")
	}
	if c, ok := w.Concrete.(VerificationResultUpdate); ok {
		r := addInteraction("VerificationResult", "update")
		c, ok := c.(VerificationResultUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesVerificationResult(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["VerificationResult"] = r
	}
	if c, ok := w.Concrete.(VerificationResultSearch); ok {
		c, err := c.SearchCapabilitiesVerificationResult(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("VerificationResult", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("VerificationResult-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["VerificationResult"] = r
		}
	}
	if _, ok := w.Concrete.(VisionPrescriptionCreate); ok {
		resourcesMap["VisionPrescription"] = addInteraction("VisionPrescription", "create")
	}
	if _, ok := w.Concrete.(VisionPrescriptionRead); ok {
		resourcesMap["VisionPrescription"] = addInteraction("VisionPrescription", "read")
	}
	if _, ok := w.Concrete.(VisionPrescriptionDelete); ok {
		resourcesMap["VisionPrescription"] = addInteraction("VisionPrescription", "delete")
	}
	if c, ok := w.Concrete.(VisionPrescriptionUpdate); ok {
		r := addInteraction("VisionPrescription", "update")
		c, ok := c.(VisionPrescriptionUpdateCapabilities)
		if ok {
			c, err := c.UpdateCapabilitiesVisionPrescription(ctx)
			if err != nil {
				errs = append(errs, err)
			} else {
				r.UpdateCreate = &r4b.Boolean{Value: ptr.To(c.UpdateCreate)}
			}
		}
		resourcesMap["VisionPrescription"] = r
	}
	if c, ok := w.Concrete.(VisionPrescriptionSearch); ok {
		c, err := c.SearchCapabilitiesVisionPrescription(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			r := addInteraction("VisionPrescription", "search-type")
			for _, include := range c.Includes {
				r.SearchInclude = append(r.SearchInclude, r4b.String{Value: &include})
			}
			for n, p := range c.Parameters {
				fhirpathType, ok, err := fhirpath.Singleton[fhirpath.String](p.Children("type"))
				if !ok || err != nil {
					continue
				}
				resolvedType := string(fhirpathType)
				var definition *r4b.Canonical
				if baseUrl != "" {
					searchParameterId := ""
					fhirpathId, idOk, idErr := fhirpath.Singleton[fhirpath.String](p.Children("id"))
					if idOk && idErr == nil {
						searchParameterId = string(fhirpathId)
					} else {
						// If no explicit ID is set, create one of pattern {resourceType}-{name}
						searchParameterId = sanitizeIdentifier("VisionPrescription-" + n)
					}
					canonicalUrl := baseUrl + "/SearchParameter/" + searchParameterId
					definition = &r4b.Canonical{Value: &canonicalUrl}
				}
				r.SearchParam = append(r.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
					Definition: definition,
					Name:       r4b.String{Value: &n},
					Type:       r4b.Code{Value: &resolvedType},
				})
			}
			resourcesMap["VisionPrescription"] = r
		}
	}
	if _, ok := w.Concrete.(SearchParameterSearch); !ok {
		resourcesMap["SearchParameter"] = addInteraction("SearchParameter", "read")
		spResource := addInteraction("SearchParameter", "search-type")
		idParam := "_id"
		tokenType := "token"
		idDefinition := baseUrl + "/SearchParameter/SearchParameter-id"
		spResource.SearchParam = append(spResource.SearchParam, r4b.CapabilityStatementRestResourceSearchParam{
			Definition: &r4b.Canonical{Value: &idDefinition},
			Name:       r4b.String{Value: &idParam},
			Type:       r4b.Code{Value: &tokenType},
		})
		resourcesMap["SearchParameter"] = spResource
	}
	if len(errs) > 0 {
		return r4b.CapabilityStatement{}, errors.Join(errs...)
	}
	capabilityStatement := baseCapabilityStatement
	if capabilityStatement.FhirVersion.Value == nil {
		capabilityStatement.FhirVersion = r4b.Code{Value: ptr.To("4.3")}
	}
	if len(capabilityStatement.Rest) == 0 {
		capabilityStatement.Rest = []r4b.CapabilityStatementRest{{Mode: r4b.Code{Value: ptr.To("server")}}}
	}
	defs := operationDefinitionsByCode(ctx, w.Concrete)
	var sysOps []r4b.CapabilityStatementRestResourceOperation
	for code, entry := range defs {
		id := code
		if entry.Def.Id != nil && entry.Def.Id.Value != nil {
			id = *entry.Def.Id.Value
		}
		canonical := baseUrl + "/OperationDefinition/" + id
		if entry.Def.System.Value != nil && *entry.Def.System.Value {
			sysOps = append(sysOps, r4b.CapabilityStatementRestResourceOperation{
				Definition: r4b.Canonical{Value: &canonical},
				Name:       r4b.String{Value: &code},
			})
		}
		for _, rt := range entry.Def.Resource {
			if rt.Value == nil {
				continue
			}
			rtype := *rt.Value
			r, ok := resourcesMap[rtype]
			if !ok {
				r = r4b.CapabilityStatementRestResource{Type: r4b.Code{Value: &rtype}}
			}
			r.Operation = append(r.Operation, r4b.CapabilityStatementRestResourceOperation{
				Definition: r4b.Canonical{Value: &canonical},
				Name:       r4b.String{Value: &code},
			})
			resourcesMap[rtype] = r
		}
	}
	capabilityStatement.Rest[0].Operation = sysOps
	resourcesList := make([]r4b.CapabilityStatementRestResource, 0, len(resourcesMap))
	for _, r := range resourcesMap {
		slices.SortStableFunc(r.SearchParam, func(a, b r4b.CapabilityStatementRestResourceSearchParam) int {
			return cmp.Compare(*a.Name.Value, *b.Name.Value)
		})
		slices.SortStableFunc(r.Interaction, func(a, b r4b.CapabilityStatementRestResourceInteraction) int {
			order := map[string]int{
				"create":      1,
				"delete":      4,
				"read":        2,
				"search-type": 5,
				"update":      3,
			}
			aCode := ""
			if a.Code.Value != nil {
				aCode = *a.Code.Value
			}
			bCode := ""
			if b.Code.Value != nil {
				bCode = *b.Code.Value
			}
			return cmp.Compare(order[aCode], order[bCode])
		})
		slices.SortStableFunc(r.Operation, func(a, b r4b.CapabilityStatementRestResourceOperation) int {
			return cmp.Compare(*a.Name.Value, *b.Name.Value)
		})
		resourcesList = append(resourcesList, r)
	}
	slices.SortFunc(resourcesList, func(a, b r4b.CapabilityStatementRestResource) int {
		return cmp.Compare(*a.Type.Value, *b.Type.Value)
	})
	capabilityStatement.Rest[0].Resource = resourcesList
	return capabilityStatement, nil
}
func searchParameters(ctx context.Context, api any, baseUrl string) (map[string]r4b.SearchParameter, error) {
	searchParameters := make(map[string]r4b.SearchParameter)
	var errs []error
	if c, ok := api.(AccountSearch); ok {
		c, err := c.SearchCapabilitiesAccount(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Account", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Account"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ActivityDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesActivityDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ActivityDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ActivityDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(AdministrableProductDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesAdministrableProductDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "AdministrableProductDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["AdministrableProductDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(AdverseEventSearch); ok {
		c, err := c.SearchCapabilitiesAdverseEvent(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "AdverseEvent", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["AdverseEvent"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(AllergyIntoleranceSearch); ok {
		c, err := c.SearchCapabilitiesAllergyIntolerance(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "AllergyIntolerance", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["AllergyIntolerance"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(AppointmentSearch); ok {
		c, err := c.SearchCapabilitiesAppointment(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Appointment", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Appointment"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(AppointmentResponseSearch); ok {
		c, err := c.SearchCapabilitiesAppointmentResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "AppointmentResponse", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["AppointmentResponse"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(AuditEventSearch); ok {
		c, err := c.SearchCapabilitiesAuditEvent(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "AuditEvent", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["AuditEvent"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(BasicSearch); ok {
		c, err := c.SearchCapabilitiesBasic(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Basic", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Basic"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(BinarySearch); ok {
		c, err := c.SearchCapabilitiesBinary(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Binary", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Binary"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(BiologicallyDerivedProductSearch); ok {
		c, err := c.SearchCapabilitiesBiologicallyDerivedProduct(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "BiologicallyDerivedProduct", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["BiologicallyDerivedProduct"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(BodyStructureSearch); ok {
		c, err := c.SearchCapabilitiesBodyStructure(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "BodyStructure", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["BodyStructure"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(BundleSearch); ok {
		c, err := c.SearchCapabilitiesBundle(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Bundle", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Bundle"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CapabilityStatementSearch); ok {
		c, err := c.SearchCapabilitiesCapabilityStatement(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "CapabilityStatement", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["CapabilityStatement"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CarePlanSearch); ok {
		c, err := c.SearchCapabilitiesCarePlan(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "CarePlan", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["CarePlan"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CareTeamSearch); ok {
		c, err := c.SearchCapabilitiesCareTeam(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "CareTeam", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["CareTeam"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CatalogEntrySearch); ok {
		c, err := c.SearchCapabilitiesCatalogEntry(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "CatalogEntry", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["CatalogEntry"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ChargeItemSearch); ok {
		c, err := c.SearchCapabilitiesChargeItem(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ChargeItem", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ChargeItem"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ChargeItemDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesChargeItemDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ChargeItemDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ChargeItemDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CitationSearch); ok {
		c, err := c.SearchCapabilitiesCitation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Citation", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Citation"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ClaimSearch); ok {
		c, err := c.SearchCapabilitiesClaim(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Claim", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Claim"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ClaimResponseSearch); ok {
		c, err := c.SearchCapabilitiesClaimResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ClaimResponse", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ClaimResponse"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ClinicalImpressionSearch); ok {
		c, err := c.SearchCapabilitiesClinicalImpression(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ClinicalImpression", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ClinicalImpression"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ClinicalUseDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesClinicalUseDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ClinicalUseDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ClinicalUseDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CodeSystemSearch); ok {
		c, err := c.SearchCapabilitiesCodeSystem(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "CodeSystem", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["CodeSystem"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CommunicationSearch); ok {
		c, err := c.SearchCapabilitiesCommunication(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Communication", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Communication"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CommunicationRequestSearch); ok {
		c, err := c.SearchCapabilitiesCommunicationRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "CommunicationRequest", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["CommunicationRequest"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CompartmentDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesCompartmentDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "CompartmentDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["CompartmentDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CompositionSearch); ok {
		c, err := c.SearchCapabilitiesComposition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Composition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Composition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ConceptMapSearch); ok {
		c, err := c.SearchCapabilitiesConceptMap(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ConceptMap", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ConceptMap"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ConditionSearch); ok {
		c, err := c.SearchCapabilitiesCondition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Condition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Condition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ConsentSearch); ok {
		c, err := c.SearchCapabilitiesConsent(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Consent", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Consent"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ContractSearch); ok {
		c, err := c.SearchCapabilitiesContract(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Contract", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Contract"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CoverageSearch); ok {
		c, err := c.SearchCapabilitiesCoverage(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Coverage", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Coverage"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CoverageEligibilityRequestSearch); ok {
		c, err := c.SearchCapabilitiesCoverageEligibilityRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "CoverageEligibilityRequest", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["CoverageEligibilityRequest"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(CoverageEligibilityResponseSearch); ok {
		c, err := c.SearchCapabilitiesCoverageEligibilityResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "CoverageEligibilityResponse", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["CoverageEligibilityResponse"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DetectedIssueSearch); ok {
		c, err := c.SearchCapabilitiesDetectedIssue(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "DetectedIssue", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["DetectedIssue"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DeviceSearch); ok {
		c, err := c.SearchCapabilitiesDevice(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Device", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Device"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DeviceDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesDeviceDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "DeviceDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["DeviceDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DeviceMetricSearch); ok {
		c, err := c.SearchCapabilitiesDeviceMetric(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "DeviceMetric", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["DeviceMetric"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DeviceRequestSearch); ok {
		c, err := c.SearchCapabilitiesDeviceRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "DeviceRequest", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["DeviceRequest"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DeviceUseStatementSearch); ok {
		c, err := c.SearchCapabilitiesDeviceUseStatement(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "DeviceUseStatement", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["DeviceUseStatement"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DiagnosticReportSearch); ok {
		c, err := c.SearchCapabilitiesDiagnosticReport(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "DiagnosticReport", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["DiagnosticReport"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DocumentManifestSearch); ok {
		c, err := c.SearchCapabilitiesDocumentManifest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "DocumentManifest", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["DocumentManifest"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(DocumentReferenceSearch); ok {
		c, err := c.SearchCapabilitiesDocumentReference(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "DocumentReference", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["DocumentReference"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EncounterSearch); ok {
		c, err := c.SearchCapabilitiesEncounter(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Encounter", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Encounter"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EndpointSearch); ok {
		c, err := c.SearchCapabilitiesEndpoint(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Endpoint", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Endpoint"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EnrollmentRequestSearch); ok {
		c, err := c.SearchCapabilitiesEnrollmentRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "EnrollmentRequest", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["EnrollmentRequest"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EnrollmentResponseSearch); ok {
		c, err := c.SearchCapabilitiesEnrollmentResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "EnrollmentResponse", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["EnrollmentResponse"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EpisodeOfCareSearch); ok {
		c, err := c.SearchCapabilitiesEpisodeOfCare(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "EpisodeOfCare", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["EpisodeOfCare"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EventDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesEventDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "EventDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["EventDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EvidenceSearch); ok {
		c, err := c.SearchCapabilitiesEvidence(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Evidence", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Evidence"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EvidenceReportSearch); ok {
		c, err := c.SearchCapabilitiesEvidenceReport(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "EvidenceReport", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["EvidenceReport"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(EvidenceVariableSearch); ok {
		c, err := c.SearchCapabilitiesEvidenceVariable(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "EvidenceVariable", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["EvidenceVariable"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ExampleScenarioSearch); ok {
		c, err := c.SearchCapabilitiesExampleScenario(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ExampleScenario", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ExampleScenario"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ExplanationOfBenefitSearch); ok {
		c, err := c.SearchCapabilitiesExplanationOfBenefit(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ExplanationOfBenefit", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ExplanationOfBenefit"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(FamilyMemberHistorySearch); ok {
		c, err := c.SearchCapabilitiesFamilyMemberHistory(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "FamilyMemberHistory", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["FamilyMemberHistory"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(FlagSearch); ok {
		c, err := c.SearchCapabilitiesFlag(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Flag", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Flag"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(GoalSearch); ok {
		c, err := c.SearchCapabilitiesGoal(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Goal", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Goal"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(GraphDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesGraphDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "GraphDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["GraphDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(GroupSearch); ok {
		c, err := c.SearchCapabilitiesGroup(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Group", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Group"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(GuidanceResponseSearch); ok {
		c, err := c.SearchCapabilitiesGuidanceResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "GuidanceResponse", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["GuidanceResponse"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(HealthcareServiceSearch); ok {
		c, err := c.SearchCapabilitiesHealthcareService(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "HealthcareService", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["HealthcareService"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ImagingStudySearch); ok {
		c, err := c.SearchCapabilitiesImagingStudy(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ImagingStudy", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ImagingStudy"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ImmunizationSearch); ok {
		c, err := c.SearchCapabilitiesImmunization(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Immunization", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Immunization"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ImmunizationEvaluationSearch); ok {
		c, err := c.SearchCapabilitiesImmunizationEvaluation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ImmunizationEvaluation", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ImmunizationEvaluation"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ImmunizationRecommendationSearch); ok {
		c, err := c.SearchCapabilitiesImmunizationRecommendation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ImmunizationRecommendation", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ImmunizationRecommendation"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ImplementationGuideSearch); ok {
		c, err := c.SearchCapabilitiesImplementationGuide(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ImplementationGuide", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ImplementationGuide"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(IngredientSearch); ok {
		c, err := c.SearchCapabilitiesIngredient(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Ingredient", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Ingredient"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(InsurancePlanSearch); ok {
		c, err := c.SearchCapabilitiesInsurancePlan(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "InsurancePlan", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["InsurancePlan"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(InvoiceSearch); ok {
		c, err := c.SearchCapabilitiesInvoice(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Invoice", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Invoice"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(LibrarySearch); ok {
		c, err := c.SearchCapabilitiesLibrary(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Library", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Library"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(LinkageSearch); ok {
		c, err := c.SearchCapabilitiesLinkage(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Linkage", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Linkage"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ListSearch); ok {
		c, err := c.SearchCapabilitiesList(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "List", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["List"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(LocationSearch); ok {
		c, err := c.SearchCapabilitiesLocation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Location", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Location"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ManufacturedItemDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesManufacturedItemDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ManufacturedItemDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ManufacturedItemDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MeasureSearch); ok {
		c, err := c.SearchCapabilitiesMeasure(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Measure", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Measure"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MeasureReportSearch); ok {
		c, err := c.SearchCapabilitiesMeasureReport(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MeasureReport", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MeasureReport"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MediaSearch); ok {
		c, err := c.SearchCapabilitiesMedia(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Media", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Media"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicationSearch); ok {
		c, err := c.SearchCapabilitiesMedication(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Medication", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Medication"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicationAdministrationSearch); ok {
		c, err := c.SearchCapabilitiesMedicationAdministration(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MedicationAdministration", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MedicationAdministration"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicationDispenseSearch); ok {
		c, err := c.SearchCapabilitiesMedicationDispense(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MedicationDispense", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MedicationDispense"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicationKnowledgeSearch); ok {
		c, err := c.SearchCapabilitiesMedicationKnowledge(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MedicationKnowledge", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MedicationKnowledge"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicationRequestSearch); ok {
		c, err := c.SearchCapabilitiesMedicationRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MedicationRequest", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MedicationRequest"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicationStatementSearch); ok {
		c, err := c.SearchCapabilitiesMedicationStatement(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MedicationStatement", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MedicationStatement"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MedicinalProductDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesMedicinalProductDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MedicinalProductDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MedicinalProductDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MessageDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesMessageDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MessageDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MessageDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MessageHeaderSearch); ok {
		c, err := c.SearchCapabilitiesMessageHeader(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MessageHeader", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MessageHeader"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(MolecularSequenceSearch); ok {
		c, err := c.SearchCapabilitiesMolecularSequence(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "MolecularSequence", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["MolecularSequence"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(NamingSystemSearch); ok {
		c, err := c.SearchCapabilitiesNamingSystem(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "NamingSystem", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["NamingSystem"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(NutritionOrderSearch); ok {
		c, err := c.SearchCapabilitiesNutritionOrder(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "NutritionOrder", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["NutritionOrder"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(NutritionProductSearch); ok {
		c, err := c.SearchCapabilitiesNutritionProduct(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "NutritionProduct", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["NutritionProduct"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ObservationSearch); ok {
		c, err := c.SearchCapabilitiesObservation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Observation", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Observation"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ObservationDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesObservationDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ObservationDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ObservationDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(OperationDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesOperationDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "OperationDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["OperationDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(OperationOutcomeSearch); ok {
		c, err := c.SearchCapabilitiesOperationOutcome(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "OperationOutcome", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["OperationOutcome"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(OrganizationSearch); ok {
		c, err := c.SearchCapabilitiesOrganization(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Organization", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Organization"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(OrganizationAffiliationSearch); ok {
		c, err := c.SearchCapabilitiesOrganizationAffiliation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "OrganizationAffiliation", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["OrganizationAffiliation"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(PackagedProductDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesPackagedProductDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "PackagedProductDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["PackagedProductDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ParametersSearch); ok {
		c, err := c.SearchCapabilitiesParameters(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Parameters", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Parameters"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(PatientSearch); ok {
		c, err := c.SearchCapabilitiesPatient(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Patient", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Patient"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(PaymentNoticeSearch); ok {
		c, err := c.SearchCapabilitiesPaymentNotice(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "PaymentNotice", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["PaymentNotice"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(PaymentReconciliationSearch); ok {
		c, err := c.SearchCapabilitiesPaymentReconciliation(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "PaymentReconciliation", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["PaymentReconciliation"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(PersonSearch); ok {
		c, err := c.SearchCapabilitiesPerson(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Person", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Person"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(PlanDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesPlanDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "PlanDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["PlanDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(PractitionerSearch); ok {
		c, err := c.SearchCapabilitiesPractitioner(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Practitioner", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Practitioner"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(PractitionerRoleSearch); ok {
		c, err := c.SearchCapabilitiesPractitionerRole(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "PractitionerRole", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["PractitionerRole"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ProcedureSearch); ok {
		c, err := c.SearchCapabilitiesProcedure(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Procedure", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Procedure"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ProvenanceSearch); ok {
		c, err := c.SearchCapabilitiesProvenance(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Provenance", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Provenance"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(QuestionnaireSearch); ok {
		c, err := c.SearchCapabilitiesQuestionnaire(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Questionnaire", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Questionnaire"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(QuestionnaireResponseSearch); ok {
		c, err := c.SearchCapabilitiesQuestionnaireResponse(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "QuestionnaireResponse", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["QuestionnaireResponse"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(RegulatedAuthorizationSearch); ok {
		c, err := c.SearchCapabilitiesRegulatedAuthorization(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "RegulatedAuthorization", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["RegulatedAuthorization"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(RelatedPersonSearch); ok {
		c, err := c.SearchCapabilitiesRelatedPerson(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "RelatedPerson", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["RelatedPerson"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(RequestGroupSearch); ok {
		c, err := c.SearchCapabilitiesRequestGroup(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "RequestGroup", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["RequestGroup"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ResearchDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesResearchDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ResearchDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ResearchDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ResearchElementDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesResearchElementDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ResearchElementDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ResearchElementDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ResearchStudySearch); ok {
		c, err := c.SearchCapabilitiesResearchStudy(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ResearchStudy", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ResearchStudy"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ResearchSubjectSearch); ok {
		c, err := c.SearchCapabilitiesResearchSubject(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ResearchSubject", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ResearchSubject"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(RiskAssessmentSearch); ok {
		c, err := c.SearchCapabilitiesRiskAssessment(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "RiskAssessment", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["RiskAssessment"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ScheduleSearch); ok {
		c, err := c.SearchCapabilitiesSchedule(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Schedule", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Schedule"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SearchParameterSearch); ok {
		c, err := c.SearchCapabilitiesSearchParameter(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SearchParameter", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SearchParameter"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ServiceRequestSearch); ok {
		c, err := c.SearchCapabilitiesServiceRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ServiceRequest", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ServiceRequest"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SlotSearch); ok {
		c, err := c.SearchCapabilitiesSlot(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Slot", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Slot"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SpecimenSearch); ok {
		c, err := c.SearchCapabilitiesSpecimen(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Specimen", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Specimen"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SpecimenDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesSpecimenDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SpecimenDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SpecimenDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(StructureDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesStructureDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "StructureDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["StructureDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(StructureMapSearch); ok {
		c, err := c.SearchCapabilitiesStructureMap(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "StructureMap", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["StructureMap"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SubscriptionSearch); ok {
		c, err := c.SearchCapabilitiesSubscription(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Subscription", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Subscription"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SubscriptionStatusSearch); ok {
		c, err := c.SearchCapabilitiesSubscriptionStatus(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SubscriptionStatus", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SubscriptionStatus"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SubscriptionTopicSearch); ok {
		c, err := c.SearchCapabilitiesSubscriptionTopic(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SubscriptionTopic", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SubscriptionTopic"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SubstanceSearch); ok {
		c, err := c.SearchCapabilitiesSubstance(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Substance", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Substance"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SubstanceDefinitionSearch); ok {
		c, err := c.SearchCapabilitiesSubstanceDefinition(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SubstanceDefinition", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SubstanceDefinition"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SupplyDeliverySearch); ok {
		c, err := c.SearchCapabilitiesSupplyDelivery(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SupplyDelivery", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SupplyDelivery"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(SupplyRequestSearch); ok {
		c, err := c.SearchCapabilitiesSupplyRequest(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "SupplyRequest", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["SupplyRequest"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(TaskSearch); ok {
		c, err := c.SearchCapabilitiesTask(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "Task", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["Task"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(TerminologyCapabilitiesSearch); ok {
		c, err := c.SearchCapabilitiesTerminologyCapabilities(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "TerminologyCapabilities", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["TerminologyCapabilities"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(TestReportSearch); ok {
		c, err := c.SearchCapabilitiesTestReport(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "TestReport", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["TestReport"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(TestScriptSearch); ok {
		c, err := c.SearchCapabilitiesTestScript(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "TestScript", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["TestScript"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(ValueSetSearch); ok {
		c, err := c.SearchCapabilitiesValueSet(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "ValueSet", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["ValueSet"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(VerificationResultSearch); ok {
		c, err := c.SearchCapabilitiesVerificationResult(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "VerificationResult", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["VerificationResult"+"-"+n] = populatedParam
				}
			}
		}
	}
	if c, ok := api.(VisionPrescriptionSearch); ok {
		c, err := c.SearchCapabilitiesVisionPrescription(ctx)
		if err != nil {
			errs = append(errs, err)
		} else {
			for n, p := range c.Parameters {
				populatedParam := populateSearchParameter(p, "VisionPrescription", n, baseUrl)
				fhirpathId, ok, err := fhirpath.Singleton[fhirpath.String](populatedParam.Children("id"))
				if ok && err == nil {
					searchParameters[string(fhirpathId)] = populatedParam
				} else {
					// Fallback: use pattern {resourceType}-{name} if ID extraction fails
					searchParameters["VisionPrescription"+"-"+n] = populatedParam
				}
			}
		}
	}
	if len(errs) > 0 {
		return nil, errors.Join(errs...)
	}
	if _, ok := api.(SearchParameterSearch); !ok {
		idParam := r4b.SearchParameter{
			Base:        []r4b.Code{r4b.Code{Value: ptr.To("SearchParameter")}},
			Code:        r4b.Code{Value: ptr.To("_id")},
			Description: r4b.Markdown{Value: ptr.To("Logical id of this artifact")},
			Expression:  &r4b.String{Value: ptr.To("SearchParameter.id")},
			Id:          &r4b.Id{Value: ptr.To("SearchParameter-id")},
			Name:        r4b.String{Value: ptr.To("_id")},
			Status:      r4b.Code{Value: ptr.To("active")},
			Type:        r4b.Code{Value: ptr.To("token")},
			Url:         r4b.Uri{Value: ptr.To(baseUrl + "/SearchParameter/SearchParameter-id")},
		}
		searchParameters["SearchParameter-id"] = idParam
	}
	return searchParameters, nil
}
func sanitizeIdentifier(input string) string {
	result := strings.ReplaceAll(input, "_", "")
	return result
}
func populateSearchParameter(searchParam r4b.SearchParameter, resourceType string, paramName string, baseUrl string) r4b.SearchParameter {
	_, idOk, idErr := fhirpath.Singleton[fhirpath.String](searchParam.Children("id"))
	if !idOk || idErr != nil {
		// Set auto-generated ID using pattern {resourceType}-{name} (FHIR-compliant)
		id := sanitizeIdentifier(resourceType + "-" + paramName)
		searchParam.Id = &r4b.Id{Value: ptr.To(id)}
	}
	_, urlOk, urlErr := fhirpath.Singleton[fhirpath.String](searchParam.Children("url"))
	if !urlOk || urlErr != nil {
		// Set canonical URL using sanitized ID
		canonicalUrl := baseUrl + "/SearchParameter/" + *searchParam.Id.Value
		searchParam.Url = r4b.Uri{Value: ptr.To(canonicalUrl)}
	}
	_, nameOk, nameErr := fhirpath.Singleton[fhirpath.String](searchParam.Children("name"))
	if !nameOk || nameErr != nil {
		// Set name based on parameter name
		searchParam.Name = r4b.String{Value: ptr.To(paramName)}
	}
	_, statusOk, statusErr := fhirpath.Singleton[fhirpath.String](searchParam.Children("status"))
	if !statusOk || statusErr != nil {
		// Set default status to active
		searchParam.Status = r4b.Code{Value: ptr.To("active")}
	}
	_, codeOk, codeErr := fhirpath.Singleton[fhirpath.String](searchParam.Children("code"))
	if !codeOk || codeErr != nil {
		// Set code based on parameter name
		searchParam.Code = r4b.Code{Value: ptr.To(paramName)}
	}
	baseElements := searchParam.Children("base")
	if len(baseElements) == 0 {
		// Set base resource type
		searchParam.Base = []r4b.Code{{Value: ptr.To(resourceType)}}
	}
	_, descOk, descErr := fhirpath.Singleton[fhirpath.String](searchParam.Children("description"))
	if !descOk || descErr != nil {
		// Set default description
		description := "Search parameter " + paramName + " for " + resourceType + " resource"
		searchParam.Description = r4b.Markdown{Value: ptr.To(description)}
	}
	return searchParam
}
func operationDefinitionsByCode(ctx context.Context, api any) map[string]struct {
	Base string
	Def  r4b.OperationDefinition
} {
	defs := make(map[string]struct {
		Base string
		Def  r4b.OperationDefinition
	})
	ctxT := reflect.TypeOf((*context.Context)(nil)).Elem()
	t := reflect.TypeOf(api)
	v := reflect.ValueOf(api)
	for i := 0; i < t.NumMethod(); i++ {
		m := t.Method(i)
		name := m.Name
		if !strings.HasSuffix(name, "Definition") && !strings.HasSuffix(name, "OperationDefinition") {
			continue
		}
		mv := v.MethodByName(name)
		mt := mv.Type()
		if (mt.NumIn() != 0) && (mt.NumIn() != 1) {
			continue
		}
		if mt.NumOut() != 1 {
			continue
		}
		if mt.Out(0) != reflect.TypeOf(r4b.OperationDefinition{}) {
			continue
		}
		args := []reflect.Value{}
		if mt.NumIn() == 1 {
			if mt.In(0) != ctxT {
				continue
			}
			args = append(args, reflect.ValueOf(ctx))
		}
		out := mv.Call(args)
		od := out[0].Interface().(r4b.OperationDefinition)
		base := name
		base = strings.TrimSuffix(base, "OperationDefinition")
		base = strings.TrimSuffix(base, "Definition")
		code := strings.ToLower(base)
		if od.Code.Value != nil {
			code = strings.ToLower(*od.Code.Value)
		}
		defs[code] = struct {
			Base string
			Def  r4b.OperationDefinition
		}{
			Base: base,
			Def:  od,
		}
	}
	return defs
}
func operationDefinitionsByID(ctx context.Context, api any, baseUrl string) (map[string]r4b.OperationDefinition, error) {
	defs := make(map[string]r4b.OperationDefinition)
	ctxT := reflect.TypeOf((*context.Context)(nil)).Elem()
	t := reflect.TypeOf(api)
	v := reflect.ValueOf(api)
	for i := 0; i < t.NumMethod(); i++ {
		m := t.Method(i)
		name := m.Name
		if !strings.HasSuffix(name, "Definition") && !strings.HasSuffix(name, "OperationDefinition") {
			continue
		}
		mv := v.MethodByName(name)
		mt := mv.Type()
		if (mt.NumIn() != 0) && (mt.NumIn() != 1) {
			continue
		}
		if mt.NumOut() != 1 {
			continue
		}
		if mt.Out(0) != reflect.TypeOf(r4b.OperationDefinition{}) {
			continue
		}
		args := []reflect.Value{}
		if mt.NumIn() == 1 {
			if mt.In(0) != ctxT {
				continue
			}
			args = append(args, reflect.ValueOf(ctx))
		}
		out := mv.Call(args)
		od := out[0].Interface().(r4b.OperationDefinition)
		base := name
		base = strings.TrimSuffix(base, "OperationDefinition")
		base = strings.TrimSuffix(base, "Definition")
		code := strings.ToLower(base)
		if od.Code.Value != nil {
			code = strings.ToLower(*od.Code.Value)
		}
		id := code
		if od.Id != nil && od.Id.Value != nil {
			id = *od.Id.Value
		} else {
			od.Id = &r4b.Id{Value: ptr.To(id)}
		}
		if baseUrl != "" {
			canonical := baseUrl + "/OperationDefinition/" + id
			od.Url = &r4b.Uri{Value: ptr.To(canonical)}
		}
		defs[id] = od
	}
	return defs, nil
}
func (w Generic) Create(ctx context.Context, resource model.Resource) (model.Resource, error) {
	switch r := resource.(type) {
	case r4b.Account:
		if impl, ok := w.Concrete.(AccountCreate); ok {
			return impl.CreateAccount(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Account")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ActivityDefinition:
		if impl, ok := w.Concrete.(ActivityDefinitionCreate); ok {
			return impl.CreateActivityDefinition(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "ActivityDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.AdministrableProductDefinition:
		if impl, ok := w.Concrete.(AdministrableProductDefinitionCreate); ok {
			return impl.CreateAdministrableProductDefinition(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "AdministrableProductDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.AdverseEvent:
		if impl, ok := w.Concrete.(AdverseEventCreate); ok {
			return impl.CreateAdverseEvent(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "AdverseEvent")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.AllergyIntolerance:
		if impl, ok := w.Concrete.(AllergyIntoleranceCreate); ok {
			return impl.CreateAllergyIntolerance(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "AllergyIntolerance")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Appointment:
		if impl, ok := w.Concrete.(AppointmentCreate); ok {
			return impl.CreateAppointment(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Appointment")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.AppointmentResponse:
		if impl, ok := w.Concrete.(AppointmentResponseCreate); ok {
			return impl.CreateAppointmentResponse(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "AppointmentResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.AuditEvent:
		if impl, ok := w.Concrete.(AuditEventCreate); ok {
			return impl.CreateAuditEvent(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "AuditEvent")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Basic:
		if impl, ok := w.Concrete.(BasicCreate); ok {
			return impl.CreateBasic(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Basic")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Binary:
		if impl, ok := w.Concrete.(BinaryCreate); ok {
			return impl.CreateBinary(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Binary")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.BiologicallyDerivedProduct:
		if impl, ok := w.Concrete.(BiologicallyDerivedProductCreate); ok {
			return impl.CreateBiologicallyDerivedProduct(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "BiologicallyDerivedProduct")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.BodyStructure:
		if impl, ok := w.Concrete.(BodyStructureCreate); ok {
			return impl.CreateBodyStructure(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "BodyStructure")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Bundle:
		if impl, ok := w.Concrete.(BundleCreate); ok {
			return impl.CreateBundle(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Bundle")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.CapabilityStatement:
		if impl, ok := w.Concrete.(CapabilityStatementCreate); ok {
			return impl.CreateCapabilityStatement(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "CapabilityStatement")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.CarePlan:
		if impl, ok := w.Concrete.(CarePlanCreate); ok {
			return impl.CreateCarePlan(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "CarePlan")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.CareTeam:
		if impl, ok := w.Concrete.(CareTeamCreate); ok {
			return impl.CreateCareTeam(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "CareTeam")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.CatalogEntry:
		if impl, ok := w.Concrete.(CatalogEntryCreate); ok {
			return impl.CreateCatalogEntry(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "CatalogEntry")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ChargeItem:
		if impl, ok := w.Concrete.(ChargeItemCreate); ok {
			return impl.CreateChargeItem(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "ChargeItem")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ChargeItemDefinition:
		if impl, ok := w.Concrete.(ChargeItemDefinitionCreate); ok {
			return impl.CreateChargeItemDefinition(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "ChargeItemDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Citation:
		if impl, ok := w.Concrete.(CitationCreate); ok {
			return impl.CreateCitation(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Citation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Claim:
		if impl, ok := w.Concrete.(ClaimCreate); ok {
			return impl.CreateClaim(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Claim")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ClaimResponse:
		if impl, ok := w.Concrete.(ClaimResponseCreate); ok {
			return impl.CreateClaimResponse(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "ClaimResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ClinicalImpression:
		if impl, ok := w.Concrete.(ClinicalImpressionCreate); ok {
			return impl.CreateClinicalImpression(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "ClinicalImpression")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ClinicalUseDefinition:
		if impl, ok := w.Concrete.(ClinicalUseDefinitionCreate); ok {
			return impl.CreateClinicalUseDefinition(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "ClinicalUseDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.CodeSystem:
		if impl, ok := w.Concrete.(CodeSystemCreate); ok {
			return impl.CreateCodeSystem(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "CodeSystem")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Communication:
		if impl, ok := w.Concrete.(CommunicationCreate); ok {
			return impl.CreateCommunication(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Communication")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.CommunicationRequest:
		if impl, ok := w.Concrete.(CommunicationRequestCreate); ok {
			return impl.CreateCommunicationRequest(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "CommunicationRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.CompartmentDefinition:
		if impl, ok := w.Concrete.(CompartmentDefinitionCreate); ok {
			return impl.CreateCompartmentDefinition(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "CompartmentDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Composition:
		if impl, ok := w.Concrete.(CompositionCreate); ok {
			return impl.CreateComposition(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Composition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ConceptMap:
		if impl, ok := w.Concrete.(ConceptMapCreate); ok {
			return impl.CreateConceptMap(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "ConceptMap")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Condition:
		if impl, ok := w.Concrete.(ConditionCreate); ok {
			return impl.CreateCondition(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Condition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Consent:
		if impl, ok := w.Concrete.(ConsentCreate); ok {
			return impl.CreateConsent(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Consent")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Contract:
		if impl, ok := w.Concrete.(ContractCreate); ok {
			return impl.CreateContract(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Contract")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Coverage:
		if impl, ok := w.Concrete.(CoverageCreate); ok {
			return impl.CreateCoverage(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Coverage")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.CoverageEligibilityRequest:
		if impl, ok := w.Concrete.(CoverageEligibilityRequestCreate); ok {
			return impl.CreateCoverageEligibilityRequest(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "CoverageEligibilityRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.CoverageEligibilityResponse:
		if impl, ok := w.Concrete.(CoverageEligibilityResponseCreate); ok {
			return impl.CreateCoverageEligibilityResponse(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "CoverageEligibilityResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.DetectedIssue:
		if impl, ok := w.Concrete.(DetectedIssueCreate); ok {
			return impl.CreateDetectedIssue(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "DetectedIssue")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Device:
		if impl, ok := w.Concrete.(DeviceCreate); ok {
			return impl.CreateDevice(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Device")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.DeviceDefinition:
		if impl, ok := w.Concrete.(DeviceDefinitionCreate); ok {
			return impl.CreateDeviceDefinition(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "DeviceDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.DeviceMetric:
		if impl, ok := w.Concrete.(DeviceMetricCreate); ok {
			return impl.CreateDeviceMetric(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "DeviceMetric")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.DeviceRequest:
		if impl, ok := w.Concrete.(DeviceRequestCreate); ok {
			return impl.CreateDeviceRequest(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "DeviceRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.DeviceUseStatement:
		if impl, ok := w.Concrete.(DeviceUseStatementCreate); ok {
			return impl.CreateDeviceUseStatement(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "DeviceUseStatement")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.DiagnosticReport:
		if impl, ok := w.Concrete.(DiagnosticReportCreate); ok {
			return impl.CreateDiagnosticReport(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "DiagnosticReport")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.DocumentManifest:
		if impl, ok := w.Concrete.(DocumentManifestCreate); ok {
			return impl.CreateDocumentManifest(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "DocumentManifest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.DocumentReference:
		if impl, ok := w.Concrete.(DocumentReferenceCreate); ok {
			return impl.CreateDocumentReference(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "DocumentReference")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Encounter:
		if impl, ok := w.Concrete.(EncounterCreate); ok {
			return impl.CreateEncounter(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Encounter")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Endpoint:
		if impl, ok := w.Concrete.(EndpointCreate); ok {
			return impl.CreateEndpoint(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Endpoint")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.EnrollmentRequest:
		if impl, ok := w.Concrete.(EnrollmentRequestCreate); ok {
			return impl.CreateEnrollmentRequest(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "EnrollmentRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.EnrollmentResponse:
		if impl, ok := w.Concrete.(EnrollmentResponseCreate); ok {
			return impl.CreateEnrollmentResponse(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "EnrollmentResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.EpisodeOfCare:
		if impl, ok := w.Concrete.(EpisodeOfCareCreate); ok {
			return impl.CreateEpisodeOfCare(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "EpisodeOfCare")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.EventDefinition:
		if impl, ok := w.Concrete.(EventDefinitionCreate); ok {
			return impl.CreateEventDefinition(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "EventDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Evidence:
		if impl, ok := w.Concrete.(EvidenceCreate); ok {
			return impl.CreateEvidence(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Evidence")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.EvidenceReport:
		if impl, ok := w.Concrete.(EvidenceReportCreate); ok {
			return impl.CreateEvidenceReport(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "EvidenceReport")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.EvidenceVariable:
		if impl, ok := w.Concrete.(EvidenceVariableCreate); ok {
			return impl.CreateEvidenceVariable(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "EvidenceVariable")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ExampleScenario:
		if impl, ok := w.Concrete.(ExampleScenarioCreate); ok {
			return impl.CreateExampleScenario(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "ExampleScenario")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ExplanationOfBenefit:
		if impl, ok := w.Concrete.(ExplanationOfBenefitCreate); ok {
			return impl.CreateExplanationOfBenefit(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "ExplanationOfBenefit")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.FamilyMemberHistory:
		if impl, ok := w.Concrete.(FamilyMemberHistoryCreate); ok {
			return impl.CreateFamilyMemberHistory(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "FamilyMemberHistory")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Flag:
		if impl, ok := w.Concrete.(FlagCreate); ok {
			return impl.CreateFlag(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Flag")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Goal:
		if impl, ok := w.Concrete.(GoalCreate); ok {
			return impl.CreateGoal(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Goal")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.GraphDefinition:
		if impl, ok := w.Concrete.(GraphDefinitionCreate); ok {
			return impl.CreateGraphDefinition(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "GraphDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Group:
		if impl, ok := w.Concrete.(GroupCreate); ok {
			return impl.CreateGroup(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Group")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.GuidanceResponse:
		if impl, ok := w.Concrete.(GuidanceResponseCreate); ok {
			return impl.CreateGuidanceResponse(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "GuidanceResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.HealthcareService:
		if impl, ok := w.Concrete.(HealthcareServiceCreate); ok {
			return impl.CreateHealthcareService(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "HealthcareService")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ImagingStudy:
		if impl, ok := w.Concrete.(ImagingStudyCreate); ok {
			return impl.CreateImagingStudy(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "ImagingStudy")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Immunization:
		if impl, ok := w.Concrete.(ImmunizationCreate); ok {
			return impl.CreateImmunization(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Immunization")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ImmunizationEvaluation:
		if impl, ok := w.Concrete.(ImmunizationEvaluationCreate); ok {
			return impl.CreateImmunizationEvaluation(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "ImmunizationEvaluation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ImmunizationRecommendation:
		if impl, ok := w.Concrete.(ImmunizationRecommendationCreate); ok {
			return impl.CreateImmunizationRecommendation(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "ImmunizationRecommendation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ImplementationGuide:
		if impl, ok := w.Concrete.(ImplementationGuideCreate); ok {
			return impl.CreateImplementationGuide(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "ImplementationGuide")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Ingredient:
		if impl, ok := w.Concrete.(IngredientCreate); ok {
			return impl.CreateIngredient(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Ingredient")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.InsurancePlan:
		if impl, ok := w.Concrete.(InsurancePlanCreate); ok {
			return impl.CreateInsurancePlan(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "InsurancePlan")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Invoice:
		if impl, ok := w.Concrete.(InvoiceCreate); ok {
			return impl.CreateInvoice(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Invoice")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Library:
		if impl, ok := w.Concrete.(LibraryCreate); ok {
			return impl.CreateLibrary(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Library")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Linkage:
		if impl, ok := w.Concrete.(LinkageCreate); ok {
			return impl.CreateLinkage(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Linkage")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.List:
		if impl, ok := w.Concrete.(ListCreate); ok {
			return impl.CreateList(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "List")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Location:
		if impl, ok := w.Concrete.(LocationCreate); ok {
			return impl.CreateLocation(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Location")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ManufacturedItemDefinition:
		if impl, ok := w.Concrete.(ManufacturedItemDefinitionCreate); ok {
			return impl.CreateManufacturedItemDefinition(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "ManufacturedItemDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Measure:
		if impl, ok := w.Concrete.(MeasureCreate); ok {
			return impl.CreateMeasure(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Measure")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.MeasureReport:
		if impl, ok := w.Concrete.(MeasureReportCreate); ok {
			return impl.CreateMeasureReport(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "MeasureReport")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Media:
		if impl, ok := w.Concrete.(MediaCreate); ok {
			return impl.CreateMedia(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Media")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Medication:
		if impl, ok := w.Concrete.(MedicationCreate); ok {
			return impl.CreateMedication(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Medication")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.MedicationAdministration:
		if impl, ok := w.Concrete.(MedicationAdministrationCreate); ok {
			return impl.CreateMedicationAdministration(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "MedicationAdministration")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.MedicationDispense:
		if impl, ok := w.Concrete.(MedicationDispenseCreate); ok {
			return impl.CreateMedicationDispense(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "MedicationDispense")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.MedicationKnowledge:
		if impl, ok := w.Concrete.(MedicationKnowledgeCreate); ok {
			return impl.CreateMedicationKnowledge(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "MedicationKnowledge")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.MedicationRequest:
		if impl, ok := w.Concrete.(MedicationRequestCreate); ok {
			return impl.CreateMedicationRequest(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "MedicationRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.MedicationStatement:
		if impl, ok := w.Concrete.(MedicationStatementCreate); ok {
			return impl.CreateMedicationStatement(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "MedicationStatement")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.MedicinalProductDefinition:
		if impl, ok := w.Concrete.(MedicinalProductDefinitionCreate); ok {
			return impl.CreateMedicinalProductDefinition(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "MedicinalProductDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.MessageDefinition:
		if impl, ok := w.Concrete.(MessageDefinitionCreate); ok {
			return impl.CreateMessageDefinition(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "MessageDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.MessageHeader:
		if impl, ok := w.Concrete.(MessageHeaderCreate); ok {
			return impl.CreateMessageHeader(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "MessageHeader")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.MolecularSequence:
		if impl, ok := w.Concrete.(MolecularSequenceCreate); ok {
			return impl.CreateMolecularSequence(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "MolecularSequence")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.NamingSystem:
		if impl, ok := w.Concrete.(NamingSystemCreate); ok {
			return impl.CreateNamingSystem(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "NamingSystem")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.NutritionOrder:
		if impl, ok := w.Concrete.(NutritionOrderCreate); ok {
			return impl.CreateNutritionOrder(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "NutritionOrder")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.NutritionProduct:
		if impl, ok := w.Concrete.(NutritionProductCreate); ok {
			return impl.CreateNutritionProduct(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "NutritionProduct")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Observation:
		if impl, ok := w.Concrete.(ObservationCreate); ok {
			return impl.CreateObservation(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Observation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ObservationDefinition:
		if impl, ok := w.Concrete.(ObservationDefinitionCreate); ok {
			return impl.CreateObservationDefinition(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "ObservationDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.OperationDefinition:
		if impl, ok := w.Concrete.(OperationDefinitionCreate); ok {
			return impl.CreateOperationDefinition(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "OperationDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.OperationOutcome:
		if impl, ok := w.Concrete.(OperationOutcomeCreate); ok {
			return impl.CreateOperationOutcome(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "OperationOutcome")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Organization:
		if impl, ok := w.Concrete.(OrganizationCreate); ok {
			return impl.CreateOrganization(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Organization")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.OrganizationAffiliation:
		if impl, ok := w.Concrete.(OrganizationAffiliationCreate); ok {
			return impl.CreateOrganizationAffiliation(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "OrganizationAffiliation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.PackagedProductDefinition:
		if impl, ok := w.Concrete.(PackagedProductDefinitionCreate); ok {
			return impl.CreatePackagedProductDefinition(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "PackagedProductDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Parameters:
		if impl, ok := w.Concrete.(ParametersCreate); ok {
			return impl.CreateParameters(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Parameters")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Patient:
		if impl, ok := w.Concrete.(PatientCreate); ok {
			return impl.CreatePatient(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Patient")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.PaymentNotice:
		if impl, ok := w.Concrete.(PaymentNoticeCreate); ok {
			return impl.CreatePaymentNotice(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "PaymentNotice")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.PaymentReconciliation:
		if impl, ok := w.Concrete.(PaymentReconciliationCreate); ok {
			return impl.CreatePaymentReconciliation(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "PaymentReconciliation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Person:
		if impl, ok := w.Concrete.(PersonCreate); ok {
			return impl.CreatePerson(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Person")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.PlanDefinition:
		if impl, ok := w.Concrete.(PlanDefinitionCreate); ok {
			return impl.CreatePlanDefinition(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "PlanDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Practitioner:
		if impl, ok := w.Concrete.(PractitionerCreate); ok {
			return impl.CreatePractitioner(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Practitioner")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.PractitionerRole:
		if impl, ok := w.Concrete.(PractitionerRoleCreate); ok {
			return impl.CreatePractitionerRole(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "PractitionerRole")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Procedure:
		if impl, ok := w.Concrete.(ProcedureCreate); ok {
			return impl.CreateProcedure(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Procedure")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Provenance:
		if impl, ok := w.Concrete.(ProvenanceCreate); ok {
			return impl.CreateProvenance(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Provenance")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Questionnaire:
		if impl, ok := w.Concrete.(QuestionnaireCreate); ok {
			return impl.CreateQuestionnaire(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Questionnaire")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.QuestionnaireResponse:
		if impl, ok := w.Concrete.(QuestionnaireResponseCreate); ok {
			return impl.CreateQuestionnaireResponse(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "QuestionnaireResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.RegulatedAuthorization:
		if impl, ok := w.Concrete.(RegulatedAuthorizationCreate); ok {
			return impl.CreateRegulatedAuthorization(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "RegulatedAuthorization")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.RelatedPerson:
		if impl, ok := w.Concrete.(RelatedPersonCreate); ok {
			return impl.CreateRelatedPerson(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "RelatedPerson")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.RequestGroup:
		if impl, ok := w.Concrete.(RequestGroupCreate); ok {
			return impl.CreateRequestGroup(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "RequestGroup")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ResearchDefinition:
		if impl, ok := w.Concrete.(ResearchDefinitionCreate); ok {
			return impl.CreateResearchDefinition(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "ResearchDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ResearchElementDefinition:
		if impl, ok := w.Concrete.(ResearchElementDefinitionCreate); ok {
			return impl.CreateResearchElementDefinition(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "ResearchElementDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ResearchStudy:
		if impl, ok := w.Concrete.(ResearchStudyCreate); ok {
			return impl.CreateResearchStudy(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "ResearchStudy")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ResearchSubject:
		if impl, ok := w.Concrete.(ResearchSubjectCreate); ok {
			return impl.CreateResearchSubject(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "ResearchSubject")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.RiskAssessment:
		if impl, ok := w.Concrete.(RiskAssessmentCreate); ok {
			return impl.CreateRiskAssessment(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "RiskAssessment")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Schedule:
		if impl, ok := w.Concrete.(ScheduleCreate); ok {
			return impl.CreateSchedule(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Schedule")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.SearchParameter:
		if impl, ok := w.Concrete.(SearchParameterCreate); ok {
			return impl.CreateSearchParameter(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "SearchParameter")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ServiceRequest:
		if impl, ok := w.Concrete.(ServiceRequestCreate); ok {
			return impl.CreateServiceRequest(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "ServiceRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Slot:
		if impl, ok := w.Concrete.(SlotCreate); ok {
			return impl.CreateSlot(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Slot")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Specimen:
		if impl, ok := w.Concrete.(SpecimenCreate); ok {
			return impl.CreateSpecimen(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Specimen")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.SpecimenDefinition:
		if impl, ok := w.Concrete.(SpecimenDefinitionCreate); ok {
			return impl.CreateSpecimenDefinition(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "SpecimenDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.StructureDefinition:
		if impl, ok := w.Concrete.(StructureDefinitionCreate); ok {
			return impl.CreateStructureDefinition(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "StructureDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.StructureMap:
		if impl, ok := w.Concrete.(StructureMapCreate); ok {
			return impl.CreateStructureMap(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "StructureMap")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Subscription:
		if impl, ok := w.Concrete.(SubscriptionCreate); ok {
			return impl.CreateSubscription(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Subscription")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.SubscriptionStatus:
		if impl, ok := w.Concrete.(SubscriptionStatusCreate); ok {
			return impl.CreateSubscriptionStatus(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "SubscriptionStatus")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.SubscriptionTopic:
		if impl, ok := w.Concrete.(SubscriptionTopicCreate); ok {
			return impl.CreateSubscriptionTopic(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "SubscriptionTopic")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Substance:
		if impl, ok := w.Concrete.(SubstanceCreate); ok {
			return impl.CreateSubstance(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Substance")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.SubstanceDefinition:
		if impl, ok := w.Concrete.(SubstanceDefinitionCreate); ok {
			return impl.CreateSubstanceDefinition(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "SubstanceDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.SupplyDelivery:
		if impl, ok := w.Concrete.(SupplyDeliveryCreate); ok {
			return impl.CreateSupplyDelivery(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "SupplyDelivery")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.SupplyRequest:
		if impl, ok := w.Concrete.(SupplyRequestCreate); ok {
			return impl.CreateSupplyRequest(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "SupplyRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Task:
		if impl, ok := w.Concrete.(TaskCreate); ok {
			return impl.CreateTask(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "Task")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.TerminologyCapabilities:
		if impl, ok := w.Concrete.(TerminologyCapabilitiesCreate); ok {
			return impl.CreateTerminologyCapabilities(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "TerminologyCapabilities")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.TestReport:
		if impl, ok := w.Concrete.(TestReportCreate); ok {
			return impl.CreateTestReport(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "TestReport")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.TestScript:
		if impl, ok := w.Concrete.(TestScriptCreate); ok {
			return impl.CreateTestScript(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "TestScript")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ValueSet:
		if impl, ok := w.Concrete.(ValueSetCreate); ok {
			return impl.CreateValueSet(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "ValueSet")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.VerificationResult:
		if impl, ok := w.Concrete.(VerificationResultCreate); ok {
			return impl.CreateVerificationResult(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "VerificationResult")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.VisionPrescription:
		if impl, ok := w.Concrete.(VisionPrescriptionCreate); ok {
			return impl.CreateVisionPrescription(ctx, r)
		}
		if gen, ok := w.Concrete.(capabilities.GenericCreate); ok {
			return gen.Create(ctx, resource)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("create not implemented for " + "VisionPrescription")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	}
	return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
		Code:        r4b.Code{Value: ptr.To("processing")},
		Diagnostics: &r4b.String{Value: ptr.To("invalid resource type: " + resource.ResourceType())},
		Severity:    r4b.Code{Value: ptr.To("fatal")},
	}}}
}
func (w Generic) Read(ctx context.Context, resourceType string, id string) (model.Resource, error) {
	switch resourceType {
	case "Account":
		if impl, ok := w.Concrete.(AccountRead); ok {
			return impl.ReadAccount(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Account")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ActivityDefinition":
		if impl, ok := w.Concrete.(ActivityDefinitionRead); ok {
			return impl.ReadActivityDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "ActivityDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "AdministrableProductDefinition":
		if impl, ok := w.Concrete.(AdministrableProductDefinitionRead); ok {
			return impl.ReadAdministrableProductDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "AdministrableProductDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "AdverseEvent":
		if impl, ok := w.Concrete.(AdverseEventRead); ok {
			return impl.ReadAdverseEvent(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "AdverseEvent")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "AllergyIntolerance":
		if impl, ok := w.Concrete.(AllergyIntoleranceRead); ok {
			return impl.ReadAllergyIntolerance(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "AllergyIntolerance")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Appointment":
		if impl, ok := w.Concrete.(AppointmentRead); ok {
			return impl.ReadAppointment(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Appointment")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "AppointmentResponse":
		if impl, ok := w.Concrete.(AppointmentResponseRead); ok {
			return impl.ReadAppointmentResponse(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "AppointmentResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "AuditEvent":
		if impl, ok := w.Concrete.(AuditEventRead); ok {
			return impl.ReadAuditEvent(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "AuditEvent")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Basic":
		if impl, ok := w.Concrete.(BasicRead); ok {
			return impl.ReadBasic(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Basic")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Binary":
		if impl, ok := w.Concrete.(BinaryRead); ok {
			return impl.ReadBinary(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Binary")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "BiologicallyDerivedProduct":
		if impl, ok := w.Concrete.(BiologicallyDerivedProductRead); ok {
			return impl.ReadBiologicallyDerivedProduct(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "BiologicallyDerivedProduct")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "BodyStructure":
		if impl, ok := w.Concrete.(BodyStructureRead); ok {
			return impl.ReadBodyStructure(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "BodyStructure")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Bundle":
		if impl, ok := w.Concrete.(BundleRead); ok {
			return impl.ReadBundle(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Bundle")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "CapabilityStatement":
		if impl, ok := w.Concrete.(CapabilityStatementRead); ok {
			return impl.ReadCapabilityStatement(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "CapabilityStatement")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "CarePlan":
		if impl, ok := w.Concrete.(CarePlanRead); ok {
			return impl.ReadCarePlan(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "CarePlan")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "CareTeam":
		if impl, ok := w.Concrete.(CareTeamRead); ok {
			return impl.ReadCareTeam(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "CareTeam")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "CatalogEntry":
		if impl, ok := w.Concrete.(CatalogEntryRead); ok {
			return impl.ReadCatalogEntry(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "CatalogEntry")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ChargeItem":
		if impl, ok := w.Concrete.(ChargeItemRead); ok {
			return impl.ReadChargeItem(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "ChargeItem")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ChargeItemDefinition":
		if impl, ok := w.Concrete.(ChargeItemDefinitionRead); ok {
			return impl.ReadChargeItemDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "ChargeItemDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Citation":
		if impl, ok := w.Concrete.(CitationRead); ok {
			return impl.ReadCitation(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Citation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Claim":
		if impl, ok := w.Concrete.(ClaimRead); ok {
			return impl.ReadClaim(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Claim")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ClaimResponse":
		if impl, ok := w.Concrete.(ClaimResponseRead); ok {
			return impl.ReadClaimResponse(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "ClaimResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ClinicalImpression":
		if impl, ok := w.Concrete.(ClinicalImpressionRead); ok {
			return impl.ReadClinicalImpression(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "ClinicalImpression")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ClinicalUseDefinition":
		if impl, ok := w.Concrete.(ClinicalUseDefinitionRead); ok {
			return impl.ReadClinicalUseDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "ClinicalUseDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "CodeSystem":
		if impl, ok := w.Concrete.(CodeSystemRead); ok {
			return impl.ReadCodeSystem(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "CodeSystem")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Communication":
		if impl, ok := w.Concrete.(CommunicationRead); ok {
			return impl.ReadCommunication(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Communication")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "CommunicationRequest":
		if impl, ok := w.Concrete.(CommunicationRequestRead); ok {
			return impl.ReadCommunicationRequest(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "CommunicationRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "CompartmentDefinition":
		if impl, ok := w.Concrete.(CompartmentDefinitionRead); ok {
			return impl.ReadCompartmentDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "CompartmentDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Composition":
		if impl, ok := w.Concrete.(CompositionRead); ok {
			return impl.ReadComposition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Composition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ConceptMap":
		if impl, ok := w.Concrete.(ConceptMapRead); ok {
			return impl.ReadConceptMap(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "ConceptMap")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Condition":
		if impl, ok := w.Concrete.(ConditionRead); ok {
			return impl.ReadCondition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Condition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Consent":
		if impl, ok := w.Concrete.(ConsentRead); ok {
			return impl.ReadConsent(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Consent")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Contract":
		if impl, ok := w.Concrete.(ContractRead); ok {
			return impl.ReadContract(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Contract")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Coverage":
		if impl, ok := w.Concrete.(CoverageRead); ok {
			return impl.ReadCoverage(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Coverage")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "CoverageEligibilityRequest":
		if impl, ok := w.Concrete.(CoverageEligibilityRequestRead); ok {
			return impl.ReadCoverageEligibilityRequest(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "CoverageEligibilityRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "CoverageEligibilityResponse":
		if impl, ok := w.Concrete.(CoverageEligibilityResponseRead); ok {
			return impl.ReadCoverageEligibilityResponse(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "CoverageEligibilityResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "DetectedIssue":
		if impl, ok := w.Concrete.(DetectedIssueRead); ok {
			return impl.ReadDetectedIssue(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "DetectedIssue")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Device":
		if impl, ok := w.Concrete.(DeviceRead); ok {
			return impl.ReadDevice(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Device")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "DeviceDefinition":
		if impl, ok := w.Concrete.(DeviceDefinitionRead); ok {
			return impl.ReadDeviceDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "DeviceDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "DeviceMetric":
		if impl, ok := w.Concrete.(DeviceMetricRead); ok {
			return impl.ReadDeviceMetric(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "DeviceMetric")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "DeviceRequest":
		if impl, ok := w.Concrete.(DeviceRequestRead); ok {
			return impl.ReadDeviceRequest(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "DeviceRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "DeviceUseStatement":
		if impl, ok := w.Concrete.(DeviceUseStatementRead); ok {
			return impl.ReadDeviceUseStatement(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "DeviceUseStatement")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "DiagnosticReport":
		if impl, ok := w.Concrete.(DiagnosticReportRead); ok {
			return impl.ReadDiagnosticReport(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "DiagnosticReport")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "DocumentManifest":
		if impl, ok := w.Concrete.(DocumentManifestRead); ok {
			return impl.ReadDocumentManifest(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "DocumentManifest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "DocumentReference":
		if impl, ok := w.Concrete.(DocumentReferenceRead); ok {
			return impl.ReadDocumentReference(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "DocumentReference")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Encounter":
		if impl, ok := w.Concrete.(EncounterRead); ok {
			return impl.ReadEncounter(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Encounter")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Endpoint":
		if impl, ok := w.Concrete.(EndpointRead); ok {
			return impl.ReadEndpoint(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Endpoint")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "EnrollmentRequest":
		if impl, ok := w.Concrete.(EnrollmentRequestRead); ok {
			return impl.ReadEnrollmentRequest(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "EnrollmentRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "EnrollmentResponse":
		if impl, ok := w.Concrete.(EnrollmentResponseRead); ok {
			return impl.ReadEnrollmentResponse(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "EnrollmentResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "EpisodeOfCare":
		if impl, ok := w.Concrete.(EpisodeOfCareRead); ok {
			return impl.ReadEpisodeOfCare(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "EpisodeOfCare")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "EventDefinition":
		if impl, ok := w.Concrete.(EventDefinitionRead); ok {
			return impl.ReadEventDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "EventDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Evidence":
		if impl, ok := w.Concrete.(EvidenceRead); ok {
			return impl.ReadEvidence(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Evidence")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "EvidenceReport":
		if impl, ok := w.Concrete.(EvidenceReportRead); ok {
			return impl.ReadEvidenceReport(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "EvidenceReport")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "EvidenceVariable":
		if impl, ok := w.Concrete.(EvidenceVariableRead); ok {
			return impl.ReadEvidenceVariable(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "EvidenceVariable")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ExampleScenario":
		if impl, ok := w.Concrete.(ExampleScenarioRead); ok {
			return impl.ReadExampleScenario(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "ExampleScenario")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ExplanationOfBenefit":
		if impl, ok := w.Concrete.(ExplanationOfBenefitRead); ok {
			return impl.ReadExplanationOfBenefit(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "ExplanationOfBenefit")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "FamilyMemberHistory":
		if impl, ok := w.Concrete.(FamilyMemberHistoryRead); ok {
			return impl.ReadFamilyMemberHistory(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "FamilyMemberHistory")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Flag":
		if impl, ok := w.Concrete.(FlagRead); ok {
			return impl.ReadFlag(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Flag")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Goal":
		if impl, ok := w.Concrete.(GoalRead); ok {
			return impl.ReadGoal(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Goal")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "GraphDefinition":
		if impl, ok := w.Concrete.(GraphDefinitionRead); ok {
			return impl.ReadGraphDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "GraphDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Group":
		if impl, ok := w.Concrete.(GroupRead); ok {
			return impl.ReadGroup(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Group")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "GuidanceResponse":
		if impl, ok := w.Concrete.(GuidanceResponseRead); ok {
			return impl.ReadGuidanceResponse(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "GuidanceResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "HealthcareService":
		if impl, ok := w.Concrete.(HealthcareServiceRead); ok {
			return impl.ReadHealthcareService(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "HealthcareService")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ImagingStudy":
		if impl, ok := w.Concrete.(ImagingStudyRead); ok {
			return impl.ReadImagingStudy(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "ImagingStudy")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Immunization":
		if impl, ok := w.Concrete.(ImmunizationRead); ok {
			return impl.ReadImmunization(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Immunization")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ImmunizationEvaluation":
		if impl, ok := w.Concrete.(ImmunizationEvaluationRead); ok {
			return impl.ReadImmunizationEvaluation(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "ImmunizationEvaluation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ImmunizationRecommendation":
		if impl, ok := w.Concrete.(ImmunizationRecommendationRead); ok {
			return impl.ReadImmunizationRecommendation(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "ImmunizationRecommendation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ImplementationGuide":
		if impl, ok := w.Concrete.(ImplementationGuideRead); ok {
			return impl.ReadImplementationGuide(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "ImplementationGuide")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Ingredient":
		if impl, ok := w.Concrete.(IngredientRead); ok {
			return impl.ReadIngredient(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Ingredient")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "InsurancePlan":
		if impl, ok := w.Concrete.(InsurancePlanRead); ok {
			return impl.ReadInsurancePlan(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "InsurancePlan")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Invoice":
		if impl, ok := w.Concrete.(InvoiceRead); ok {
			return impl.ReadInvoice(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Invoice")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Library":
		if impl, ok := w.Concrete.(LibraryRead); ok {
			return impl.ReadLibrary(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Library")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Linkage":
		if impl, ok := w.Concrete.(LinkageRead); ok {
			return impl.ReadLinkage(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Linkage")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "List":
		if impl, ok := w.Concrete.(ListRead); ok {
			return impl.ReadList(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "List")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Location":
		if impl, ok := w.Concrete.(LocationRead); ok {
			return impl.ReadLocation(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Location")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ManufacturedItemDefinition":
		if impl, ok := w.Concrete.(ManufacturedItemDefinitionRead); ok {
			return impl.ReadManufacturedItemDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "ManufacturedItemDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Measure":
		if impl, ok := w.Concrete.(MeasureRead); ok {
			return impl.ReadMeasure(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Measure")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MeasureReport":
		if impl, ok := w.Concrete.(MeasureReportRead); ok {
			return impl.ReadMeasureReport(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "MeasureReport")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Media":
		if impl, ok := w.Concrete.(MediaRead); ok {
			return impl.ReadMedia(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Media")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Medication":
		if impl, ok := w.Concrete.(MedicationRead); ok {
			return impl.ReadMedication(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Medication")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MedicationAdministration":
		if impl, ok := w.Concrete.(MedicationAdministrationRead); ok {
			return impl.ReadMedicationAdministration(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "MedicationAdministration")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MedicationDispense":
		if impl, ok := w.Concrete.(MedicationDispenseRead); ok {
			return impl.ReadMedicationDispense(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "MedicationDispense")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MedicationKnowledge":
		if impl, ok := w.Concrete.(MedicationKnowledgeRead); ok {
			return impl.ReadMedicationKnowledge(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "MedicationKnowledge")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MedicationRequest":
		if impl, ok := w.Concrete.(MedicationRequestRead); ok {
			return impl.ReadMedicationRequest(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "MedicationRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MedicationStatement":
		if impl, ok := w.Concrete.(MedicationStatementRead); ok {
			return impl.ReadMedicationStatement(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "MedicationStatement")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MedicinalProductDefinition":
		if impl, ok := w.Concrete.(MedicinalProductDefinitionRead); ok {
			return impl.ReadMedicinalProductDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "MedicinalProductDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MessageDefinition":
		if impl, ok := w.Concrete.(MessageDefinitionRead); ok {
			return impl.ReadMessageDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "MessageDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MessageHeader":
		if impl, ok := w.Concrete.(MessageHeaderRead); ok {
			return impl.ReadMessageHeader(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "MessageHeader")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MolecularSequence":
		if impl, ok := w.Concrete.(MolecularSequenceRead); ok {
			return impl.ReadMolecularSequence(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "MolecularSequence")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "NamingSystem":
		if impl, ok := w.Concrete.(NamingSystemRead); ok {
			return impl.ReadNamingSystem(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "NamingSystem")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "NutritionOrder":
		if impl, ok := w.Concrete.(NutritionOrderRead); ok {
			return impl.ReadNutritionOrder(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "NutritionOrder")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "NutritionProduct":
		if impl, ok := w.Concrete.(NutritionProductRead); ok {
			return impl.ReadNutritionProduct(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "NutritionProduct")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Observation":
		if impl, ok := w.Concrete.(ObservationRead); ok {
			return impl.ReadObservation(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Observation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ObservationDefinition":
		if impl, ok := w.Concrete.(ObservationDefinitionRead); ok {
			return impl.ReadObservationDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "ObservationDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "OperationDefinition":
		impl, ok := w.Concrete.(OperationDefinitionRead)
		if ok {
			return impl.ReadOperationDefinition(ctx, id)
		}
		cs, err := w.Concrete.CapabilityBase(ctx)
		if err != nil {
			return nil, err
		}
		var baseUrl string
		if cs.Implementation != nil && cs.Implementation.Url != nil && cs.Implementation.Url.Value != nil {
			baseUrl = *cs.Implementation.Url.Value
		}
		defs, err := operationDefinitionsByID(ctx, w.Concrete, baseUrl)
		if err != nil {
			return nil, err
		}
		if od, exists := defs[id]; exists {
			return od, nil
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-found")},
			Diagnostics: &r4b.String{Value: ptr.To("OperationDefinition with ID " + id + " not found")},
			Severity:    r4b.Code{Value: ptr.To("error")},
		}}}
	case "OperationOutcome":
		if impl, ok := w.Concrete.(OperationOutcomeRead); ok {
			return impl.ReadOperationOutcome(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "OperationOutcome")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Organization":
		if impl, ok := w.Concrete.(OrganizationRead); ok {
			return impl.ReadOrganization(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Organization")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "OrganizationAffiliation":
		if impl, ok := w.Concrete.(OrganizationAffiliationRead); ok {
			return impl.ReadOrganizationAffiliation(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "OrganizationAffiliation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "PackagedProductDefinition":
		if impl, ok := w.Concrete.(PackagedProductDefinitionRead); ok {
			return impl.ReadPackagedProductDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "PackagedProductDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Parameters":
		if impl, ok := w.Concrete.(ParametersRead); ok {
			return impl.ReadParameters(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Parameters")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Patient":
		if impl, ok := w.Concrete.(PatientRead); ok {
			return impl.ReadPatient(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Patient")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "PaymentNotice":
		if impl, ok := w.Concrete.(PaymentNoticeRead); ok {
			return impl.ReadPaymentNotice(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "PaymentNotice")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "PaymentReconciliation":
		if impl, ok := w.Concrete.(PaymentReconciliationRead); ok {
			return impl.ReadPaymentReconciliation(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "PaymentReconciliation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Person":
		if impl, ok := w.Concrete.(PersonRead); ok {
			return impl.ReadPerson(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Person")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "PlanDefinition":
		if impl, ok := w.Concrete.(PlanDefinitionRead); ok {
			return impl.ReadPlanDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "PlanDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Practitioner":
		if impl, ok := w.Concrete.(PractitionerRead); ok {
			return impl.ReadPractitioner(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Practitioner")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "PractitionerRole":
		if impl, ok := w.Concrete.(PractitionerRoleRead); ok {
			return impl.ReadPractitionerRole(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "PractitionerRole")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Procedure":
		if impl, ok := w.Concrete.(ProcedureRead); ok {
			return impl.ReadProcedure(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Procedure")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Provenance":
		if impl, ok := w.Concrete.(ProvenanceRead); ok {
			return impl.ReadProvenance(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Provenance")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Questionnaire":
		if impl, ok := w.Concrete.(QuestionnaireRead); ok {
			return impl.ReadQuestionnaire(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Questionnaire")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "QuestionnaireResponse":
		if impl, ok := w.Concrete.(QuestionnaireResponseRead); ok {
			return impl.ReadQuestionnaireResponse(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "QuestionnaireResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "RegulatedAuthorization":
		if impl, ok := w.Concrete.(RegulatedAuthorizationRead); ok {
			return impl.ReadRegulatedAuthorization(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "RegulatedAuthorization")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "RelatedPerson":
		if impl, ok := w.Concrete.(RelatedPersonRead); ok {
			return impl.ReadRelatedPerson(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "RelatedPerson")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "RequestGroup":
		if impl, ok := w.Concrete.(RequestGroupRead); ok {
			return impl.ReadRequestGroup(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "RequestGroup")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ResearchDefinition":
		if impl, ok := w.Concrete.(ResearchDefinitionRead); ok {
			return impl.ReadResearchDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "ResearchDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ResearchElementDefinition":
		if impl, ok := w.Concrete.(ResearchElementDefinitionRead); ok {
			return impl.ReadResearchElementDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "ResearchElementDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ResearchStudy":
		if impl, ok := w.Concrete.(ResearchStudyRead); ok {
			return impl.ReadResearchStudy(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "ResearchStudy")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ResearchSubject":
		if impl, ok := w.Concrete.(ResearchSubjectRead); ok {
			return impl.ReadResearchSubject(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "ResearchSubject")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "RiskAssessment":
		if impl, ok := w.Concrete.(RiskAssessmentRead); ok {
			return impl.ReadRiskAssessment(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "RiskAssessment")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Schedule":
		if impl, ok := w.Concrete.(ScheduleRead); ok {
			return impl.ReadSchedule(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Schedule")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "SearchParameter":
		impl, ok := w.Concrete.(SearchParameterRead)
		if ok {
			return impl.ReadSearchParameter(ctx, id)
		}
		// Fallback: gather SearchParameter from SearchCapabilities methods if ReadSearchParameter not implemented
		// Get base URL from CapabilityStatement for canonical references
		cs, err := w.Concrete.CapabilityBase(ctx)
		if err != nil {
			return nil, err
		}
		var baseUrl string
		if cs.Implementation != nil && cs.Implementation.Url != nil && cs.Implementation.Url.Value != nil {
			baseUrl = *cs.Implementation.Url.Value
		}
		searchParameters, err := searchParameters(ctx, w.Concrete, baseUrl)
		if err != nil {
			return nil, err
		}
		searchParam, exists := searchParameters[id]
		if exists {
			return searchParam, nil
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-found")},
			Diagnostics: &r4b.String{Value: ptr.To("SearchParameter with ID " + id + " not found")},
			Severity:    r4b.Code{Value: ptr.To("error")},
		}}}
	case "ServiceRequest":
		if impl, ok := w.Concrete.(ServiceRequestRead); ok {
			return impl.ReadServiceRequest(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "ServiceRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Slot":
		if impl, ok := w.Concrete.(SlotRead); ok {
			return impl.ReadSlot(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Slot")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Specimen":
		if impl, ok := w.Concrete.(SpecimenRead); ok {
			return impl.ReadSpecimen(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Specimen")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "SpecimenDefinition":
		if impl, ok := w.Concrete.(SpecimenDefinitionRead); ok {
			return impl.ReadSpecimenDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "SpecimenDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "StructureDefinition":
		if impl, ok := w.Concrete.(StructureDefinitionRead); ok {
			return impl.ReadStructureDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "StructureDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "StructureMap":
		if impl, ok := w.Concrete.(StructureMapRead); ok {
			return impl.ReadStructureMap(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "StructureMap")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Subscription":
		if impl, ok := w.Concrete.(SubscriptionRead); ok {
			return impl.ReadSubscription(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Subscription")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "SubscriptionStatus":
		if impl, ok := w.Concrete.(SubscriptionStatusRead); ok {
			return impl.ReadSubscriptionStatus(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "SubscriptionStatus")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "SubscriptionTopic":
		if impl, ok := w.Concrete.(SubscriptionTopicRead); ok {
			return impl.ReadSubscriptionTopic(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "SubscriptionTopic")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Substance":
		if impl, ok := w.Concrete.(SubstanceRead); ok {
			return impl.ReadSubstance(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Substance")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "SubstanceDefinition":
		if impl, ok := w.Concrete.(SubstanceDefinitionRead); ok {
			return impl.ReadSubstanceDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "SubstanceDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "SupplyDelivery":
		if impl, ok := w.Concrete.(SupplyDeliveryRead); ok {
			return impl.ReadSupplyDelivery(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "SupplyDelivery")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "SupplyRequest":
		if impl, ok := w.Concrete.(SupplyRequestRead); ok {
			return impl.ReadSupplyRequest(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "SupplyRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Task":
		if impl, ok := w.Concrete.(TaskRead); ok {
			return impl.ReadTask(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "Task")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "TerminologyCapabilities":
		if impl, ok := w.Concrete.(TerminologyCapabilitiesRead); ok {
			return impl.ReadTerminologyCapabilities(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "TerminologyCapabilities")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "TestReport":
		if impl, ok := w.Concrete.(TestReportRead); ok {
			return impl.ReadTestReport(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "TestReport")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "TestScript":
		if impl, ok := w.Concrete.(TestScriptRead); ok {
			return impl.ReadTestScript(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "TestScript")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ValueSet":
		if impl, ok := w.Concrete.(ValueSetRead); ok {
			return impl.ReadValueSet(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "ValueSet")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "VerificationResult":
		if impl, ok := w.Concrete.(VerificationResultRead); ok {
			return impl.ReadVerificationResult(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "VerificationResult")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "VisionPrescription":
		if impl, ok := w.Concrete.(VisionPrescriptionRead); ok {
			return impl.ReadVisionPrescription(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericRead); ok {
			return gen.Read(ctx, resourceType, id)
		}
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("read not implemented for " + "VisionPrescription")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	}
	return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
		Code:        r4b.Code{Value: ptr.To("processing")},
		Diagnostics: &r4b.String{Value: ptr.To("invalid resource type: " + resourceType)},
		Severity:    r4b.Code{Value: ptr.To("fatal")},
	}}}
}
func (w Generic) Update(ctx context.Context, resource model.Resource) (update.Result[model.Resource], error) {
	switch r := resource.(type) {
	case r4b.Account:
		if impl, ok := w.Concrete.(AccountUpdate); ok {
			result, err := impl.UpdateAccount(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Account")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ActivityDefinition:
		if impl, ok := w.Concrete.(ActivityDefinitionUpdate); ok {
			result, err := impl.UpdateActivityDefinition(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "ActivityDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.AdministrableProductDefinition:
		if impl, ok := w.Concrete.(AdministrableProductDefinitionUpdate); ok {
			result, err := impl.UpdateAdministrableProductDefinition(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "AdministrableProductDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.AdverseEvent:
		if impl, ok := w.Concrete.(AdverseEventUpdate); ok {
			result, err := impl.UpdateAdverseEvent(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "AdverseEvent")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.AllergyIntolerance:
		if impl, ok := w.Concrete.(AllergyIntoleranceUpdate); ok {
			result, err := impl.UpdateAllergyIntolerance(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "AllergyIntolerance")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Appointment:
		if impl, ok := w.Concrete.(AppointmentUpdate); ok {
			result, err := impl.UpdateAppointment(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Appointment")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.AppointmentResponse:
		if impl, ok := w.Concrete.(AppointmentResponseUpdate); ok {
			result, err := impl.UpdateAppointmentResponse(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "AppointmentResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.AuditEvent:
		if impl, ok := w.Concrete.(AuditEventUpdate); ok {
			result, err := impl.UpdateAuditEvent(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "AuditEvent")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Basic:
		if impl, ok := w.Concrete.(BasicUpdate); ok {
			result, err := impl.UpdateBasic(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Basic")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Binary:
		if impl, ok := w.Concrete.(BinaryUpdate); ok {
			result, err := impl.UpdateBinary(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Binary")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.BiologicallyDerivedProduct:
		if impl, ok := w.Concrete.(BiologicallyDerivedProductUpdate); ok {
			result, err := impl.UpdateBiologicallyDerivedProduct(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "BiologicallyDerivedProduct")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.BodyStructure:
		if impl, ok := w.Concrete.(BodyStructureUpdate); ok {
			result, err := impl.UpdateBodyStructure(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "BodyStructure")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Bundle:
		if impl, ok := w.Concrete.(BundleUpdate); ok {
			result, err := impl.UpdateBundle(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Bundle")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.CapabilityStatement:
		if impl, ok := w.Concrete.(CapabilityStatementUpdate); ok {
			result, err := impl.UpdateCapabilityStatement(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "CapabilityStatement")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.CarePlan:
		if impl, ok := w.Concrete.(CarePlanUpdate); ok {
			result, err := impl.UpdateCarePlan(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "CarePlan")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.CareTeam:
		if impl, ok := w.Concrete.(CareTeamUpdate); ok {
			result, err := impl.UpdateCareTeam(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "CareTeam")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.CatalogEntry:
		if impl, ok := w.Concrete.(CatalogEntryUpdate); ok {
			result, err := impl.UpdateCatalogEntry(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "CatalogEntry")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ChargeItem:
		if impl, ok := w.Concrete.(ChargeItemUpdate); ok {
			result, err := impl.UpdateChargeItem(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "ChargeItem")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ChargeItemDefinition:
		if impl, ok := w.Concrete.(ChargeItemDefinitionUpdate); ok {
			result, err := impl.UpdateChargeItemDefinition(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "ChargeItemDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Citation:
		if impl, ok := w.Concrete.(CitationUpdate); ok {
			result, err := impl.UpdateCitation(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Citation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Claim:
		if impl, ok := w.Concrete.(ClaimUpdate); ok {
			result, err := impl.UpdateClaim(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Claim")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ClaimResponse:
		if impl, ok := w.Concrete.(ClaimResponseUpdate); ok {
			result, err := impl.UpdateClaimResponse(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "ClaimResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ClinicalImpression:
		if impl, ok := w.Concrete.(ClinicalImpressionUpdate); ok {
			result, err := impl.UpdateClinicalImpression(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "ClinicalImpression")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ClinicalUseDefinition:
		if impl, ok := w.Concrete.(ClinicalUseDefinitionUpdate); ok {
			result, err := impl.UpdateClinicalUseDefinition(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "ClinicalUseDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.CodeSystem:
		if impl, ok := w.Concrete.(CodeSystemUpdate); ok {
			result, err := impl.UpdateCodeSystem(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "CodeSystem")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Communication:
		if impl, ok := w.Concrete.(CommunicationUpdate); ok {
			result, err := impl.UpdateCommunication(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Communication")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.CommunicationRequest:
		if impl, ok := w.Concrete.(CommunicationRequestUpdate); ok {
			result, err := impl.UpdateCommunicationRequest(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "CommunicationRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.CompartmentDefinition:
		if impl, ok := w.Concrete.(CompartmentDefinitionUpdate); ok {
			result, err := impl.UpdateCompartmentDefinition(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "CompartmentDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Composition:
		if impl, ok := w.Concrete.(CompositionUpdate); ok {
			result, err := impl.UpdateComposition(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Composition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ConceptMap:
		if impl, ok := w.Concrete.(ConceptMapUpdate); ok {
			result, err := impl.UpdateConceptMap(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "ConceptMap")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Condition:
		if impl, ok := w.Concrete.(ConditionUpdate); ok {
			result, err := impl.UpdateCondition(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Condition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Consent:
		if impl, ok := w.Concrete.(ConsentUpdate); ok {
			result, err := impl.UpdateConsent(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Consent")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Contract:
		if impl, ok := w.Concrete.(ContractUpdate); ok {
			result, err := impl.UpdateContract(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Contract")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Coverage:
		if impl, ok := w.Concrete.(CoverageUpdate); ok {
			result, err := impl.UpdateCoverage(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Coverage")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.CoverageEligibilityRequest:
		if impl, ok := w.Concrete.(CoverageEligibilityRequestUpdate); ok {
			result, err := impl.UpdateCoverageEligibilityRequest(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "CoverageEligibilityRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.CoverageEligibilityResponse:
		if impl, ok := w.Concrete.(CoverageEligibilityResponseUpdate); ok {
			result, err := impl.UpdateCoverageEligibilityResponse(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "CoverageEligibilityResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.DetectedIssue:
		if impl, ok := w.Concrete.(DetectedIssueUpdate); ok {
			result, err := impl.UpdateDetectedIssue(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "DetectedIssue")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Device:
		if impl, ok := w.Concrete.(DeviceUpdate); ok {
			result, err := impl.UpdateDevice(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Device")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.DeviceDefinition:
		if impl, ok := w.Concrete.(DeviceDefinitionUpdate); ok {
			result, err := impl.UpdateDeviceDefinition(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "DeviceDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.DeviceMetric:
		if impl, ok := w.Concrete.(DeviceMetricUpdate); ok {
			result, err := impl.UpdateDeviceMetric(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "DeviceMetric")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.DeviceRequest:
		if impl, ok := w.Concrete.(DeviceRequestUpdate); ok {
			result, err := impl.UpdateDeviceRequest(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "DeviceRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.DeviceUseStatement:
		if impl, ok := w.Concrete.(DeviceUseStatementUpdate); ok {
			result, err := impl.UpdateDeviceUseStatement(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "DeviceUseStatement")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.DiagnosticReport:
		if impl, ok := w.Concrete.(DiagnosticReportUpdate); ok {
			result, err := impl.UpdateDiagnosticReport(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "DiagnosticReport")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.DocumentManifest:
		if impl, ok := w.Concrete.(DocumentManifestUpdate); ok {
			result, err := impl.UpdateDocumentManifest(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "DocumentManifest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.DocumentReference:
		if impl, ok := w.Concrete.(DocumentReferenceUpdate); ok {
			result, err := impl.UpdateDocumentReference(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "DocumentReference")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Encounter:
		if impl, ok := w.Concrete.(EncounterUpdate); ok {
			result, err := impl.UpdateEncounter(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Encounter")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Endpoint:
		if impl, ok := w.Concrete.(EndpointUpdate); ok {
			result, err := impl.UpdateEndpoint(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Endpoint")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.EnrollmentRequest:
		if impl, ok := w.Concrete.(EnrollmentRequestUpdate); ok {
			result, err := impl.UpdateEnrollmentRequest(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "EnrollmentRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.EnrollmentResponse:
		if impl, ok := w.Concrete.(EnrollmentResponseUpdate); ok {
			result, err := impl.UpdateEnrollmentResponse(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "EnrollmentResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.EpisodeOfCare:
		if impl, ok := w.Concrete.(EpisodeOfCareUpdate); ok {
			result, err := impl.UpdateEpisodeOfCare(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "EpisodeOfCare")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.EventDefinition:
		if impl, ok := w.Concrete.(EventDefinitionUpdate); ok {
			result, err := impl.UpdateEventDefinition(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "EventDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Evidence:
		if impl, ok := w.Concrete.(EvidenceUpdate); ok {
			result, err := impl.UpdateEvidence(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Evidence")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.EvidenceReport:
		if impl, ok := w.Concrete.(EvidenceReportUpdate); ok {
			result, err := impl.UpdateEvidenceReport(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "EvidenceReport")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.EvidenceVariable:
		if impl, ok := w.Concrete.(EvidenceVariableUpdate); ok {
			result, err := impl.UpdateEvidenceVariable(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "EvidenceVariable")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ExampleScenario:
		if impl, ok := w.Concrete.(ExampleScenarioUpdate); ok {
			result, err := impl.UpdateExampleScenario(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "ExampleScenario")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ExplanationOfBenefit:
		if impl, ok := w.Concrete.(ExplanationOfBenefitUpdate); ok {
			result, err := impl.UpdateExplanationOfBenefit(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "ExplanationOfBenefit")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.FamilyMemberHistory:
		if impl, ok := w.Concrete.(FamilyMemberHistoryUpdate); ok {
			result, err := impl.UpdateFamilyMemberHistory(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "FamilyMemberHistory")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Flag:
		if impl, ok := w.Concrete.(FlagUpdate); ok {
			result, err := impl.UpdateFlag(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Flag")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Goal:
		if impl, ok := w.Concrete.(GoalUpdate); ok {
			result, err := impl.UpdateGoal(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Goal")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.GraphDefinition:
		if impl, ok := w.Concrete.(GraphDefinitionUpdate); ok {
			result, err := impl.UpdateGraphDefinition(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "GraphDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Group:
		if impl, ok := w.Concrete.(GroupUpdate); ok {
			result, err := impl.UpdateGroup(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Group")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.GuidanceResponse:
		if impl, ok := w.Concrete.(GuidanceResponseUpdate); ok {
			result, err := impl.UpdateGuidanceResponse(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "GuidanceResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.HealthcareService:
		if impl, ok := w.Concrete.(HealthcareServiceUpdate); ok {
			result, err := impl.UpdateHealthcareService(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "HealthcareService")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ImagingStudy:
		if impl, ok := w.Concrete.(ImagingStudyUpdate); ok {
			result, err := impl.UpdateImagingStudy(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "ImagingStudy")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Immunization:
		if impl, ok := w.Concrete.(ImmunizationUpdate); ok {
			result, err := impl.UpdateImmunization(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Immunization")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ImmunizationEvaluation:
		if impl, ok := w.Concrete.(ImmunizationEvaluationUpdate); ok {
			result, err := impl.UpdateImmunizationEvaluation(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "ImmunizationEvaluation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ImmunizationRecommendation:
		if impl, ok := w.Concrete.(ImmunizationRecommendationUpdate); ok {
			result, err := impl.UpdateImmunizationRecommendation(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "ImmunizationRecommendation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ImplementationGuide:
		if impl, ok := w.Concrete.(ImplementationGuideUpdate); ok {
			result, err := impl.UpdateImplementationGuide(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "ImplementationGuide")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Ingredient:
		if impl, ok := w.Concrete.(IngredientUpdate); ok {
			result, err := impl.UpdateIngredient(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Ingredient")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.InsurancePlan:
		if impl, ok := w.Concrete.(InsurancePlanUpdate); ok {
			result, err := impl.UpdateInsurancePlan(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "InsurancePlan")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Invoice:
		if impl, ok := w.Concrete.(InvoiceUpdate); ok {
			result, err := impl.UpdateInvoice(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Invoice")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Library:
		if impl, ok := w.Concrete.(LibraryUpdate); ok {
			result, err := impl.UpdateLibrary(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Library")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Linkage:
		if impl, ok := w.Concrete.(LinkageUpdate); ok {
			result, err := impl.UpdateLinkage(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Linkage")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.List:
		if impl, ok := w.Concrete.(ListUpdate); ok {
			result, err := impl.UpdateList(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "List")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Location:
		if impl, ok := w.Concrete.(LocationUpdate); ok {
			result, err := impl.UpdateLocation(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Location")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ManufacturedItemDefinition:
		if impl, ok := w.Concrete.(ManufacturedItemDefinitionUpdate); ok {
			result, err := impl.UpdateManufacturedItemDefinition(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "ManufacturedItemDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Measure:
		if impl, ok := w.Concrete.(MeasureUpdate); ok {
			result, err := impl.UpdateMeasure(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Measure")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.MeasureReport:
		if impl, ok := w.Concrete.(MeasureReportUpdate); ok {
			result, err := impl.UpdateMeasureReport(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "MeasureReport")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Media:
		if impl, ok := w.Concrete.(MediaUpdate); ok {
			result, err := impl.UpdateMedia(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Media")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Medication:
		if impl, ok := w.Concrete.(MedicationUpdate); ok {
			result, err := impl.UpdateMedication(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Medication")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.MedicationAdministration:
		if impl, ok := w.Concrete.(MedicationAdministrationUpdate); ok {
			result, err := impl.UpdateMedicationAdministration(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "MedicationAdministration")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.MedicationDispense:
		if impl, ok := w.Concrete.(MedicationDispenseUpdate); ok {
			result, err := impl.UpdateMedicationDispense(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "MedicationDispense")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.MedicationKnowledge:
		if impl, ok := w.Concrete.(MedicationKnowledgeUpdate); ok {
			result, err := impl.UpdateMedicationKnowledge(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "MedicationKnowledge")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.MedicationRequest:
		if impl, ok := w.Concrete.(MedicationRequestUpdate); ok {
			result, err := impl.UpdateMedicationRequest(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "MedicationRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.MedicationStatement:
		if impl, ok := w.Concrete.(MedicationStatementUpdate); ok {
			result, err := impl.UpdateMedicationStatement(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "MedicationStatement")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.MedicinalProductDefinition:
		if impl, ok := w.Concrete.(MedicinalProductDefinitionUpdate); ok {
			result, err := impl.UpdateMedicinalProductDefinition(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "MedicinalProductDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.MessageDefinition:
		if impl, ok := w.Concrete.(MessageDefinitionUpdate); ok {
			result, err := impl.UpdateMessageDefinition(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "MessageDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.MessageHeader:
		if impl, ok := w.Concrete.(MessageHeaderUpdate); ok {
			result, err := impl.UpdateMessageHeader(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "MessageHeader")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.MolecularSequence:
		if impl, ok := w.Concrete.(MolecularSequenceUpdate); ok {
			result, err := impl.UpdateMolecularSequence(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "MolecularSequence")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.NamingSystem:
		if impl, ok := w.Concrete.(NamingSystemUpdate); ok {
			result, err := impl.UpdateNamingSystem(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "NamingSystem")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.NutritionOrder:
		if impl, ok := w.Concrete.(NutritionOrderUpdate); ok {
			result, err := impl.UpdateNutritionOrder(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "NutritionOrder")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.NutritionProduct:
		if impl, ok := w.Concrete.(NutritionProductUpdate); ok {
			result, err := impl.UpdateNutritionProduct(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "NutritionProduct")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Observation:
		if impl, ok := w.Concrete.(ObservationUpdate); ok {
			result, err := impl.UpdateObservation(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Observation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ObservationDefinition:
		if impl, ok := w.Concrete.(ObservationDefinitionUpdate); ok {
			result, err := impl.UpdateObservationDefinition(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "ObservationDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.OperationDefinition:
		if impl, ok := w.Concrete.(OperationDefinitionUpdate); ok {
			result, err := impl.UpdateOperationDefinition(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "OperationDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.OperationOutcome:
		if impl, ok := w.Concrete.(OperationOutcomeUpdate); ok {
			result, err := impl.UpdateOperationOutcome(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "OperationOutcome")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Organization:
		if impl, ok := w.Concrete.(OrganizationUpdate); ok {
			result, err := impl.UpdateOrganization(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Organization")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.OrganizationAffiliation:
		if impl, ok := w.Concrete.(OrganizationAffiliationUpdate); ok {
			result, err := impl.UpdateOrganizationAffiliation(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "OrganizationAffiliation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.PackagedProductDefinition:
		if impl, ok := w.Concrete.(PackagedProductDefinitionUpdate); ok {
			result, err := impl.UpdatePackagedProductDefinition(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "PackagedProductDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Parameters:
		if impl, ok := w.Concrete.(ParametersUpdate); ok {
			result, err := impl.UpdateParameters(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Parameters")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Patient:
		if impl, ok := w.Concrete.(PatientUpdate); ok {
			result, err := impl.UpdatePatient(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Patient")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.PaymentNotice:
		if impl, ok := w.Concrete.(PaymentNoticeUpdate); ok {
			result, err := impl.UpdatePaymentNotice(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "PaymentNotice")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.PaymentReconciliation:
		if impl, ok := w.Concrete.(PaymentReconciliationUpdate); ok {
			result, err := impl.UpdatePaymentReconciliation(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "PaymentReconciliation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Person:
		if impl, ok := w.Concrete.(PersonUpdate); ok {
			result, err := impl.UpdatePerson(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Person")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.PlanDefinition:
		if impl, ok := w.Concrete.(PlanDefinitionUpdate); ok {
			result, err := impl.UpdatePlanDefinition(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "PlanDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Practitioner:
		if impl, ok := w.Concrete.(PractitionerUpdate); ok {
			result, err := impl.UpdatePractitioner(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Practitioner")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.PractitionerRole:
		if impl, ok := w.Concrete.(PractitionerRoleUpdate); ok {
			result, err := impl.UpdatePractitionerRole(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "PractitionerRole")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Procedure:
		if impl, ok := w.Concrete.(ProcedureUpdate); ok {
			result, err := impl.UpdateProcedure(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Procedure")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Provenance:
		if impl, ok := w.Concrete.(ProvenanceUpdate); ok {
			result, err := impl.UpdateProvenance(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Provenance")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Questionnaire:
		if impl, ok := w.Concrete.(QuestionnaireUpdate); ok {
			result, err := impl.UpdateQuestionnaire(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Questionnaire")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.QuestionnaireResponse:
		if impl, ok := w.Concrete.(QuestionnaireResponseUpdate); ok {
			result, err := impl.UpdateQuestionnaireResponse(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "QuestionnaireResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.RegulatedAuthorization:
		if impl, ok := w.Concrete.(RegulatedAuthorizationUpdate); ok {
			result, err := impl.UpdateRegulatedAuthorization(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "RegulatedAuthorization")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.RelatedPerson:
		if impl, ok := w.Concrete.(RelatedPersonUpdate); ok {
			result, err := impl.UpdateRelatedPerson(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "RelatedPerson")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.RequestGroup:
		if impl, ok := w.Concrete.(RequestGroupUpdate); ok {
			result, err := impl.UpdateRequestGroup(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "RequestGroup")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ResearchDefinition:
		if impl, ok := w.Concrete.(ResearchDefinitionUpdate); ok {
			result, err := impl.UpdateResearchDefinition(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "ResearchDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ResearchElementDefinition:
		if impl, ok := w.Concrete.(ResearchElementDefinitionUpdate); ok {
			result, err := impl.UpdateResearchElementDefinition(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "ResearchElementDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ResearchStudy:
		if impl, ok := w.Concrete.(ResearchStudyUpdate); ok {
			result, err := impl.UpdateResearchStudy(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "ResearchStudy")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ResearchSubject:
		if impl, ok := w.Concrete.(ResearchSubjectUpdate); ok {
			result, err := impl.UpdateResearchSubject(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "ResearchSubject")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.RiskAssessment:
		if impl, ok := w.Concrete.(RiskAssessmentUpdate); ok {
			result, err := impl.UpdateRiskAssessment(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "RiskAssessment")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Schedule:
		if impl, ok := w.Concrete.(ScheduleUpdate); ok {
			result, err := impl.UpdateSchedule(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Schedule")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.SearchParameter:
		if impl, ok := w.Concrete.(SearchParameterUpdate); ok {
			result, err := impl.UpdateSearchParameter(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "SearchParameter")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ServiceRequest:
		if impl, ok := w.Concrete.(ServiceRequestUpdate); ok {
			result, err := impl.UpdateServiceRequest(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "ServiceRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Slot:
		if impl, ok := w.Concrete.(SlotUpdate); ok {
			result, err := impl.UpdateSlot(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Slot")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Specimen:
		if impl, ok := w.Concrete.(SpecimenUpdate); ok {
			result, err := impl.UpdateSpecimen(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Specimen")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.SpecimenDefinition:
		if impl, ok := w.Concrete.(SpecimenDefinitionUpdate); ok {
			result, err := impl.UpdateSpecimenDefinition(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "SpecimenDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.StructureDefinition:
		if impl, ok := w.Concrete.(StructureDefinitionUpdate); ok {
			result, err := impl.UpdateStructureDefinition(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "StructureDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.StructureMap:
		if impl, ok := w.Concrete.(StructureMapUpdate); ok {
			result, err := impl.UpdateStructureMap(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "StructureMap")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Subscription:
		if impl, ok := w.Concrete.(SubscriptionUpdate); ok {
			result, err := impl.UpdateSubscription(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Subscription")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.SubscriptionStatus:
		if impl, ok := w.Concrete.(SubscriptionStatusUpdate); ok {
			result, err := impl.UpdateSubscriptionStatus(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "SubscriptionStatus")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.SubscriptionTopic:
		if impl, ok := w.Concrete.(SubscriptionTopicUpdate); ok {
			result, err := impl.UpdateSubscriptionTopic(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "SubscriptionTopic")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Substance:
		if impl, ok := w.Concrete.(SubstanceUpdate); ok {
			result, err := impl.UpdateSubstance(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Substance")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.SubstanceDefinition:
		if impl, ok := w.Concrete.(SubstanceDefinitionUpdate); ok {
			result, err := impl.UpdateSubstanceDefinition(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "SubstanceDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.SupplyDelivery:
		if impl, ok := w.Concrete.(SupplyDeliveryUpdate); ok {
			result, err := impl.UpdateSupplyDelivery(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "SupplyDelivery")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.SupplyRequest:
		if impl, ok := w.Concrete.(SupplyRequestUpdate); ok {
			result, err := impl.UpdateSupplyRequest(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "SupplyRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.Task:
		if impl, ok := w.Concrete.(TaskUpdate); ok {
			result, err := impl.UpdateTask(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "Task")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.TerminologyCapabilities:
		if impl, ok := w.Concrete.(TerminologyCapabilitiesUpdate); ok {
			result, err := impl.UpdateTerminologyCapabilities(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "TerminologyCapabilities")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.TestReport:
		if impl, ok := w.Concrete.(TestReportUpdate); ok {
			result, err := impl.UpdateTestReport(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "TestReport")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.TestScript:
		if impl, ok := w.Concrete.(TestScriptUpdate); ok {
			result, err := impl.UpdateTestScript(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "TestScript")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.ValueSet:
		if impl, ok := w.Concrete.(ValueSetUpdate); ok {
			result, err := impl.UpdateValueSet(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "ValueSet")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.VerificationResult:
		if impl, ok := w.Concrete.(VerificationResultUpdate); ok {
			result, err := impl.UpdateVerificationResult(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "VerificationResult")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case r4b.VisionPrescription:
		if impl, ok := w.Concrete.(VisionPrescriptionUpdate); ok {
			result, err := impl.UpdateVisionPrescription(ctx, r)
			if err != nil {
				return update.Result[model.Resource]{}, err
			}
			return update.Result[model.Resource]{

				Created:  result.Created,
				Resource: result.Resource,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericUpdate); ok {
			return gen.Update(ctx, resource)
		}
		return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("update not implemented for " + "VisionPrescription")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
		Code:        r4b.Code{Value: ptr.To("processing")},
		Diagnostics: &r4b.String{Value: ptr.To("invalid resource type: " + resource.ResourceType())},
		Severity:    r4b.Code{Value: ptr.To("fatal")},
	}}}
}
func (w Generic) Delete(ctx context.Context, resourceType string, id string) error {
	switch resourceType {
	case "Account":
		if impl, ok := w.Concrete.(AccountDelete); ok {
			return impl.DeleteAccount(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Account")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ActivityDefinition":
		if impl, ok := w.Concrete.(ActivityDefinitionDelete); ok {
			return impl.DeleteActivityDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "ActivityDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "AdministrableProductDefinition":
		if impl, ok := w.Concrete.(AdministrableProductDefinitionDelete); ok {
			return impl.DeleteAdministrableProductDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "AdministrableProductDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "AdverseEvent":
		if impl, ok := w.Concrete.(AdverseEventDelete); ok {
			return impl.DeleteAdverseEvent(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "AdverseEvent")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "AllergyIntolerance":
		if impl, ok := w.Concrete.(AllergyIntoleranceDelete); ok {
			return impl.DeleteAllergyIntolerance(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "AllergyIntolerance")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Appointment":
		if impl, ok := w.Concrete.(AppointmentDelete); ok {
			return impl.DeleteAppointment(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Appointment")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "AppointmentResponse":
		if impl, ok := w.Concrete.(AppointmentResponseDelete); ok {
			return impl.DeleteAppointmentResponse(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "AppointmentResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "AuditEvent":
		if impl, ok := w.Concrete.(AuditEventDelete); ok {
			return impl.DeleteAuditEvent(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "AuditEvent")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Basic":
		if impl, ok := w.Concrete.(BasicDelete); ok {
			return impl.DeleteBasic(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Basic")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Binary":
		if impl, ok := w.Concrete.(BinaryDelete); ok {
			return impl.DeleteBinary(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Binary")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "BiologicallyDerivedProduct":
		if impl, ok := w.Concrete.(BiologicallyDerivedProductDelete); ok {
			return impl.DeleteBiologicallyDerivedProduct(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "BiologicallyDerivedProduct")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "BodyStructure":
		if impl, ok := w.Concrete.(BodyStructureDelete); ok {
			return impl.DeleteBodyStructure(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "BodyStructure")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Bundle":
		if impl, ok := w.Concrete.(BundleDelete); ok {
			return impl.DeleteBundle(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Bundle")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "CapabilityStatement":
		if impl, ok := w.Concrete.(CapabilityStatementDelete); ok {
			return impl.DeleteCapabilityStatement(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "CapabilityStatement")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "CarePlan":
		if impl, ok := w.Concrete.(CarePlanDelete); ok {
			return impl.DeleteCarePlan(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "CarePlan")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "CareTeam":
		if impl, ok := w.Concrete.(CareTeamDelete); ok {
			return impl.DeleteCareTeam(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "CareTeam")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "CatalogEntry":
		if impl, ok := w.Concrete.(CatalogEntryDelete); ok {
			return impl.DeleteCatalogEntry(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "CatalogEntry")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ChargeItem":
		if impl, ok := w.Concrete.(ChargeItemDelete); ok {
			return impl.DeleteChargeItem(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "ChargeItem")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ChargeItemDefinition":
		if impl, ok := w.Concrete.(ChargeItemDefinitionDelete); ok {
			return impl.DeleteChargeItemDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "ChargeItemDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Citation":
		if impl, ok := w.Concrete.(CitationDelete); ok {
			return impl.DeleteCitation(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Citation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Claim":
		if impl, ok := w.Concrete.(ClaimDelete); ok {
			return impl.DeleteClaim(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Claim")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ClaimResponse":
		if impl, ok := w.Concrete.(ClaimResponseDelete); ok {
			return impl.DeleteClaimResponse(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "ClaimResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ClinicalImpression":
		if impl, ok := w.Concrete.(ClinicalImpressionDelete); ok {
			return impl.DeleteClinicalImpression(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "ClinicalImpression")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ClinicalUseDefinition":
		if impl, ok := w.Concrete.(ClinicalUseDefinitionDelete); ok {
			return impl.DeleteClinicalUseDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "ClinicalUseDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "CodeSystem":
		if impl, ok := w.Concrete.(CodeSystemDelete); ok {
			return impl.DeleteCodeSystem(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "CodeSystem")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Communication":
		if impl, ok := w.Concrete.(CommunicationDelete); ok {
			return impl.DeleteCommunication(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Communication")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "CommunicationRequest":
		if impl, ok := w.Concrete.(CommunicationRequestDelete); ok {
			return impl.DeleteCommunicationRequest(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "CommunicationRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "CompartmentDefinition":
		if impl, ok := w.Concrete.(CompartmentDefinitionDelete); ok {
			return impl.DeleteCompartmentDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "CompartmentDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Composition":
		if impl, ok := w.Concrete.(CompositionDelete); ok {
			return impl.DeleteComposition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Composition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ConceptMap":
		if impl, ok := w.Concrete.(ConceptMapDelete); ok {
			return impl.DeleteConceptMap(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "ConceptMap")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Condition":
		if impl, ok := w.Concrete.(ConditionDelete); ok {
			return impl.DeleteCondition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Condition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Consent":
		if impl, ok := w.Concrete.(ConsentDelete); ok {
			return impl.DeleteConsent(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Consent")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Contract":
		if impl, ok := w.Concrete.(ContractDelete); ok {
			return impl.DeleteContract(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Contract")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Coverage":
		if impl, ok := w.Concrete.(CoverageDelete); ok {
			return impl.DeleteCoverage(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Coverage")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "CoverageEligibilityRequest":
		if impl, ok := w.Concrete.(CoverageEligibilityRequestDelete); ok {
			return impl.DeleteCoverageEligibilityRequest(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "CoverageEligibilityRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "CoverageEligibilityResponse":
		if impl, ok := w.Concrete.(CoverageEligibilityResponseDelete); ok {
			return impl.DeleteCoverageEligibilityResponse(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "CoverageEligibilityResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "DetectedIssue":
		if impl, ok := w.Concrete.(DetectedIssueDelete); ok {
			return impl.DeleteDetectedIssue(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "DetectedIssue")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Device":
		if impl, ok := w.Concrete.(DeviceDelete); ok {
			return impl.DeleteDevice(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Device")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "DeviceDefinition":
		if impl, ok := w.Concrete.(DeviceDefinitionDelete); ok {
			return impl.DeleteDeviceDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "DeviceDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "DeviceMetric":
		if impl, ok := w.Concrete.(DeviceMetricDelete); ok {
			return impl.DeleteDeviceMetric(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "DeviceMetric")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "DeviceRequest":
		if impl, ok := w.Concrete.(DeviceRequestDelete); ok {
			return impl.DeleteDeviceRequest(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "DeviceRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "DeviceUseStatement":
		if impl, ok := w.Concrete.(DeviceUseStatementDelete); ok {
			return impl.DeleteDeviceUseStatement(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "DeviceUseStatement")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "DiagnosticReport":
		if impl, ok := w.Concrete.(DiagnosticReportDelete); ok {
			return impl.DeleteDiagnosticReport(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "DiagnosticReport")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "DocumentManifest":
		if impl, ok := w.Concrete.(DocumentManifestDelete); ok {
			return impl.DeleteDocumentManifest(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "DocumentManifest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "DocumentReference":
		if impl, ok := w.Concrete.(DocumentReferenceDelete); ok {
			return impl.DeleteDocumentReference(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "DocumentReference")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Encounter":
		if impl, ok := w.Concrete.(EncounterDelete); ok {
			return impl.DeleteEncounter(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Encounter")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Endpoint":
		if impl, ok := w.Concrete.(EndpointDelete); ok {
			return impl.DeleteEndpoint(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Endpoint")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "EnrollmentRequest":
		if impl, ok := w.Concrete.(EnrollmentRequestDelete); ok {
			return impl.DeleteEnrollmentRequest(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "EnrollmentRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "EnrollmentResponse":
		if impl, ok := w.Concrete.(EnrollmentResponseDelete); ok {
			return impl.DeleteEnrollmentResponse(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "EnrollmentResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "EpisodeOfCare":
		if impl, ok := w.Concrete.(EpisodeOfCareDelete); ok {
			return impl.DeleteEpisodeOfCare(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "EpisodeOfCare")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "EventDefinition":
		if impl, ok := w.Concrete.(EventDefinitionDelete); ok {
			return impl.DeleteEventDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "EventDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Evidence":
		if impl, ok := w.Concrete.(EvidenceDelete); ok {
			return impl.DeleteEvidence(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Evidence")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "EvidenceReport":
		if impl, ok := w.Concrete.(EvidenceReportDelete); ok {
			return impl.DeleteEvidenceReport(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "EvidenceReport")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "EvidenceVariable":
		if impl, ok := w.Concrete.(EvidenceVariableDelete); ok {
			return impl.DeleteEvidenceVariable(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "EvidenceVariable")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ExampleScenario":
		if impl, ok := w.Concrete.(ExampleScenarioDelete); ok {
			return impl.DeleteExampleScenario(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "ExampleScenario")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ExplanationOfBenefit":
		if impl, ok := w.Concrete.(ExplanationOfBenefitDelete); ok {
			return impl.DeleteExplanationOfBenefit(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "ExplanationOfBenefit")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "FamilyMemberHistory":
		if impl, ok := w.Concrete.(FamilyMemberHistoryDelete); ok {
			return impl.DeleteFamilyMemberHistory(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "FamilyMemberHistory")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Flag":
		if impl, ok := w.Concrete.(FlagDelete); ok {
			return impl.DeleteFlag(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Flag")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Goal":
		if impl, ok := w.Concrete.(GoalDelete); ok {
			return impl.DeleteGoal(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Goal")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "GraphDefinition":
		if impl, ok := w.Concrete.(GraphDefinitionDelete); ok {
			return impl.DeleteGraphDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "GraphDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Group":
		if impl, ok := w.Concrete.(GroupDelete); ok {
			return impl.DeleteGroup(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Group")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "GuidanceResponse":
		if impl, ok := w.Concrete.(GuidanceResponseDelete); ok {
			return impl.DeleteGuidanceResponse(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "GuidanceResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "HealthcareService":
		if impl, ok := w.Concrete.(HealthcareServiceDelete); ok {
			return impl.DeleteHealthcareService(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "HealthcareService")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ImagingStudy":
		if impl, ok := w.Concrete.(ImagingStudyDelete); ok {
			return impl.DeleteImagingStudy(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "ImagingStudy")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Immunization":
		if impl, ok := w.Concrete.(ImmunizationDelete); ok {
			return impl.DeleteImmunization(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Immunization")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ImmunizationEvaluation":
		if impl, ok := w.Concrete.(ImmunizationEvaluationDelete); ok {
			return impl.DeleteImmunizationEvaluation(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "ImmunizationEvaluation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ImmunizationRecommendation":
		if impl, ok := w.Concrete.(ImmunizationRecommendationDelete); ok {
			return impl.DeleteImmunizationRecommendation(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "ImmunizationRecommendation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ImplementationGuide":
		if impl, ok := w.Concrete.(ImplementationGuideDelete); ok {
			return impl.DeleteImplementationGuide(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "ImplementationGuide")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Ingredient":
		if impl, ok := w.Concrete.(IngredientDelete); ok {
			return impl.DeleteIngredient(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Ingredient")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "InsurancePlan":
		if impl, ok := w.Concrete.(InsurancePlanDelete); ok {
			return impl.DeleteInsurancePlan(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "InsurancePlan")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Invoice":
		if impl, ok := w.Concrete.(InvoiceDelete); ok {
			return impl.DeleteInvoice(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Invoice")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Library":
		if impl, ok := w.Concrete.(LibraryDelete); ok {
			return impl.DeleteLibrary(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Library")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Linkage":
		if impl, ok := w.Concrete.(LinkageDelete); ok {
			return impl.DeleteLinkage(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Linkage")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "List":
		if impl, ok := w.Concrete.(ListDelete); ok {
			return impl.DeleteList(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "List")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Location":
		if impl, ok := w.Concrete.(LocationDelete); ok {
			return impl.DeleteLocation(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Location")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ManufacturedItemDefinition":
		if impl, ok := w.Concrete.(ManufacturedItemDefinitionDelete); ok {
			return impl.DeleteManufacturedItemDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "ManufacturedItemDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Measure":
		if impl, ok := w.Concrete.(MeasureDelete); ok {
			return impl.DeleteMeasure(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Measure")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MeasureReport":
		if impl, ok := w.Concrete.(MeasureReportDelete); ok {
			return impl.DeleteMeasureReport(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "MeasureReport")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Media":
		if impl, ok := w.Concrete.(MediaDelete); ok {
			return impl.DeleteMedia(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Media")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Medication":
		if impl, ok := w.Concrete.(MedicationDelete); ok {
			return impl.DeleteMedication(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Medication")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MedicationAdministration":
		if impl, ok := w.Concrete.(MedicationAdministrationDelete); ok {
			return impl.DeleteMedicationAdministration(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "MedicationAdministration")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MedicationDispense":
		if impl, ok := w.Concrete.(MedicationDispenseDelete); ok {
			return impl.DeleteMedicationDispense(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "MedicationDispense")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MedicationKnowledge":
		if impl, ok := w.Concrete.(MedicationKnowledgeDelete); ok {
			return impl.DeleteMedicationKnowledge(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "MedicationKnowledge")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MedicationRequest":
		if impl, ok := w.Concrete.(MedicationRequestDelete); ok {
			return impl.DeleteMedicationRequest(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "MedicationRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MedicationStatement":
		if impl, ok := w.Concrete.(MedicationStatementDelete); ok {
			return impl.DeleteMedicationStatement(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "MedicationStatement")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MedicinalProductDefinition":
		if impl, ok := w.Concrete.(MedicinalProductDefinitionDelete); ok {
			return impl.DeleteMedicinalProductDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "MedicinalProductDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MessageDefinition":
		if impl, ok := w.Concrete.(MessageDefinitionDelete); ok {
			return impl.DeleteMessageDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "MessageDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MessageHeader":
		if impl, ok := w.Concrete.(MessageHeaderDelete); ok {
			return impl.DeleteMessageHeader(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "MessageHeader")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MolecularSequence":
		if impl, ok := w.Concrete.(MolecularSequenceDelete); ok {
			return impl.DeleteMolecularSequence(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "MolecularSequence")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "NamingSystem":
		if impl, ok := w.Concrete.(NamingSystemDelete); ok {
			return impl.DeleteNamingSystem(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "NamingSystem")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "NutritionOrder":
		if impl, ok := w.Concrete.(NutritionOrderDelete); ok {
			return impl.DeleteNutritionOrder(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "NutritionOrder")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "NutritionProduct":
		if impl, ok := w.Concrete.(NutritionProductDelete); ok {
			return impl.DeleteNutritionProduct(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "NutritionProduct")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Observation":
		if impl, ok := w.Concrete.(ObservationDelete); ok {
			return impl.DeleteObservation(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Observation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ObservationDefinition":
		if impl, ok := w.Concrete.(ObservationDefinitionDelete); ok {
			return impl.DeleteObservationDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "ObservationDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "OperationDefinition":
		if impl, ok := w.Concrete.(OperationDefinitionDelete); ok {
			return impl.DeleteOperationDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "OperationDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "OperationOutcome":
		if impl, ok := w.Concrete.(OperationOutcomeDelete); ok {
			return impl.DeleteOperationOutcome(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "OperationOutcome")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Organization":
		if impl, ok := w.Concrete.(OrganizationDelete); ok {
			return impl.DeleteOrganization(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Organization")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "OrganizationAffiliation":
		if impl, ok := w.Concrete.(OrganizationAffiliationDelete); ok {
			return impl.DeleteOrganizationAffiliation(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "OrganizationAffiliation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "PackagedProductDefinition":
		if impl, ok := w.Concrete.(PackagedProductDefinitionDelete); ok {
			return impl.DeletePackagedProductDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "PackagedProductDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Parameters":
		if impl, ok := w.Concrete.(ParametersDelete); ok {
			return impl.DeleteParameters(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Parameters")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Patient":
		if impl, ok := w.Concrete.(PatientDelete); ok {
			return impl.DeletePatient(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Patient")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "PaymentNotice":
		if impl, ok := w.Concrete.(PaymentNoticeDelete); ok {
			return impl.DeletePaymentNotice(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "PaymentNotice")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "PaymentReconciliation":
		if impl, ok := w.Concrete.(PaymentReconciliationDelete); ok {
			return impl.DeletePaymentReconciliation(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "PaymentReconciliation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Person":
		if impl, ok := w.Concrete.(PersonDelete); ok {
			return impl.DeletePerson(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Person")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "PlanDefinition":
		if impl, ok := w.Concrete.(PlanDefinitionDelete); ok {
			return impl.DeletePlanDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "PlanDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Practitioner":
		if impl, ok := w.Concrete.(PractitionerDelete); ok {
			return impl.DeletePractitioner(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Practitioner")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "PractitionerRole":
		if impl, ok := w.Concrete.(PractitionerRoleDelete); ok {
			return impl.DeletePractitionerRole(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "PractitionerRole")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Procedure":
		if impl, ok := w.Concrete.(ProcedureDelete); ok {
			return impl.DeleteProcedure(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Procedure")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Provenance":
		if impl, ok := w.Concrete.(ProvenanceDelete); ok {
			return impl.DeleteProvenance(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Provenance")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Questionnaire":
		if impl, ok := w.Concrete.(QuestionnaireDelete); ok {
			return impl.DeleteQuestionnaire(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Questionnaire")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "QuestionnaireResponse":
		if impl, ok := w.Concrete.(QuestionnaireResponseDelete); ok {
			return impl.DeleteQuestionnaireResponse(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "QuestionnaireResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "RegulatedAuthorization":
		if impl, ok := w.Concrete.(RegulatedAuthorizationDelete); ok {
			return impl.DeleteRegulatedAuthorization(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "RegulatedAuthorization")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "RelatedPerson":
		if impl, ok := w.Concrete.(RelatedPersonDelete); ok {
			return impl.DeleteRelatedPerson(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "RelatedPerson")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "RequestGroup":
		if impl, ok := w.Concrete.(RequestGroupDelete); ok {
			return impl.DeleteRequestGroup(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "RequestGroup")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ResearchDefinition":
		if impl, ok := w.Concrete.(ResearchDefinitionDelete); ok {
			return impl.DeleteResearchDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "ResearchDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ResearchElementDefinition":
		if impl, ok := w.Concrete.(ResearchElementDefinitionDelete); ok {
			return impl.DeleteResearchElementDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "ResearchElementDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ResearchStudy":
		if impl, ok := w.Concrete.(ResearchStudyDelete); ok {
			return impl.DeleteResearchStudy(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "ResearchStudy")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ResearchSubject":
		if impl, ok := w.Concrete.(ResearchSubjectDelete); ok {
			return impl.DeleteResearchSubject(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "ResearchSubject")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "RiskAssessment":
		if impl, ok := w.Concrete.(RiskAssessmentDelete); ok {
			return impl.DeleteRiskAssessment(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "RiskAssessment")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Schedule":
		if impl, ok := w.Concrete.(ScheduleDelete); ok {
			return impl.DeleteSchedule(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Schedule")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "SearchParameter":
		if impl, ok := w.Concrete.(SearchParameterDelete); ok {
			return impl.DeleteSearchParameter(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "SearchParameter")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ServiceRequest":
		if impl, ok := w.Concrete.(ServiceRequestDelete); ok {
			return impl.DeleteServiceRequest(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "ServiceRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Slot":
		if impl, ok := w.Concrete.(SlotDelete); ok {
			return impl.DeleteSlot(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Slot")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Specimen":
		if impl, ok := w.Concrete.(SpecimenDelete); ok {
			return impl.DeleteSpecimen(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Specimen")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "SpecimenDefinition":
		if impl, ok := w.Concrete.(SpecimenDefinitionDelete); ok {
			return impl.DeleteSpecimenDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "SpecimenDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "StructureDefinition":
		if impl, ok := w.Concrete.(StructureDefinitionDelete); ok {
			return impl.DeleteStructureDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "StructureDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "StructureMap":
		if impl, ok := w.Concrete.(StructureMapDelete); ok {
			return impl.DeleteStructureMap(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "StructureMap")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Subscription":
		if impl, ok := w.Concrete.(SubscriptionDelete); ok {
			return impl.DeleteSubscription(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Subscription")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "SubscriptionStatus":
		if impl, ok := w.Concrete.(SubscriptionStatusDelete); ok {
			return impl.DeleteSubscriptionStatus(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "SubscriptionStatus")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "SubscriptionTopic":
		if impl, ok := w.Concrete.(SubscriptionTopicDelete); ok {
			return impl.DeleteSubscriptionTopic(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "SubscriptionTopic")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Substance":
		if impl, ok := w.Concrete.(SubstanceDelete); ok {
			return impl.DeleteSubstance(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Substance")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "SubstanceDefinition":
		if impl, ok := w.Concrete.(SubstanceDefinitionDelete); ok {
			return impl.DeleteSubstanceDefinition(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "SubstanceDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "SupplyDelivery":
		if impl, ok := w.Concrete.(SupplyDeliveryDelete); ok {
			return impl.DeleteSupplyDelivery(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "SupplyDelivery")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "SupplyRequest":
		if impl, ok := w.Concrete.(SupplyRequestDelete); ok {
			return impl.DeleteSupplyRequest(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "SupplyRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Task":
		if impl, ok := w.Concrete.(TaskDelete); ok {
			return impl.DeleteTask(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "Task")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "TerminologyCapabilities":
		if impl, ok := w.Concrete.(TerminologyCapabilitiesDelete); ok {
			return impl.DeleteTerminologyCapabilities(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "TerminologyCapabilities")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "TestReport":
		if impl, ok := w.Concrete.(TestReportDelete); ok {
			return impl.DeleteTestReport(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "TestReport")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "TestScript":
		if impl, ok := w.Concrete.(TestScriptDelete); ok {
			return impl.DeleteTestScript(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "TestScript")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ValueSet":
		if impl, ok := w.Concrete.(ValueSetDelete); ok {
			return impl.DeleteValueSet(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "ValueSet")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "VerificationResult":
		if impl, ok := w.Concrete.(VerificationResultDelete); ok {
			return impl.DeleteVerificationResult(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "VerificationResult")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "VisionPrescription":
		if impl, ok := w.Concrete.(VisionPrescriptionDelete); ok {
			return impl.DeleteVisionPrescription(ctx, id)
		}
		if gen, ok := w.Concrete.(capabilities.GenericDelete); ok {
			return gen.Delete(ctx, resourceType, id)
		}
		return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("delete not implemented for " + "VisionPrescription")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
		Code:        r4b.Code{Value: ptr.To("processing")},
		Diagnostics: &r4b.String{Value: ptr.To("invalid resource type: " + resourceType)},
		Severity:    r4b.Code{Value: ptr.To("fatal")},
	}}}
}
func (w Generic) Search(ctx context.Context, resourceType string, parameters search.Parameters, options search.Options) (search.Result[model.Resource], error) {
	switch resourceType {
	case "Account":
		if impl, ok := w.Concrete.(AccountSearch); ok {
			result, err := impl.SearchAccount(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Account")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ActivityDefinition":
		if impl, ok := w.Concrete.(ActivityDefinitionSearch); ok {
			result, err := impl.SearchActivityDefinition(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "ActivityDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "AdministrableProductDefinition":
		if impl, ok := w.Concrete.(AdministrableProductDefinitionSearch); ok {
			result, err := impl.SearchAdministrableProductDefinition(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "AdministrableProductDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "AdverseEvent":
		if impl, ok := w.Concrete.(AdverseEventSearch); ok {
			result, err := impl.SearchAdverseEvent(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "AdverseEvent")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "AllergyIntolerance":
		if impl, ok := w.Concrete.(AllergyIntoleranceSearch); ok {
			result, err := impl.SearchAllergyIntolerance(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "AllergyIntolerance")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Appointment":
		if impl, ok := w.Concrete.(AppointmentSearch); ok {
			result, err := impl.SearchAppointment(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Appointment")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "AppointmentResponse":
		if impl, ok := w.Concrete.(AppointmentResponseSearch); ok {
			result, err := impl.SearchAppointmentResponse(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "AppointmentResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "AuditEvent":
		if impl, ok := w.Concrete.(AuditEventSearch); ok {
			result, err := impl.SearchAuditEvent(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "AuditEvent")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Basic":
		if impl, ok := w.Concrete.(BasicSearch); ok {
			result, err := impl.SearchBasic(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Basic")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Binary":
		if impl, ok := w.Concrete.(BinarySearch); ok {
			result, err := impl.SearchBinary(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Binary")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "BiologicallyDerivedProduct":
		if impl, ok := w.Concrete.(BiologicallyDerivedProductSearch); ok {
			result, err := impl.SearchBiologicallyDerivedProduct(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "BiologicallyDerivedProduct")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "BodyStructure":
		if impl, ok := w.Concrete.(BodyStructureSearch); ok {
			result, err := impl.SearchBodyStructure(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "BodyStructure")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Bundle":
		if impl, ok := w.Concrete.(BundleSearch); ok {
			result, err := impl.SearchBundle(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Bundle")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "CapabilityStatement":
		if impl, ok := w.Concrete.(CapabilityStatementSearch); ok {
			result, err := impl.SearchCapabilityStatement(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "CapabilityStatement")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "CarePlan":
		if impl, ok := w.Concrete.(CarePlanSearch); ok {
			result, err := impl.SearchCarePlan(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "CarePlan")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "CareTeam":
		if impl, ok := w.Concrete.(CareTeamSearch); ok {
			result, err := impl.SearchCareTeam(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "CareTeam")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "CatalogEntry":
		if impl, ok := w.Concrete.(CatalogEntrySearch); ok {
			result, err := impl.SearchCatalogEntry(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "CatalogEntry")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ChargeItem":
		if impl, ok := w.Concrete.(ChargeItemSearch); ok {
			result, err := impl.SearchChargeItem(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "ChargeItem")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ChargeItemDefinition":
		if impl, ok := w.Concrete.(ChargeItemDefinitionSearch); ok {
			result, err := impl.SearchChargeItemDefinition(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "ChargeItemDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Citation":
		if impl, ok := w.Concrete.(CitationSearch); ok {
			result, err := impl.SearchCitation(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Citation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Claim":
		if impl, ok := w.Concrete.(ClaimSearch); ok {
			result, err := impl.SearchClaim(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Claim")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ClaimResponse":
		if impl, ok := w.Concrete.(ClaimResponseSearch); ok {
			result, err := impl.SearchClaimResponse(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "ClaimResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ClinicalImpression":
		if impl, ok := w.Concrete.(ClinicalImpressionSearch); ok {
			result, err := impl.SearchClinicalImpression(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "ClinicalImpression")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ClinicalUseDefinition":
		if impl, ok := w.Concrete.(ClinicalUseDefinitionSearch); ok {
			result, err := impl.SearchClinicalUseDefinition(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "ClinicalUseDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "CodeSystem":
		if impl, ok := w.Concrete.(CodeSystemSearch); ok {
			result, err := impl.SearchCodeSystem(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "CodeSystem")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Communication":
		if impl, ok := w.Concrete.(CommunicationSearch); ok {
			result, err := impl.SearchCommunication(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Communication")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "CommunicationRequest":
		if impl, ok := w.Concrete.(CommunicationRequestSearch); ok {
			result, err := impl.SearchCommunicationRequest(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "CommunicationRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "CompartmentDefinition":
		if impl, ok := w.Concrete.(CompartmentDefinitionSearch); ok {
			result, err := impl.SearchCompartmentDefinition(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "CompartmentDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Composition":
		if impl, ok := w.Concrete.(CompositionSearch); ok {
			result, err := impl.SearchComposition(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Composition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ConceptMap":
		if impl, ok := w.Concrete.(ConceptMapSearch); ok {
			result, err := impl.SearchConceptMap(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "ConceptMap")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Condition":
		if impl, ok := w.Concrete.(ConditionSearch); ok {
			result, err := impl.SearchCondition(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Condition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Consent":
		if impl, ok := w.Concrete.(ConsentSearch); ok {
			result, err := impl.SearchConsent(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Consent")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Contract":
		if impl, ok := w.Concrete.(ContractSearch); ok {
			result, err := impl.SearchContract(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Contract")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Coverage":
		if impl, ok := w.Concrete.(CoverageSearch); ok {
			result, err := impl.SearchCoverage(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Coverage")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "CoverageEligibilityRequest":
		if impl, ok := w.Concrete.(CoverageEligibilityRequestSearch); ok {
			result, err := impl.SearchCoverageEligibilityRequest(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "CoverageEligibilityRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "CoverageEligibilityResponse":
		if impl, ok := w.Concrete.(CoverageEligibilityResponseSearch); ok {
			result, err := impl.SearchCoverageEligibilityResponse(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "CoverageEligibilityResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "DetectedIssue":
		if impl, ok := w.Concrete.(DetectedIssueSearch); ok {
			result, err := impl.SearchDetectedIssue(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "DetectedIssue")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Device":
		if impl, ok := w.Concrete.(DeviceSearch); ok {
			result, err := impl.SearchDevice(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Device")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "DeviceDefinition":
		if impl, ok := w.Concrete.(DeviceDefinitionSearch); ok {
			result, err := impl.SearchDeviceDefinition(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "DeviceDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "DeviceMetric":
		if impl, ok := w.Concrete.(DeviceMetricSearch); ok {
			result, err := impl.SearchDeviceMetric(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "DeviceMetric")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "DeviceRequest":
		if impl, ok := w.Concrete.(DeviceRequestSearch); ok {
			result, err := impl.SearchDeviceRequest(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "DeviceRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "DeviceUseStatement":
		if impl, ok := w.Concrete.(DeviceUseStatementSearch); ok {
			result, err := impl.SearchDeviceUseStatement(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "DeviceUseStatement")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "DiagnosticReport":
		if impl, ok := w.Concrete.(DiagnosticReportSearch); ok {
			result, err := impl.SearchDiagnosticReport(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "DiagnosticReport")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "DocumentManifest":
		if impl, ok := w.Concrete.(DocumentManifestSearch); ok {
			result, err := impl.SearchDocumentManifest(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "DocumentManifest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "DocumentReference":
		if impl, ok := w.Concrete.(DocumentReferenceSearch); ok {
			result, err := impl.SearchDocumentReference(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "DocumentReference")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Encounter":
		if impl, ok := w.Concrete.(EncounterSearch); ok {
			result, err := impl.SearchEncounter(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Encounter")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Endpoint":
		if impl, ok := w.Concrete.(EndpointSearch); ok {
			result, err := impl.SearchEndpoint(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Endpoint")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "EnrollmentRequest":
		if impl, ok := w.Concrete.(EnrollmentRequestSearch); ok {
			result, err := impl.SearchEnrollmentRequest(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "EnrollmentRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "EnrollmentResponse":
		if impl, ok := w.Concrete.(EnrollmentResponseSearch); ok {
			result, err := impl.SearchEnrollmentResponse(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "EnrollmentResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "EpisodeOfCare":
		if impl, ok := w.Concrete.(EpisodeOfCareSearch); ok {
			result, err := impl.SearchEpisodeOfCare(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "EpisodeOfCare")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "EventDefinition":
		if impl, ok := w.Concrete.(EventDefinitionSearch); ok {
			result, err := impl.SearchEventDefinition(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "EventDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Evidence":
		if impl, ok := w.Concrete.(EvidenceSearch); ok {
			result, err := impl.SearchEvidence(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Evidence")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "EvidenceReport":
		if impl, ok := w.Concrete.(EvidenceReportSearch); ok {
			result, err := impl.SearchEvidenceReport(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "EvidenceReport")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "EvidenceVariable":
		if impl, ok := w.Concrete.(EvidenceVariableSearch); ok {
			result, err := impl.SearchEvidenceVariable(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "EvidenceVariable")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ExampleScenario":
		if impl, ok := w.Concrete.(ExampleScenarioSearch); ok {
			result, err := impl.SearchExampleScenario(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "ExampleScenario")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ExplanationOfBenefit":
		if impl, ok := w.Concrete.(ExplanationOfBenefitSearch); ok {
			result, err := impl.SearchExplanationOfBenefit(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "ExplanationOfBenefit")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "FamilyMemberHistory":
		if impl, ok := w.Concrete.(FamilyMemberHistorySearch); ok {
			result, err := impl.SearchFamilyMemberHistory(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "FamilyMemberHistory")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Flag":
		if impl, ok := w.Concrete.(FlagSearch); ok {
			result, err := impl.SearchFlag(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Flag")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Goal":
		if impl, ok := w.Concrete.(GoalSearch); ok {
			result, err := impl.SearchGoal(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Goal")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "GraphDefinition":
		if impl, ok := w.Concrete.(GraphDefinitionSearch); ok {
			result, err := impl.SearchGraphDefinition(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "GraphDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Group":
		if impl, ok := w.Concrete.(GroupSearch); ok {
			result, err := impl.SearchGroup(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Group")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "GuidanceResponse":
		if impl, ok := w.Concrete.(GuidanceResponseSearch); ok {
			result, err := impl.SearchGuidanceResponse(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "GuidanceResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "HealthcareService":
		if impl, ok := w.Concrete.(HealthcareServiceSearch); ok {
			result, err := impl.SearchHealthcareService(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "HealthcareService")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ImagingStudy":
		if impl, ok := w.Concrete.(ImagingStudySearch); ok {
			result, err := impl.SearchImagingStudy(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "ImagingStudy")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Immunization":
		if impl, ok := w.Concrete.(ImmunizationSearch); ok {
			result, err := impl.SearchImmunization(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Immunization")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ImmunizationEvaluation":
		if impl, ok := w.Concrete.(ImmunizationEvaluationSearch); ok {
			result, err := impl.SearchImmunizationEvaluation(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "ImmunizationEvaluation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ImmunizationRecommendation":
		if impl, ok := w.Concrete.(ImmunizationRecommendationSearch); ok {
			result, err := impl.SearchImmunizationRecommendation(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "ImmunizationRecommendation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ImplementationGuide":
		if impl, ok := w.Concrete.(ImplementationGuideSearch); ok {
			result, err := impl.SearchImplementationGuide(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "ImplementationGuide")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Ingredient":
		if impl, ok := w.Concrete.(IngredientSearch); ok {
			result, err := impl.SearchIngredient(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Ingredient")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "InsurancePlan":
		if impl, ok := w.Concrete.(InsurancePlanSearch); ok {
			result, err := impl.SearchInsurancePlan(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "InsurancePlan")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Invoice":
		if impl, ok := w.Concrete.(InvoiceSearch); ok {
			result, err := impl.SearchInvoice(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Invoice")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Library":
		if impl, ok := w.Concrete.(LibrarySearch); ok {
			result, err := impl.SearchLibrary(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Library")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Linkage":
		if impl, ok := w.Concrete.(LinkageSearch); ok {
			result, err := impl.SearchLinkage(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Linkage")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "List":
		if impl, ok := w.Concrete.(ListSearch); ok {
			result, err := impl.SearchList(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "List")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Location":
		if impl, ok := w.Concrete.(LocationSearch); ok {
			result, err := impl.SearchLocation(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Location")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ManufacturedItemDefinition":
		if impl, ok := w.Concrete.(ManufacturedItemDefinitionSearch); ok {
			result, err := impl.SearchManufacturedItemDefinition(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "ManufacturedItemDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Measure":
		if impl, ok := w.Concrete.(MeasureSearch); ok {
			result, err := impl.SearchMeasure(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Measure")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MeasureReport":
		if impl, ok := w.Concrete.(MeasureReportSearch); ok {
			result, err := impl.SearchMeasureReport(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "MeasureReport")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Media":
		if impl, ok := w.Concrete.(MediaSearch); ok {
			result, err := impl.SearchMedia(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Media")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Medication":
		if impl, ok := w.Concrete.(MedicationSearch); ok {
			result, err := impl.SearchMedication(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Medication")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MedicationAdministration":
		if impl, ok := w.Concrete.(MedicationAdministrationSearch); ok {
			result, err := impl.SearchMedicationAdministration(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "MedicationAdministration")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MedicationDispense":
		if impl, ok := w.Concrete.(MedicationDispenseSearch); ok {
			result, err := impl.SearchMedicationDispense(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "MedicationDispense")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MedicationKnowledge":
		if impl, ok := w.Concrete.(MedicationKnowledgeSearch); ok {
			result, err := impl.SearchMedicationKnowledge(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "MedicationKnowledge")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MedicationRequest":
		if impl, ok := w.Concrete.(MedicationRequestSearch); ok {
			result, err := impl.SearchMedicationRequest(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "MedicationRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MedicationStatement":
		if impl, ok := w.Concrete.(MedicationStatementSearch); ok {
			result, err := impl.SearchMedicationStatement(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "MedicationStatement")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MedicinalProductDefinition":
		if impl, ok := w.Concrete.(MedicinalProductDefinitionSearch); ok {
			result, err := impl.SearchMedicinalProductDefinition(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "MedicinalProductDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MessageDefinition":
		if impl, ok := w.Concrete.(MessageDefinitionSearch); ok {
			result, err := impl.SearchMessageDefinition(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "MessageDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MessageHeader":
		if impl, ok := w.Concrete.(MessageHeaderSearch); ok {
			result, err := impl.SearchMessageHeader(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "MessageHeader")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "MolecularSequence":
		if impl, ok := w.Concrete.(MolecularSequenceSearch); ok {
			result, err := impl.SearchMolecularSequence(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "MolecularSequence")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "NamingSystem":
		if impl, ok := w.Concrete.(NamingSystemSearch); ok {
			result, err := impl.SearchNamingSystem(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "NamingSystem")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "NutritionOrder":
		if impl, ok := w.Concrete.(NutritionOrderSearch); ok {
			result, err := impl.SearchNutritionOrder(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "NutritionOrder")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "NutritionProduct":
		if impl, ok := w.Concrete.(NutritionProductSearch); ok {
			result, err := impl.SearchNutritionProduct(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "NutritionProduct")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Observation":
		if impl, ok := w.Concrete.(ObservationSearch); ok {
			result, err := impl.SearchObservation(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Observation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ObservationDefinition":
		if impl, ok := w.Concrete.(ObservationDefinitionSearch); ok {
			result, err := impl.SearchObservationDefinition(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "ObservationDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "OperationDefinition":
		impl, ok := w.Concrete.(OperationDefinitionSearch)
		if ok {
			result, err := impl.SearchOperationDefinition(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		cs, err := w.Concrete.CapabilityBase(ctx)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		var baseUrl string
		if cs.Implementation != nil && cs.Implementation.Url != nil && cs.Implementation.Url.Value != nil {
			baseUrl = *cs.Implementation.Url.Value
		}
		defs, err := operationDefinitionsByID(ctx, w.Concrete, baseUrl)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		filtered := make(map[string]r4b.OperationDefinition)
		for id, od := range defs {
			filtered[id] = od
		}
		if idParams, ok := parameters.Map()[search.ParameterKey{Name: "_id"}]; ok {
			filtered = make(map[string]r4b.OperationDefinition)
			for _, idValues := range idParams {
				for _, idValue := range idValues {
					idStr := idValue.String()
					if od, exists := defs[idStr]; exists {
						filtered[idStr] = od
					}
				}
			}
		}
		sortedIds := make([]string, 0, len(filtered))
		for id, _ := range filtered {
			sortedIds = append(sortedIds, id)
		}
		sort.Strings(sortedIds)
		allResources := make([]model.Resource, 0, len(filtered))
		for _, id := range sortedIds {
			allResources = append(allResources, filtered[id])
		}
		var offset int
		opts := options
		if opts.Cursor != "" {
			parsedOffset, err := strconv.Atoi(string(opts.Cursor))
			if err != nil {
				return search.Result[model.Resource]{}, fmt.Errorf("invalid cursor: %w", err)
			}
			if parsedOffset < 0 {
				return search.Result[model.Resource]{}, fmt.Errorf("invalid cursor: offset must be non-negative")
			}
			offset = parsedOffset
		}
		var resources []model.Resource
		if offset < len(allResources) {
			resources = allResources[offset:]
		}
		var nextCursor search.Cursor
		if opts.Count > 0 && len(resources) > opts.Count {
			resources = resources[:opts.Count]
			nextOffset := offset + opts.Count
			if nextOffset < len(allResources) {
				nextCursor = search.Cursor(strconv.Itoa(nextOffset))
			}
		}
		return search.Result[model.Resource]{

			Included:  []model.Resource{},
			Next:      nextCursor,
			Resources: resources,
		}, nil
	case "OperationOutcome":
		if impl, ok := w.Concrete.(OperationOutcomeSearch); ok {
			result, err := impl.SearchOperationOutcome(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "OperationOutcome")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Organization":
		if impl, ok := w.Concrete.(OrganizationSearch); ok {
			result, err := impl.SearchOrganization(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Organization")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "OrganizationAffiliation":
		if impl, ok := w.Concrete.(OrganizationAffiliationSearch); ok {
			result, err := impl.SearchOrganizationAffiliation(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "OrganizationAffiliation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "PackagedProductDefinition":
		if impl, ok := w.Concrete.(PackagedProductDefinitionSearch); ok {
			result, err := impl.SearchPackagedProductDefinition(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "PackagedProductDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Parameters":
		if impl, ok := w.Concrete.(ParametersSearch); ok {
			result, err := impl.SearchParameters(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Parameters")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Patient":
		if impl, ok := w.Concrete.(PatientSearch); ok {
			result, err := impl.SearchPatient(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Patient")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "PaymentNotice":
		if impl, ok := w.Concrete.(PaymentNoticeSearch); ok {
			result, err := impl.SearchPaymentNotice(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "PaymentNotice")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "PaymentReconciliation":
		if impl, ok := w.Concrete.(PaymentReconciliationSearch); ok {
			result, err := impl.SearchPaymentReconciliation(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "PaymentReconciliation")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Person":
		if impl, ok := w.Concrete.(PersonSearch); ok {
			result, err := impl.SearchPerson(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Person")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "PlanDefinition":
		if impl, ok := w.Concrete.(PlanDefinitionSearch); ok {
			result, err := impl.SearchPlanDefinition(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "PlanDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Practitioner":
		if impl, ok := w.Concrete.(PractitionerSearch); ok {
			result, err := impl.SearchPractitioner(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Practitioner")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "PractitionerRole":
		if impl, ok := w.Concrete.(PractitionerRoleSearch); ok {
			result, err := impl.SearchPractitionerRole(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "PractitionerRole")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Procedure":
		if impl, ok := w.Concrete.(ProcedureSearch); ok {
			result, err := impl.SearchProcedure(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Procedure")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Provenance":
		if impl, ok := w.Concrete.(ProvenanceSearch); ok {
			result, err := impl.SearchProvenance(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Provenance")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Questionnaire":
		if impl, ok := w.Concrete.(QuestionnaireSearch); ok {
			result, err := impl.SearchQuestionnaire(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Questionnaire")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "QuestionnaireResponse":
		if impl, ok := w.Concrete.(QuestionnaireResponseSearch); ok {
			result, err := impl.SearchQuestionnaireResponse(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "QuestionnaireResponse")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "RegulatedAuthorization":
		if impl, ok := w.Concrete.(RegulatedAuthorizationSearch); ok {
			result, err := impl.SearchRegulatedAuthorization(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "RegulatedAuthorization")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "RelatedPerson":
		if impl, ok := w.Concrete.(RelatedPersonSearch); ok {
			result, err := impl.SearchRelatedPerson(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "RelatedPerson")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "RequestGroup":
		if impl, ok := w.Concrete.(RequestGroupSearch); ok {
			result, err := impl.SearchRequestGroup(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "RequestGroup")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ResearchDefinition":
		if impl, ok := w.Concrete.(ResearchDefinitionSearch); ok {
			result, err := impl.SearchResearchDefinition(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "ResearchDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ResearchElementDefinition":
		if impl, ok := w.Concrete.(ResearchElementDefinitionSearch); ok {
			result, err := impl.SearchResearchElementDefinition(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "ResearchElementDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ResearchStudy":
		if impl, ok := w.Concrete.(ResearchStudySearch); ok {
			result, err := impl.SearchResearchStudy(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "ResearchStudy")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ResearchSubject":
		if impl, ok := w.Concrete.(ResearchSubjectSearch); ok {
			result, err := impl.SearchResearchSubject(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "ResearchSubject")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "RiskAssessment":
		if impl, ok := w.Concrete.(RiskAssessmentSearch); ok {
			result, err := impl.SearchRiskAssessment(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "RiskAssessment")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Schedule":
		if impl, ok := w.Concrete.(ScheduleSearch); ok {
			result, err := impl.SearchSchedule(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Schedule")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "SearchParameter":
		impl, ok := w.Concrete.(SearchParameterSearch)
		if ok {
			result, err := impl.SearchSearchParameter(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		// Fallback: gather SearchParameter from SearchCapabilities methods if SearchSearchParameter not implemented
		// Get base URL from CapabilityStatement for canonical references
		cs, err := w.Concrete.CapabilityBase(ctx)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		var baseUrl string
		if cs.Implementation != nil && cs.Implementation.Url != nil && cs.Implementation.Url.Value != nil {
			baseUrl = *cs.Implementation.Url.Value
		}
		searchParameters, err := searchParameters(ctx, w.Concrete, baseUrl)
		if err != nil {
			return search.Result[model.Resource]{}, err
		}
		filteredParameters := make(map[string]r4b.SearchParameter)
		for id, searchParam := range searchParameters {
			filteredParameters[id] = searchParam
		}
		if idParams, ok := parameters.Map()[search.ParameterKey{Name: "_id"}]; ok {
			filteredParameters = make(map[string]r4b.SearchParameter)
			for _, idValues := range idParams {
				for _, idValue := range idValues {
					idStr := idValue.String()
					if searchParam, exists := searchParameters[idStr]; exists {
						filteredParameters[idStr] = searchParam
					}
				}
			}
		}
		// Sort IDs for deterministic ordering
		sortedIds := make([]string, 0, len(filteredParameters))
		for id, _ := range filteredParameters {
			sortedIds = append(sortedIds, id)
		}
		sort.Strings(sortedIds)
		allResources := make([]model.Resource, 0, len(filteredParameters))
		for _, id := range sortedIds {
			allResources = append(allResources, filteredParameters[id])
		}
		var offset int
		opts := options
		if opts.Cursor != "" {
			parsedOffset, err := strconv.Atoi(string(opts.Cursor))
			if err != nil {
				return search.Result[model.Resource]{}, fmt.Errorf("invalid cursor: %w", err)
			}
			if parsedOffset < 0 {
				return search.Result[model.Resource]{}, fmt.Errorf("invalid cursor: offset must be non-negative")
			}
			offset = parsedOffset
		}
		var resources []model.Resource
		if offset < len(allResources) {
			resources = allResources[offset:]
		}
		var nextCursor search.Cursor
		if opts.Count > 0 && len(resources) > opts.Count {
			resources = resources[:opts.Count]
			nextOffset := offset + opts.Count
			if nextOffset < len(allResources) {
				nextCursor = search.Cursor(strconv.Itoa(nextOffset))
			}
		}
		return search.Result[model.Resource]{

			Included:  []model.Resource{},
			Next:      nextCursor,
			Resources: resources,
		}, nil
	case "ServiceRequest":
		if impl, ok := w.Concrete.(ServiceRequestSearch); ok {
			result, err := impl.SearchServiceRequest(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "ServiceRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Slot":
		if impl, ok := w.Concrete.(SlotSearch); ok {
			result, err := impl.SearchSlot(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Slot")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Specimen":
		if impl, ok := w.Concrete.(SpecimenSearch); ok {
			result, err := impl.SearchSpecimen(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Specimen")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "SpecimenDefinition":
		if impl, ok := w.Concrete.(SpecimenDefinitionSearch); ok {
			result, err := impl.SearchSpecimenDefinition(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "SpecimenDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "StructureDefinition":
		if impl, ok := w.Concrete.(StructureDefinitionSearch); ok {
			result, err := impl.SearchStructureDefinition(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "StructureDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "StructureMap":
		if impl, ok := w.Concrete.(StructureMapSearch); ok {
			result, err := impl.SearchStructureMap(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "StructureMap")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Subscription":
		if impl, ok := w.Concrete.(SubscriptionSearch); ok {
			result, err := impl.SearchSubscription(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Subscription")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "SubscriptionStatus":
		if impl, ok := w.Concrete.(SubscriptionStatusSearch); ok {
			result, err := impl.SearchSubscriptionStatus(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "SubscriptionStatus")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "SubscriptionTopic":
		if impl, ok := w.Concrete.(SubscriptionTopicSearch); ok {
			result, err := impl.SearchSubscriptionTopic(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "SubscriptionTopic")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Substance":
		if impl, ok := w.Concrete.(SubstanceSearch); ok {
			result, err := impl.SearchSubstance(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Substance")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "SubstanceDefinition":
		if impl, ok := w.Concrete.(SubstanceDefinitionSearch); ok {
			result, err := impl.SearchSubstanceDefinition(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "SubstanceDefinition")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "SupplyDelivery":
		if impl, ok := w.Concrete.(SupplyDeliverySearch); ok {
			result, err := impl.SearchSupplyDelivery(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "SupplyDelivery")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "SupplyRequest":
		if impl, ok := w.Concrete.(SupplyRequestSearch); ok {
			result, err := impl.SearchSupplyRequest(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "SupplyRequest")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "Task":
		if impl, ok := w.Concrete.(TaskSearch); ok {
			result, err := impl.SearchTask(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "Task")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "TerminologyCapabilities":
		if impl, ok := w.Concrete.(TerminologyCapabilitiesSearch); ok {
			result, err := impl.SearchTerminologyCapabilities(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "TerminologyCapabilities")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "TestReport":
		if impl, ok := w.Concrete.(TestReportSearch); ok {
			result, err := impl.SearchTestReport(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "TestReport")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "TestScript":
		if impl, ok := w.Concrete.(TestScriptSearch); ok {
			result, err := impl.SearchTestScript(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "TestScript")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "ValueSet":
		if impl, ok := w.Concrete.(ValueSetSearch); ok {
			result, err := impl.SearchValueSet(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "ValueSet")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "VerificationResult":
		if impl, ok := w.Concrete.(VerificationResultSearch); ok {
			result, err := impl.SearchVerificationResult(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "VerificationResult")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	case "VisionPrescription":
		if impl, ok := w.Concrete.(VisionPrescriptionSearch); ok {
			result, err := impl.SearchVisionPrescription(ctx, parameters, options)
			if err != nil {
				return search.Result[model.Resource]{}, err
			}
			genericResources := make([]model.Resource, len(result.Resources))
			for i, r := range result.Resources {
				genericResources[i] = r
			}
			return search.Result[model.Resource]{

				Included:  result.Included,
				Next:      result.Next,
				Resources: genericResources,
			}, nil
		}
		if gen, ok := w.Concrete.(capabilities.GenericSearch); ok {
			return gen.Search(ctx, resourceType, parameters, options)
		}
		return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("search not implemented for " + "VisionPrescription")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	}
	return search.Result[model.Resource]{}, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
		Code:        r4b.Code{Value: ptr.To("processing")},
		Diagnostics: &r4b.String{Value: ptr.To("invalid resource type: " + resourceType)},
		Severity:    r4b.Code{Value: ptr.To("fatal")},
	}}}
}
func (w Generic) Invoke(ctx context.Context, resourceType string, resourceID string, code string, parameters model.Parameters) (model.Resource, error) {
	crp, okCrp := parameters.(r4b.ContainedResource)
	if okCrp {
		parameters = crp.Resource
	}
	typedParams, _ := parameters.(r4b.Parameters)
	op, ok := w.Concrete.(capabilities.GenericOperation)
	if ok {
		return op.Invoke(ctx, resourceType, resourceID, code, parameters)
	}
	t := reflect.TypeOf(w.Concrete)
	v := reflect.ValueOf(w.Concrete)
	codeKey := strings.ToLower(code)
	matchBase := ""
	var opDef r4b.OperationDefinition
	defs := operationDefinitionsByCode(ctx, w.Concrete)
	entry, found := defs[codeKey]
	if found {
		matchBase = entry.Base
		opDef = entry.Def
	}
	if !found {
		return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
			Code:        r4b.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r4b.String{Value: ptr.To("OperationDefinition not found for code ")},
			Severity:    r4b.Code{Value: ptr.To("fatal")},
		}}}
	}
	if matchBase != "" {
		if resourceType == "" && (opDef.System.Value == nil || !*opDef.System.Value) {
			return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
				Code:        r4b.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4b.String{Value: ptr.To("operation not allowed at system level")},
				Severity:    r4b.Code{Value: ptr.To("fatal")},
			}}}
		}
		if resourceType != "" && resourceID == "" && (opDef.Type.Value == nil || !*opDef.Type.Value) {
			return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
				Code:        r4b.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4b.String{Value: ptr.To("operation not allowed at type level")},
				Severity:    r4b.Code{Value: ptr.To("fatal")},
			}}}
		}
		if resourceType != "" && resourceID != "" && (opDef.Instance.Value == nil || !*opDef.Instance.Value) {
			return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
				Code:        r4b.Code{Value: ptr.To("not-supported")},
				Diagnostics: &r4b.String{Value: ptr.To("operation not allowed at instance level")},
				Severity:    r4b.Code{Value: ptr.To("fatal")},
			}}}
		}
		if resourceType != "" {
			allowed := false
			for _, rt := range opDef.Resource {
				if rt.Value != nil && *rt.Value == resourceType {
					allowed = true
					break
				}
			}
			if (len(opDef.Resource) != 0) && !allowed {
				return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
					Code:        r4b.Code{Value: ptr.To("not-supported")},
					Diagnostics: &r4b.String{Value: ptr.To("operation not allowed for resource type")},
					Severity:    r4b.Code{Value: ptr.To("fatal")},
				}}}
			}
		}
	}
	need := 2
	if resourceType != "" {
		need = 3
		if resourceID != "" {
			need = 4
		}
	}
	ctxT := reflect.TypeOf((*context.Context)(nil)).Elem()
	paramT := reflect.TypeOf(r4b.Parameters{})
	var tryList []int
	if need == 2 {
		tryList = []int{2, 3, 4}
	} else if need == 3 {
		tryList = []int{3, 4}
	} else {
		tryList = []int{4}
	}
	for _, tryN := range tryList {
		for i := 0; i < t.NumMethod(); i++ {
			m := t.Method(i)
			name := m.Name
			if !strings.HasPrefix(name, "Invoke") {
				continue
			}
			base := strings.TrimPrefix(name, "Invoke")
			base = strings.TrimSuffix(base, "Operation")
			if base != matchBase {
				continue
			}
			mv := v.Method(i)
			mt := mv.Type()
			if mt.NumIn() != tryN {
				continue
			}
			if mt.NumOut() != 2 {
				continue
			}
			errorT := reflect.TypeOf((*error)(nil)).Elem()
			if !mt.Out(1).Implements(errorT) {
				continue
			}
			if mt.In(0) != ctxT {
				continue
			}
			if tryN == 2 {
				if mt.In(1) != paramT {
					continue
				}
			} else if tryN == 3 {
				if mt.In(1).Kind() != reflect.String {
					continue
				}
				if mt.In(2) != paramT {
					continue
				}
			} else {
				if mt.In(1).Kind() != reflect.String {
					continue
				}
				if mt.In(2).Kind() != reflect.String {
					continue
				}
				if mt.In(3) != paramT {
					continue
				}
			}
			args := []reflect.Value{reflect.ValueOf(ctx)}
			if tryN == 2 {
				args = append(args, reflect.ValueOf(typedParams))
			} else if tryN == 3 {
				args = append(args, reflect.ValueOf(resourceType))
				args = append(args, reflect.ValueOf(typedParams))
			} else {
				args = append(args, reflect.ValueOf(resourceType))
				args = append(args, reflect.ValueOf(resourceID))
				args = append(args, reflect.ValueOf(typedParams))
			}
			out := mv.Call(args)
			rv := out[0].Interface()
			errv := out[1].Interface()
			if errv != nil {
				return nil, errv.(error)
			}
			cr, ok := rv.(r4b.ContainedResource)
			if ok {
				return cr.Resource, nil
			}
			res, ok := rv.(model.Resource)
			if ok {
				return res, nil
			}
		}
	}
	return nil, r4b.OperationOutcome{Issue: []r4b.OperationOutcomeIssue{{
		Code:        r4b.Code{Value: ptr.To("not-supported")},
		Diagnostics: &r4b.String{Value: ptr.To("OperationDefinition but no implementation found")},
		Severity:    r4b.Code{Value: ptr.To("fatal")},
	}}}
}
