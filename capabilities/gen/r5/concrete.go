// DO NOT EDIT!
// Code generated by "github.com/damedic/fhir-toolbox-go/internal/generate";
// use `make generate` to regenerate.

package capabilitiesR5

import (
	"context"
	"fmt"
	capabilities "github.com/damedic/fhir-toolbox-go/capabilities"
	search "github.com/damedic/fhir-toolbox-go/capabilities/search"
	update "github.com/damedic/fhir-toolbox-go/capabilities/update"
	model "github.com/damedic/fhir-toolbox-go/model"
	r5 "github.com/damedic/fhir-toolbox-go/model/gen/r5"
	ptr "github.com/damedic/fhir-toolbox-go/utils/ptr"
	"strings"
)

type Concrete struct {
	Generic capabilities.GenericCapabilities
}

func (w Concrete) CapabilityBase(ctx context.Context) (model.CapabilityStatement, error) {
	// Delegate to the generic CapabilityStatement method
	return w.Generic.CapabilityStatement(ctx)
}
func (w Concrete) CreateAccount(ctx context.Context, resource r5.Account) (r5.Account, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Account{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Account")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Account{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Account)
	if !ok {
		return r5.Account{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Account" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateActivityDefinition(ctx context.Context, resource r5.ActivityDefinition) (r5.ActivityDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.ActivityDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for ActivityDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.ActivityDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ActivityDefinition)
	if !ok {
		return r5.ActivityDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ActivityDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateActorDefinition(ctx context.Context, resource r5.ActorDefinition) (r5.ActorDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.ActorDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for ActorDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.ActorDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ActorDefinition)
	if !ok {
		return r5.ActorDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ActorDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateAdministrableProductDefinition(ctx context.Context, resource r5.AdministrableProductDefinition) (r5.AdministrableProductDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.AdministrableProductDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for AdministrableProductDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.AdministrableProductDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.AdministrableProductDefinition)
	if !ok {
		return r5.AdministrableProductDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "AdministrableProductDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateAdverseEvent(ctx context.Context, resource r5.AdverseEvent) (r5.AdverseEvent, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.AdverseEvent{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for AdverseEvent")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.AdverseEvent{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.AdverseEvent)
	if !ok {
		return r5.AdverseEvent{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "AdverseEvent" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateAllergyIntolerance(ctx context.Context, resource r5.AllergyIntolerance) (r5.AllergyIntolerance, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.AllergyIntolerance{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for AllergyIntolerance")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.AllergyIntolerance{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.AllergyIntolerance)
	if !ok {
		return r5.AllergyIntolerance{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "AllergyIntolerance" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateAppointment(ctx context.Context, resource r5.Appointment) (r5.Appointment, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Appointment{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Appointment")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Appointment{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Appointment)
	if !ok {
		return r5.Appointment{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Appointment" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateAppointmentResponse(ctx context.Context, resource r5.AppointmentResponse) (r5.AppointmentResponse, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.AppointmentResponse{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for AppointmentResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.AppointmentResponse{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.AppointmentResponse)
	if !ok {
		return r5.AppointmentResponse{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "AppointmentResponse" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateArtifactAssessment(ctx context.Context, resource r5.ArtifactAssessment) (r5.ArtifactAssessment, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.ArtifactAssessment{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for ArtifactAssessment")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.ArtifactAssessment{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ArtifactAssessment)
	if !ok {
		return r5.ArtifactAssessment{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ArtifactAssessment" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateAuditEvent(ctx context.Context, resource r5.AuditEvent) (r5.AuditEvent, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.AuditEvent{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for AuditEvent")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.AuditEvent{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.AuditEvent)
	if !ok {
		return r5.AuditEvent{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "AuditEvent" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateBasic(ctx context.Context, resource r5.Basic) (r5.Basic, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Basic{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Basic")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Basic{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Basic)
	if !ok {
		return r5.Basic{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Basic" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateBinary(ctx context.Context, resource r5.Binary) (r5.Binary, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Binary{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Binary")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Binary{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Binary)
	if !ok {
		return r5.Binary{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Binary" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateBiologicallyDerivedProduct(ctx context.Context, resource r5.BiologicallyDerivedProduct) (r5.BiologicallyDerivedProduct, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.BiologicallyDerivedProduct{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for BiologicallyDerivedProduct")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.BiologicallyDerivedProduct{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.BiologicallyDerivedProduct)
	if !ok {
		return r5.BiologicallyDerivedProduct{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "BiologicallyDerivedProduct" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateBiologicallyDerivedProductDispense(ctx context.Context, resource r5.BiologicallyDerivedProductDispense) (r5.BiologicallyDerivedProductDispense, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.BiologicallyDerivedProductDispense{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for BiologicallyDerivedProductDispense")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.BiologicallyDerivedProductDispense{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.BiologicallyDerivedProductDispense)
	if !ok {
		return r5.BiologicallyDerivedProductDispense{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "BiologicallyDerivedProductDispense" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateBodyStructure(ctx context.Context, resource r5.BodyStructure) (r5.BodyStructure, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.BodyStructure{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for BodyStructure")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.BodyStructure{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.BodyStructure)
	if !ok {
		return r5.BodyStructure{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "BodyStructure" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateBundle(ctx context.Context, resource r5.Bundle) (r5.Bundle, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Bundle{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Bundle")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Bundle{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Bundle)
	if !ok {
		return r5.Bundle{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Bundle" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateCapabilityStatement(ctx context.Context, resource r5.CapabilityStatement) (r5.CapabilityStatement, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.CapabilityStatement{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for CapabilityStatement")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.CapabilityStatement{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.CapabilityStatement)
	if !ok {
		return r5.CapabilityStatement{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "CapabilityStatement" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateCarePlan(ctx context.Context, resource r5.CarePlan) (r5.CarePlan, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.CarePlan{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for CarePlan")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.CarePlan{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.CarePlan)
	if !ok {
		return r5.CarePlan{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "CarePlan" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateCareTeam(ctx context.Context, resource r5.CareTeam) (r5.CareTeam, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.CareTeam{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for CareTeam")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.CareTeam{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.CareTeam)
	if !ok {
		return r5.CareTeam{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "CareTeam" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateChargeItem(ctx context.Context, resource r5.ChargeItem) (r5.ChargeItem, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.ChargeItem{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for ChargeItem")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.ChargeItem{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ChargeItem)
	if !ok {
		return r5.ChargeItem{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ChargeItem" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateChargeItemDefinition(ctx context.Context, resource r5.ChargeItemDefinition) (r5.ChargeItemDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.ChargeItemDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for ChargeItemDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.ChargeItemDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ChargeItemDefinition)
	if !ok {
		return r5.ChargeItemDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ChargeItemDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateCitation(ctx context.Context, resource r5.Citation) (r5.Citation, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Citation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Citation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Citation{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Citation)
	if !ok {
		return r5.Citation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Citation" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateClaim(ctx context.Context, resource r5.Claim) (r5.Claim, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Claim{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Claim")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Claim{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Claim)
	if !ok {
		return r5.Claim{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Claim" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateClaimResponse(ctx context.Context, resource r5.ClaimResponse) (r5.ClaimResponse, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.ClaimResponse{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for ClaimResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.ClaimResponse{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ClaimResponse)
	if !ok {
		return r5.ClaimResponse{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ClaimResponse" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateClinicalImpression(ctx context.Context, resource r5.ClinicalImpression) (r5.ClinicalImpression, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.ClinicalImpression{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for ClinicalImpression")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.ClinicalImpression{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ClinicalImpression)
	if !ok {
		return r5.ClinicalImpression{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ClinicalImpression" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateClinicalUseDefinition(ctx context.Context, resource r5.ClinicalUseDefinition) (r5.ClinicalUseDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.ClinicalUseDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for ClinicalUseDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.ClinicalUseDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ClinicalUseDefinition)
	if !ok {
		return r5.ClinicalUseDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ClinicalUseDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateCodeSystem(ctx context.Context, resource r5.CodeSystem) (r5.CodeSystem, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.CodeSystem{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for CodeSystem")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.CodeSystem{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.CodeSystem)
	if !ok {
		return r5.CodeSystem{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "CodeSystem" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateCommunication(ctx context.Context, resource r5.Communication) (r5.Communication, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Communication{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Communication")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Communication{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Communication)
	if !ok {
		return r5.Communication{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Communication" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateCommunicationRequest(ctx context.Context, resource r5.CommunicationRequest) (r5.CommunicationRequest, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.CommunicationRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for CommunicationRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.CommunicationRequest{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.CommunicationRequest)
	if !ok {
		return r5.CommunicationRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "CommunicationRequest" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateCompartmentDefinition(ctx context.Context, resource r5.CompartmentDefinition) (r5.CompartmentDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.CompartmentDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for CompartmentDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.CompartmentDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.CompartmentDefinition)
	if !ok {
		return r5.CompartmentDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "CompartmentDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateComposition(ctx context.Context, resource r5.Composition) (r5.Composition, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Composition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Composition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Composition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Composition)
	if !ok {
		return r5.Composition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Composition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateConceptMap(ctx context.Context, resource r5.ConceptMap) (r5.ConceptMap, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.ConceptMap{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for ConceptMap")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.ConceptMap{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ConceptMap)
	if !ok {
		return r5.ConceptMap{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ConceptMap" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateCondition(ctx context.Context, resource r5.Condition) (r5.Condition, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Condition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Condition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Condition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Condition)
	if !ok {
		return r5.Condition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Condition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateConditionDefinition(ctx context.Context, resource r5.ConditionDefinition) (r5.ConditionDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.ConditionDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for ConditionDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.ConditionDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ConditionDefinition)
	if !ok {
		return r5.ConditionDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ConditionDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateConsent(ctx context.Context, resource r5.Consent) (r5.Consent, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Consent{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Consent")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Consent{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Consent)
	if !ok {
		return r5.Consent{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Consent" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateContract(ctx context.Context, resource r5.Contract) (r5.Contract, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Contract{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Contract")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Contract{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Contract)
	if !ok {
		return r5.Contract{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Contract" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateCoverage(ctx context.Context, resource r5.Coverage) (r5.Coverage, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Coverage{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Coverage")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Coverage{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Coverage)
	if !ok {
		return r5.Coverage{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Coverage" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateCoverageEligibilityRequest(ctx context.Context, resource r5.CoverageEligibilityRequest) (r5.CoverageEligibilityRequest, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.CoverageEligibilityRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for CoverageEligibilityRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.CoverageEligibilityRequest{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.CoverageEligibilityRequest)
	if !ok {
		return r5.CoverageEligibilityRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "CoverageEligibilityRequest" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateCoverageEligibilityResponse(ctx context.Context, resource r5.CoverageEligibilityResponse) (r5.CoverageEligibilityResponse, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.CoverageEligibilityResponse{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for CoverageEligibilityResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.CoverageEligibilityResponse{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.CoverageEligibilityResponse)
	if !ok {
		return r5.CoverageEligibilityResponse{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "CoverageEligibilityResponse" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateDetectedIssue(ctx context.Context, resource r5.DetectedIssue) (r5.DetectedIssue, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.DetectedIssue{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for DetectedIssue")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.DetectedIssue{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.DetectedIssue)
	if !ok {
		return r5.DetectedIssue{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "DetectedIssue" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateDevice(ctx context.Context, resource r5.Device) (r5.Device, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Device{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Device")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Device{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Device)
	if !ok {
		return r5.Device{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Device" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateDeviceAssociation(ctx context.Context, resource r5.DeviceAssociation) (r5.DeviceAssociation, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.DeviceAssociation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for DeviceAssociation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.DeviceAssociation{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.DeviceAssociation)
	if !ok {
		return r5.DeviceAssociation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "DeviceAssociation" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateDeviceDefinition(ctx context.Context, resource r5.DeviceDefinition) (r5.DeviceDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.DeviceDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for DeviceDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.DeviceDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.DeviceDefinition)
	if !ok {
		return r5.DeviceDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "DeviceDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateDeviceDispense(ctx context.Context, resource r5.DeviceDispense) (r5.DeviceDispense, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.DeviceDispense{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for DeviceDispense")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.DeviceDispense{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.DeviceDispense)
	if !ok {
		return r5.DeviceDispense{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "DeviceDispense" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateDeviceMetric(ctx context.Context, resource r5.DeviceMetric) (r5.DeviceMetric, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.DeviceMetric{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for DeviceMetric")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.DeviceMetric{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.DeviceMetric)
	if !ok {
		return r5.DeviceMetric{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "DeviceMetric" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateDeviceRequest(ctx context.Context, resource r5.DeviceRequest) (r5.DeviceRequest, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.DeviceRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for DeviceRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.DeviceRequest{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.DeviceRequest)
	if !ok {
		return r5.DeviceRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "DeviceRequest" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateDeviceUsage(ctx context.Context, resource r5.DeviceUsage) (r5.DeviceUsage, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.DeviceUsage{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for DeviceUsage")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.DeviceUsage{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.DeviceUsage)
	if !ok {
		return r5.DeviceUsage{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "DeviceUsage" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateDiagnosticReport(ctx context.Context, resource r5.DiagnosticReport) (r5.DiagnosticReport, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.DiagnosticReport{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for DiagnosticReport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.DiagnosticReport{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.DiagnosticReport)
	if !ok {
		return r5.DiagnosticReport{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "DiagnosticReport" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateDocumentReference(ctx context.Context, resource r5.DocumentReference) (r5.DocumentReference, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.DocumentReference{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for DocumentReference")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.DocumentReference{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.DocumentReference)
	if !ok {
		return r5.DocumentReference{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "DocumentReference" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateEncounter(ctx context.Context, resource r5.Encounter) (r5.Encounter, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Encounter{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Encounter")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Encounter{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Encounter)
	if !ok {
		return r5.Encounter{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Encounter" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateEncounterHistory(ctx context.Context, resource r5.EncounterHistory) (r5.EncounterHistory, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.EncounterHistory{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for EncounterHistory")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.EncounterHistory{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.EncounterHistory)
	if !ok {
		return r5.EncounterHistory{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "EncounterHistory" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateEndpoint(ctx context.Context, resource r5.Endpoint) (r5.Endpoint, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Endpoint{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Endpoint")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Endpoint{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Endpoint)
	if !ok {
		return r5.Endpoint{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Endpoint" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateEnrollmentRequest(ctx context.Context, resource r5.EnrollmentRequest) (r5.EnrollmentRequest, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.EnrollmentRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for EnrollmentRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.EnrollmentRequest{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.EnrollmentRequest)
	if !ok {
		return r5.EnrollmentRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "EnrollmentRequest" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateEnrollmentResponse(ctx context.Context, resource r5.EnrollmentResponse) (r5.EnrollmentResponse, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.EnrollmentResponse{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for EnrollmentResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.EnrollmentResponse{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.EnrollmentResponse)
	if !ok {
		return r5.EnrollmentResponse{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "EnrollmentResponse" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateEpisodeOfCare(ctx context.Context, resource r5.EpisodeOfCare) (r5.EpisodeOfCare, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.EpisodeOfCare{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for EpisodeOfCare")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.EpisodeOfCare{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.EpisodeOfCare)
	if !ok {
		return r5.EpisodeOfCare{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "EpisodeOfCare" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateEventDefinition(ctx context.Context, resource r5.EventDefinition) (r5.EventDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.EventDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for EventDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.EventDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.EventDefinition)
	if !ok {
		return r5.EventDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "EventDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateEvidence(ctx context.Context, resource r5.Evidence) (r5.Evidence, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Evidence{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Evidence")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Evidence{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Evidence)
	if !ok {
		return r5.Evidence{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Evidence" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateEvidenceReport(ctx context.Context, resource r5.EvidenceReport) (r5.EvidenceReport, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.EvidenceReport{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for EvidenceReport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.EvidenceReport{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.EvidenceReport)
	if !ok {
		return r5.EvidenceReport{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "EvidenceReport" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateEvidenceVariable(ctx context.Context, resource r5.EvidenceVariable) (r5.EvidenceVariable, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.EvidenceVariable{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for EvidenceVariable")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.EvidenceVariable{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.EvidenceVariable)
	if !ok {
		return r5.EvidenceVariable{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "EvidenceVariable" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateExampleScenario(ctx context.Context, resource r5.ExampleScenario) (r5.ExampleScenario, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.ExampleScenario{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for ExampleScenario")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.ExampleScenario{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ExampleScenario)
	if !ok {
		return r5.ExampleScenario{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ExampleScenario" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateExplanationOfBenefit(ctx context.Context, resource r5.ExplanationOfBenefit) (r5.ExplanationOfBenefit, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.ExplanationOfBenefit{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for ExplanationOfBenefit")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.ExplanationOfBenefit{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ExplanationOfBenefit)
	if !ok {
		return r5.ExplanationOfBenefit{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ExplanationOfBenefit" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateFamilyMemberHistory(ctx context.Context, resource r5.FamilyMemberHistory) (r5.FamilyMemberHistory, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.FamilyMemberHistory{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for FamilyMemberHistory")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.FamilyMemberHistory{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.FamilyMemberHistory)
	if !ok {
		return r5.FamilyMemberHistory{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "FamilyMemberHistory" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateFlag(ctx context.Context, resource r5.Flag) (r5.Flag, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Flag{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Flag")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Flag{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Flag)
	if !ok {
		return r5.Flag{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Flag" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateFormularyItem(ctx context.Context, resource r5.FormularyItem) (r5.FormularyItem, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.FormularyItem{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for FormularyItem")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.FormularyItem{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.FormularyItem)
	if !ok {
		return r5.FormularyItem{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "FormularyItem" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateGenomicStudy(ctx context.Context, resource r5.GenomicStudy) (r5.GenomicStudy, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.GenomicStudy{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for GenomicStudy")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.GenomicStudy{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.GenomicStudy)
	if !ok {
		return r5.GenomicStudy{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "GenomicStudy" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateGoal(ctx context.Context, resource r5.Goal) (r5.Goal, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Goal{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Goal")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Goal{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Goal)
	if !ok {
		return r5.Goal{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Goal" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateGraphDefinition(ctx context.Context, resource r5.GraphDefinition) (r5.GraphDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.GraphDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for GraphDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.GraphDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.GraphDefinition)
	if !ok {
		return r5.GraphDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "GraphDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateGroup(ctx context.Context, resource r5.Group) (r5.Group, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Group{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Group")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Group{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Group)
	if !ok {
		return r5.Group{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Group" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateGuidanceResponse(ctx context.Context, resource r5.GuidanceResponse) (r5.GuidanceResponse, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.GuidanceResponse{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for GuidanceResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.GuidanceResponse{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.GuidanceResponse)
	if !ok {
		return r5.GuidanceResponse{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "GuidanceResponse" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateHealthcareService(ctx context.Context, resource r5.HealthcareService) (r5.HealthcareService, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.HealthcareService{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for HealthcareService")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.HealthcareService{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.HealthcareService)
	if !ok {
		return r5.HealthcareService{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "HealthcareService" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateImagingSelection(ctx context.Context, resource r5.ImagingSelection) (r5.ImagingSelection, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.ImagingSelection{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for ImagingSelection")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.ImagingSelection{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ImagingSelection)
	if !ok {
		return r5.ImagingSelection{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ImagingSelection" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateImagingStudy(ctx context.Context, resource r5.ImagingStudy) (r5.ImagingStudy, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.ImagingStudy{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for ImagingStudy")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.ImagingStudy{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ImagingStudy)
	if !ok {
		return r5.ImagingStudy{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ImagingStudy" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateImmunization(ctx context.Context, resource r5.Immunization) (r5.Immunization, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Immunization{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Immunization")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Immunization{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Immunization)
	if !ok {
		return r5.Immunization{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Immunization" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateImmunizationEvaluation(ctx context.Context, resource r5.ImmunizationEvaluation) (r5.ImmunizationEvaluation, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.ImmunizationEvaluation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for ImmunizationEvaluation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.ImmunizationEvaluation{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ImmunizationEvaluation)
	if !ok {
		return r5.ImmunizationEvaluation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ImmunizationEvaluation" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateImmunizationRecommendation(ctx context.Context, resource r5.ImmunizationRecommendation) (r5.ImmunizationRecommendation, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.ImmunizationRecommendation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for ImmunizationRecommendation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.ImmunizationRecommendation{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ImmunizationRecommendation)
	if !ok {
		return r5.ImmunizationRecommendation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ImmunizationRecommendation" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateImplementationGuide(ctx context.Context, resource r5.ImplementationGuide) (r5.ImplementationGuide, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.ImplementationGuide{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for ImplementationGuide")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.ImplementationGuide{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ImplementationGuide)
	if !ok {
		return r5.ImplementationGuide{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ImplementationGuide" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateIngredient(ctx context.Context, resource r5.Ingredient) (r5.Ingredient, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Ingredient{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Ingredient")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Ingredient{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Ingredient)
	if !ok {
		return r5.Ingredient{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Ingredient" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateInsurancePlan(ctx context.Context, resource r5.InsurancePlan) (r5.InsurancePlan, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.InsurancePlan{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for InsurancePlan")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.InsurancePlan{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.InsurancePlan)
	if !ok {
		return r5.InsurancePlan{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "InsurancePlan" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateInventoryItem(ctx context.Context, resource r5.InventoryItem) (r5.InventoryItem, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.InventoryItem{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for InventoryItem")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.InventoryItem{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.InventoryItem)
	if !ok {
		return r5.InventoryItem{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "InventoryItem" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateInventoryReport(ctx context.Context, resource r5.InventoryReport) (r5.InventoryReport, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.InventoryReport{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for InventoryReport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.InventoryReport{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.InventoryReport)
	if !ok {
		return r5.InventoryReport{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "InventoryReport" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateInvoice(ctx context.Context, resource r5.Invoice) (r5.Invoice, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Invoice{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Invoice")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Invoice{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Invoice)
	if !ok {
		return r5.Invoice{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Invoice" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateLibrary(ctx context.Context, resource r5.Library) (r5.Library, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Library{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Library")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Library{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Library)
	if !ok {
		return r5.Library{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Library" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateLinkage(ctx context.Context, resource r5.Linkage) (r5.Linkage, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Linkage{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Linkage")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Linkage{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Linkage)
	if !ok {
		return r5.Linkage{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Linkage" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateList(ctx context.Context, resource r5.List) (r5.List, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.List{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for List")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.List{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.List)
	if !ok {
		return r5.List{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "List" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateLocation(ctx context.Context, resource r5.Location) (r5.Location, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Location{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Location")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Location{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Location)
	if !ok {
		return r5.Location{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Location" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateManufacturedItemDefinition(ctx context.Context, resource r5.ManufacturedItemDefinition) (r5.ManufacturedItemDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.ManufacturedItemDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for ManufacturedItemDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.ManufacturedItemDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ManufacturedItemDefinition)
	if !ok {
		return r5.ManufacturedItemDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ManufacturedItemDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateMeasure(ctx context.Context, resource r5.Measure) (r5.Measure, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Measure{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Measure")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Measure{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Measure)
	if !ok {
		return r5.Measure{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Measure" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateMeasureReport(ctx context.Context, resource r5.MeasureReport) (r5.MeasureReport, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.MeasureReport{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for MeasureReport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.MeasureReport{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MeasureReport)
	if !ok {
		return r5.MeasureReport{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MeasureReport" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateMedication(ctx context.Context, resource r5.Medication) (r5.Medication, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Medication{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Medication")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Medication{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Medication)
	if !ok {
		return r5.Medication{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Medication" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateMedicationAdministration(ctx context.Context, resource r5.MedicationAdministration) (r5.MedicationAdministration, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.MedicationAdministration{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for MedicationAdministration")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.MedicationAdministration{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MedicationAdministration)
	if !ok {
		return r5.MedicationAdministration{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MedicationAdministration" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateMedicationDispense(ctx context.Context, resource r5.MedicationDispense) (r5.MedicationDispense, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.MedicationDispense{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for MedicationDispense")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.MedicationDispense{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MedicationDispense)
	if !ok {
		return r5.MedicationDispense{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MedicationDispense" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateMedicationKnowledge(ctx context.Context, resource r5.MedicationKnowledge) (r5.MedicationKnowledge, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.MedicationKnowledge{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for MedicationKnowledge")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.MedicationKnowledge{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MedicationKnowledge)
	if !ok {
		return r5.MedicationKnowledge{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MedicationKnowledge" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateMedicationRequest(ctx context.Context, resource r5.MedicationRequest) (r5.MedicationRequest, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.MedicationRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for MedicationRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.MedicationRequest{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MedicationRequest)
	if !ok {
		return r5.MedicationRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MedicationRequest" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateMedicationStatement(ctx context.Context, resource r5.MedicationStatement) (r5.MedicationStatement, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.MedicationStatement{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for MedicationStatement")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.MedicationStatement{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MedicationStatement)
	if !ok {
		return r5.MedicationStatement{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MedicationStatement" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateMedicinalProductDefinition(ctx context.Context, resource r5.MedicinalProductDefinition) (r5.MedicinalProductDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.MedicinalProductDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for MedicinalProductDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.MedicinalProductDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MedicinalProductDefinition)
	if !ok {
		return r5.MedicinalProductDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MedicinalProductDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateMessageDefinition(ctx context.Context, resource r5.MessageDefinition) (r5.MessageDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.MessageDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for MessageDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.MessageDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MessageDefinition)
	if !ok {
		return r5.MessageDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MessageDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateMessageHeader(ctx context.Context, resource r5.MessageHeader) (r5.MessageHeader, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.MessageHeader{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for MessageHeader")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.MessageHeader{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MessageHeader)
	if !ok {
		return r5.MessageHeader{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MessageHeader" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateMolecularSequence(ctx context.Context, resource r5.MolecularSequence) (r5.MolecularSequence, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.MolecularSequence{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for MolecularSequence")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.MolecularSequence{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MolecularSequence)
	if !ok {
		return r5.MolecularSequence{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MolecularSequence" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateNamingSystem(ctx context.Context, resource r5.NamingSystem) (r5.NamingSystem, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.NamingSystem{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for NamingSystem")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.NamingSystem{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.NamingSystem)
	if !ok {
		return r5.NamingSystem{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "NamingSystem" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateNutritionIntake(ctx context.Context, resource r5.NutritionIntake) (r5.NutritionIntake, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.NutritionIntake{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for NutritionIntake")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.NutritionIntake{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.NutritionIntake)
	if !ok {
		return r5.NutritionIntake{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "NutritionIntake" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateNutritionOrder(ctx context.Context, resource r5.NutritionOrder) (r5.NutritionOrder, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.NutritionOrder{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for NutritionOrder")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.NutritionOrder{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.NutritionOrder)
	if !ok {
		return r5.NutritionOrder{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "NutritionOrder" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateNutritionProduct(ctx context.Context, resource r5.NutritionProduct) (r5.NutritionProduct, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.NutritionProduct{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for NutritionProduct")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.NutritionProduct{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.NutritionProduct)
	if !ok {
		return r5.NutritionProduct{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "NutritionProduct" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateObservation(ctx context.Context, resource r5.Observation) (r5.Observation, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Observation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Observation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Observation{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Observation)
	if !ok {
		return r5.Observation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Observation" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateObservationDefinition(ctx context.Context, resource r5.ObservationDefinition) (r5.ObservationDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.ObservationDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for ObservationDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.ObservationDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ObservationDefinition)
	if !ok {
		return r5.ObservationDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ObservationDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateOperationDefinition(ctx context.Context, resource r5.OperationDefinition) (r5.OperationDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.OperationDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for OperationDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.OperationDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.OperationDefinition)
	if !ok {
		return r5.OperationDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "OperationDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateOperationOutcome(ctx context.Context, resource r5.OperationOutcome) (r5.OperationOutcome, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.OperationOutcome{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for OperationOutcome")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.OperationOutcome{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.OperationOutcome)
	if !ok {
		return r5.OperationOutcome{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "OperationOutcome" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateOrganization(ctx context.Context, resource r5.Organization) (r5.Organization, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Organization{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Organization")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Organization{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Organization)
	if !ok {
		return r5.Organization{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Organization" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateOrganizationAffiliation(ctx context.Context, resource r5.OrganizationAffiliation) (r5.OrganizationAffiliation, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.OrganizationAffiliation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for OrganizationAffiliation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.OrganizationAffiliation{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.OrganizationAffiliation)
	if !ok {
		return r5.OrganizationAffiliation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "OrganizationAffiliation" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreatePackagedProductDefinition(ctx context.Context, resource r5.PackagedProductDefinition) (r5.PackagedProductDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.PackagedProductDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for PackagedProductDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.PackagedProductDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.PackagedProductDefinition)
	if !ok {
		return r5.PackagedProductDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "PackagedProductDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateParameters(ctx context.Context, resource r5.Parameters) (r5.Parameters, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Parameters{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Parameters")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Parameters{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Parameters)
	if !ok {
		return r5.Parameters{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Parameters" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreatePatient(ctx context.Context, resource r5.Patient) (r5.Patient, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Patient{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Patient")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Patient{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Patient)
	if !ok {
		return r5.Patient{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Patient" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreatePaymentNotice(ctx context.Context, resource r5.PaymentNotice) (r5.PaymentNotice, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.PaymentNotice{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for PaymentNotice")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.PaymentNotice{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.PaymentNotice)
	if !ok {
		return r5.PaymentNotice{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "PaymentNotice" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreatePaymentReconciliation(ctx context.Context, resource r5.PaymentReconciliation) (r5.PaymentReconciliation, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.PaymentReconciliation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for PaymentReconciliation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.PaymentReconciliation{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.PaymentReconciliation)
	if !ok {
		return r5.PaymentReconciliation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "PaymentReconciliation" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreatePermission(ctx context.Context, resource r5.Permission) (r5.Permission, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Permission{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Permission")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Permission{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Permission)
	if !ok {
		return r5.Permission{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Permission" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreatePerson(ctx context.Context, resource r5.Person) (r5.Person, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Person{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Person")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Person{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Person)
	if !ok {
		return r5.Person{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Person" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreatePlanDefinition(ctx context.Context, resource r5.PlanDefinition) (r5.PlanDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.PlanDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for PlanDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.PlanDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.PlanDefinition)
	if !ok {
		return r5.PlanDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "PlanDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreatePractitioner(ctx context.Context, resource r5.Practitioner) (r5.Practitioner, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Practitioner{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Practitioner")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Practitioner{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Practitioner)
	if !ok {
		return r5.Practitioner{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Practitioner" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreatePractitionerRole(ctx context.Context, resource r5.PractitionerRole) (r5.PractitionerRole, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.PractitionerRole{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for PractitionerRole")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.PractitionerRole{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.PractitionerRole)
	if !ok {
		return r5.PractitionerRole{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "PractitionerRole" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateProcedure(ctx context.Context, resource r5.Procedure) (r5.Procedure, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Procedure{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Procedure")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Procedure{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Procedure)
	if !ok {
		return r5.Procedure{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Procedure" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateProvenance(ctx context.Context, resource r5.Provenance) (r5.Provenance, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Provenance{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Provenance")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Provenance{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Provenance)
	if !ok {
		return r5.Provenance{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Provenance" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateQuestionnaire(ctx context.Context, resource r5.Questionnaire) (r5.Questionnaire, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Questionnaire{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Questionnaire")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Questionnaire{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Questionnaire)
	if !ok {
		return r5.Questionnaire{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Questionnaire" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateQuestionnaireResponse(ctx context.Context, resource r5.QuestionnaireResponse) (r5.QuestionnaireResponse, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.QuestionnaireResponse{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for QuestionnaireResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.QuestionnaireResponse{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.QuestionnaireResponse)
	if !ok {
		return r5.QuestionnaireResponse{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "QuestionnaireResponse" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateRegulatedAuthorization(ctx context.Context, resource r5.RegulatedAuthorization) (r5.RegulatedAuthorization, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.RegulatedAuthorization{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for RegulatedAuthorization")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.RegulatedAuthorization{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.RegulatedAuthorization)
	if !ok {
		return r5.RegulatedAuthorization{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "RegulatedAuthorization" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateRelatedPerson(ctx context.Context, resource r5.RelatedPerson) (r5.RelatedPerson, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.RelatedPerson{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for RelatedPerson")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.RelatedPerson{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.RelatedPerson)
	if !ok {
		return r5.RelatedPerson{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "RelatedPerson" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateRequestOrchestration(ctx context.Context, resource r5.RequestOrchestration) (r5.RequestOrchestration, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.RequestOrchestration{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for RequestOrchestration")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.RequestOrchestration{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.RequestOrchestration)
	if !ok {
		return r5.RequestOrchestration{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "RequestOrchestration" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateRequirements(ctx context.Context, resource r5.Requirements) (r5.Requirements, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Requirements{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Requirements")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Requirements{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Requirements)
	if !ok {
		return r5.Requirements{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Requirements" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateResearchStudy(ctx context.Context, resource r5.ResearchStudy) (r5.ResearchStudy, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.ResearchStudy{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for ResearchStudy")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.ResearchStudy{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ResearchStudy)
	if !ok {
		return r5.ResearchStudy{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ResearchStudy" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateResearchSubject(ctx context.Context, resource r5.ResearchSubject) (r5.ResearchSubject, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.ResearchSubject{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for ResearchSubject")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.ResearchSubject{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ResearchSubject)
	if !ok {
		return r5.ResearchSubject{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ResearchSubject" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateRiskAssessment(ctx context.Context, resource r5.RiskAssessment) (r5.RiskAssessment, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.RiskAssessment{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for RiskAssessment")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.RiskAssessment{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.RiskAssessment)
	if !ok {
		return r5.RiskAssessment{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "RiskAssessment" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateSchedule(ctx context.Context, resource r5.Schedule) (r5.Schedule, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Schedule{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Schedule")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Schedule{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Schedule)
	if !ok {
		return r5.Schedule{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Schedule" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateSearchParameter(ctx context.Context, resource r5.SearchParameter) (r5.SearchParameter, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.SearchParameter{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for SearchParameter")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.SearchParameter{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SearchParameter)
	if !ok {
		return r5.SearchParameter{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SearchParameter" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateServiceRequest(ctx context.Context, resource r5.ServiceRequest) (r5.ServiceRequest, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.ServiceRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for ServiceRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.ServiceRequest{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ServiceRequest)
	if !ok {
		return r5.ServiceRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ServiceRequest" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateSlot(ctx context.Context, resource r5.Slot) (r5.Slot, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Slot{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Slot")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Slot{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Slot)
	if !ok {
		return r5.Slot{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Slot" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateSpecimen(ctx context.Context, resource r5.Specimen) (r5.Specimen, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Specimen{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Specimen")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Specimen{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Specimen)
	if !ok {
		return r5.Specimen{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Specimen" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateSpecimenDefinition(ctx context.Context, resource r5.SpecimenDefinition) (r5.SpecimenDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.SpecimenDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for SpecimenDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.SpecimenDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SpecimenDefinition)
	if !ok {
		return r5.SpecimenDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SpecimenDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateStructureDefinition(ctx context.Context, resource r5.StructureDefinition) (r5.StructureDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.StructureDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for StructureDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.StructureDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.StructureDefinition)
	if !ok {
		return r5.StructureDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "StructureDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateStructureMap(ctx context.Context, resource r5.StructureMap) (r5.StructureMap, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.StructureMap{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for StructureMap")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.StructureMap{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.StructureMap)
	if !ok {
		return r5.StructureMap{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "StructureMap" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateSubscription(ctx context.Context, resource r5.Subscription) (r5.Subscription, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Subscription{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Subscription")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Subscription{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Subscription)
	if !ok {
		return r5.Subscription{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Subscription" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateSubscriptionStatus(ctx context.Context, resource r5.SubscriptionStatus) (r5.SubscriptionStatus, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.SubscriptionStatus{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for SubscriptionStatus")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.SubscriptionStatus{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SubscriptionStatus)
	if !ok {
		return r5.SubscriptionStatus{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SubscriptionStatus" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateSubscriptionTopic(ctx context.Context, resource r5.SubscriptionTopic) (r5.SubscriptionTopic, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.SubscriptionTopic{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for SubscriptionTopic")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.SubscriptionTopic{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SubscriptionTopic)
	if !ok {
		return r5.SubscriptionTopic{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SubscriptionTopic" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateSubstance(ctx context.Context, resource r5.Substance) (r5.Substance, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Substance{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Substance")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Substance{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Substance)
	if !ok {
		return r5.Substance{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Substance" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateSubstanceDefinition(ctx context.Context, resource r5.SubstanceDefinition) (r5.SubstanceDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.SubstanceDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for SubstanceDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.SubstanceDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SubstanceDefinition)
	if !ok {
		return r5.SubstanceDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SubstanceDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateSubstanceNucleicAcid(ctx context.Context, resource r5.SubstanceNucleicAcid) (r5.SubstanceNucleicAcid, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.SubstanceNucleicAcid{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for SubstanceNucleicAcid")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.SubstanceNucleicAcid{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SubstanceNucleicAcid)
	if !ok {
		return r5.SubstanceNucleicAcid{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SubstanceNucleicAcid" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateSubstancePolymer(ctx context.Context, resource r5.SubstancePolymer) (r5.SubstancePolymer, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.SubstancePolymer{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for SubstancePolymer")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.SubstancePolymer{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SubstancePolymer)
	if !ok {
		return r5.SubstancePolymer{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SubstancePolymer" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateSubstanceProtein(ctx context.Context, resource r5.SubstanceProtein) (r5.SubstanceProtein, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.SubstanceProtein{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for SubstanceProtein")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.SubstanceProtein{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SubstanceProtein)
	if !ok {
		return r5.SubstanceProtein{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SubstanceProtein" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateSubstanceReferenceInformation(ctx context.Context, resource r5.SubstanceReferenceInformation) (r5.SubstanceReferenceInformation, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.SubstanceReferenceInformation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for SubstanceReferenceInformation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.SubstanceReferenceInformation{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SubstanceReferenceInformation)
	if !ok {
		return r5.SubstanceReferenceInformation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SubstanceReferenceInformation" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateSubstanceSourceMaterial(ctx context.Context, resource r5.SubstanceSourceMaterial) (r5.SubstanceSourceMaterial, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.SubstanceSourceMaterial{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for SubstanceSourceMaterial")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.SubstanceSourceMaterial{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SubstanceSourceMaterial)
	if !ok {
		return r5.SubstanceSourceMaterial{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SubstanceSourceMaterial" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateSupplyDelivery(ctx context.Context, resource r5.SupplyDelivery) (r5.SupplyDelivery, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.SupplyDelivery{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for SupplyDelivery")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.SupplyDelivery{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SupplyDelivery)
	if !ok {
		return r5.SupplyDelivery{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SupplyDelivery" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateSupplyRequest(ctx context.Context, resource r5.SupplyRequest) (r5.SupplyRequest, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.SupplyRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for SupplyRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.SupplyRequest{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SupplyRequest)
	if !ok {
		return r5.SupplyRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SupplyRequest" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateTask(ctx context.Context, resource r5.Task) (r5.Task, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Task{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Task")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Task{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Task)
	if !ok {
		return r5.Task{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Task" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateTerminologyCapabilities(ctx context.Context, resource r5.TerminologyCapabilities) (r5.TerminologyCapabilities, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.TerminologyCapabilities{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for TerminologyCapabilities")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.TerminologyCapabilities{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.TerminologyCapabilities)
	if !ok {
		return r5.TerminologyCapabilities{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "TerminologyCapabilities" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateTestPlan(ctx context.Context, resource r5.TestPlan) (r5.TestPlan, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.TestPlan{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for TestPlan")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.TestPlan{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.TestPlan)
	if !ok {
		return r5.TestPlan{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "TestPlan" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateTestReport(ctx context.Context, resource r5.TestReport) (r5.TestReport, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.TestReport{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for TestReport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.TestReport{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.TestReport)
	if !ok {
		return r5.TestReport{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "TestReport" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateTestScript(ctx context.Context, resource r5.TestScript) (r5.TestScript, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.TestScript{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for TestScript")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.TestScript{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.TestScript)
	if !ok {
		return r5.TestScript{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "TestScript" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateTransport(ctx context.Context, resource r5.Transport) (r5.Transport, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.Transport{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for Transport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.Transport{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Transport)
	if !ok {
		return r5.Transport{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Transport" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateValueSet(ctx context.Context, resource r5.ValueSet) (r5.ValueSet, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.ValueSet{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for ValueSet")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.ValueSet{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ValueSet)
	if !ok {
		return r5.ValueSet{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ValueSet" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateVerificationResult(ctx context.Context, resource r5.VerificationResult) (r5.VerificationResult, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.VerificationResult{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for VerificationResult")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.VerificationResult{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.VerificationResult)
	if !ok {
		return r5.VerificationResult{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "VerificationResult" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) CreateVisionPrescription(ctx context.Context, resource r5.VisionPrescription) (r5.VisionPrescription, error) {
	g, ok := w.Generic.(capabilities.GenericCreate)
	if !ok {
		return r5.VisionPrescription{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Create not implemented for VisionPrescription")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Create(ctx, resource)
	if err != nil {
		return r5.VisionPrescription{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.VisionPrescription)
	if !ok {
		return r5.VisionPrescription{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "VisionPrescription" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadAccount(ctx context.Context, id string) (r5.Account, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Account{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Account")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Account", id)
	if err != nil {
		return r5.Account{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Account)
	if !ok {
		return r5.Account{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Account" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadActivityDefinition(ctx context.Context, id string) (r5.ActivityDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.ActivityDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for ActivityDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "ActivityDefinition", id)
	if err != nil {
		return r5.ActivityDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ActivityDefinition)
	if !ok {
		return r5.ActivityDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ActivityDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadActorDefinition(ctx context.Context, id string) (r5.ActorDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.ActorDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for ActorDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "ActorDefinition", id)
	if err != nil {
		return r5.ActorDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ActorDefinition)
	if !ok {
		return r5.ActorDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ActorDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadAdministrableProductDefinition(ctx context.Context, id string) (r5.AdministrableProductDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.AdministrableProductDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for AdministrableProductDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "AdministrableProductDefinition", id)
	if err != nil {
		return r5.AdministrableProductDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.AdministrableProductDefinition)
	if !ok {
		return r5.AdministrableProductDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "AdministrableProductDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadAdverseEvent(ctx context.Context, id string) (r5.AdverseEvent, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.AdverseEvent{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for AdverseEvent")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "AdverseEvent", id)
	if err != nil {
		return r5.AdverseEvent{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.AdverseEvent)
	if !ok {
		return r5.AdverseEvent{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "AdverseEvent" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadAllergyIntolerance(ctx context.Context, id string) (r5.AllergyIntolerance, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.AllergyIntolerance{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for AllergyIntolerance")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "AllergyIntolerance", id)
	if err != nil {
		return r5.AllergyIntolerance{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.AllergyIntolerance)
	if !ok {
		return r5.AllergyIntolerance{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "AllergyIntolerance" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadAppointment(ctx context.Context, id string) (r5.Appointment, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Appointment{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Appointment")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Appointment", id)
	if err != nil {
		return r5.Appointment{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Appointment)
	if !ok {
		return r5.Appointment{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Appointment" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadAppointmentResponse(ctx context.Context, id string) (r5.AppointmentResponse, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.AppointmentResponse{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for AppointmentResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "AppointmentResponse", id)
	if err != nil {
		return r5.AppointmentResponse{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.AppointmentResponse)
	if !ok {
		return r5.AppointmentResponse{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "AppointmentResponse" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadArtifactAssessment(ctx context.Context, id string) (r5.ArtifactAssessment, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.ArtifactAssessment{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for ArtifactAssessment")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "ArtifactAssessment", id)
	if err != nil {
		return r5.ArtifactAssessment{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ArtifactAssessment)
	if !ok {
		return r5.ArtifactAssessment{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ArtifactAssessment" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadAuditEvent(ctx context.Context, id string) (r5.AuditEvent, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.AuditEvent{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for AuditEvent")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "AuditEvent", id)
	if err != nil {
		return r5.AuditEvent{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.AuditEvent)
	if !ok {
		return r5.AuditEvent{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "AuditEvent" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadBasic(ctx context.Context, id string) (r5.Basic, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Basic{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Basic")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Basic", id)
	if err != nil {
		return r5.Basic{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Basic)
	if !ok {
		return r5.Basic{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Basic" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadBinary(ctx context.Context, id string) (r5.Binary, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Binary{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Binary")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Binary", id)
	if err != nil {
		return r5.Binary{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Binary)
	if !ok {
		return r5.Binary{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Binary" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadBiologicallyDerivedProduct(ctx context.Context, id string) (r5.BiologicallyDerivedProduct, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.BiologicallyDerivedProduct{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for BiologicallyDerivedProduct")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "BiologicallyDerivedProduct", id)
	if err != nil {
		return r5.BiologicallyDerivedProduct{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.BiologicallyDerivedProduct)
	if !ok {
		return r5.BiologicallyDerivedProduct{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "BiologicallyDerivedProduct" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadBiologicallyDerivedProductDispense(ctx context.Context, id string) (r5.BiologicallyDerivedProductDispense, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.BiologicallyDerivedProductDispense{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for BiologicallyDerivedProductDispense")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "BiologicallyDerivedProductDispense", id)
	if err != nil {
		return r5.BiologicallyDerivedProductDispense{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.BiologicallyDerivedProductDispense)
	if !ok {
		return r5.BiologicallyDerivedProductDispense{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "BiologicallyDerivedProductDispense" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadBodyStructure(ctx context.Context, id string) (r5.BodyStructure, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.BodyStructure{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for BodyStructure")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "BodyStructure", id)
	if err != nil {
		return r5.BodyStructure{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.BodyStructure)
	if !ok {
		return r5.BodyStructure{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "BodyStructure" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadBundle(ctx context.Context, id string) (r5.Bundle, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Bundle{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Bundle")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Bundle", id)
	if err != nil {
		return r5.Bundle{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Bundle)
	if !ok {
		return r5.Bundle{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Bundle" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadCapabilityStatement(ctx context.Context, id string) (r5.CapabilityStatement, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.CapabilityStatement{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for CapabilityStatement")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "CapabilityStatement", id)
	if err != nil {
		return r5.CapabilityStatement{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.CapabilityStatement)
	if !ok {
		return r5.CapabilityStatement{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "CapabilityStatement" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadCarePlan(ctx context.Context, id string) (r5.CarePlan, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.CarePlan{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for CarePlan")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "CarePlan", id)
	if err != nil {
		return r5.CarePlan{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.CarePlan)
	if !ok {
		return r5.CarePlan{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "CarePlan" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadCareTeam(ctx context.Context, id string) (r5.CareTeam, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.CareTeam{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for CareTeam")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "CareTeam", id)
	if err != nil {
		return r5.CareTeam{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.CareTeam)
	if !ok {
		return r5.CareTeam{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "CareTeam" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadChargeItem(ctx context.Context, id string) (r5.ChargeItem, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.ChargeItem{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for ChargeItem")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "ChargeItem", id)
	if err != nil {
		return r5.ChargeItem{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ChargeItem)
	if !ok {
		return r5.ChargeItem{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ChargeItem" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadChargeItemDefinition(ctx context.Context, id string) (r5.ChargeItemDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.ChargeItemDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for ChargeItemDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "ChargeItemDefinition", id)
	if err != nil {
		return r5.ChargeItemDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ChargeItemDefinition)
	if !ok {
		return r5.ChargeItemDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ChargeItemDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadCitation(ctx context.Context, id string) (r5.Citation, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Citation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Citation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Citation", id)
	if err != nil {
		return r5.Citation{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Citation)
	if !ok {
		return r5.Citation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Citation" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadClaim(ctx context.Context, id string) (r5.Claim, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Claim{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Claim")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Claim", id)
	if err != nil {
		return r5.Claim{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Claim)
	if !ok {
		return r5.Claim{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Claim" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadClaimResponse(ctx context.Context, id string) (r5.ClaimResponse, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.ClaimResponse{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for ClaimResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "ClaimResponse", id)
	if err != nil {
		return r5.ClaimResponse{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ClaimResponse)
	if !ok {
		return r5.ClaimResponse{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ClaimResponse" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadClinicalImpression(ctx context.Context, id string) (r5.ClinicalImpression, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.ClinicalImpression{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for ClinicalImpression")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "ClinicalImpression", id)
	if err != nil {
		return r5.ClinicalImpression{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ClinicalImpression)
	if !ok {
		return r5.ClinicalImpression{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ClinicalImpression" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadClinicalUseDefinition(ctx context.Context, id string) (r5.ClinicalUseDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.ClinicalUseDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for ClinicalUseDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "ClinicalUseDefinition", id)
	if err != nil {
		return r5.ClinicalUseDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ClinicalUseDefinition)
	if !ok {
		return r5.ClinicalUseDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ClinicalUseDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadCodeSystem(ctx context.Context, id string) (r5.CodeSystem, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.CodeSystem{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for CodeSystem")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "CodeSystem", id)
	if err != nil {
		return r5.CodeSystem{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.CodeSystem)
	if !ok {
		return r5.CodeSystem{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "CodeSystem" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadCommunication(ctx context.Context, id string) (r5.Communication, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Communication{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Communication")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Communication", id)
	if err != nil {
		return r5.Communication{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Communication)
	if !ok {
		return r5.Communication{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Communication" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadCommunicationRequest(ctx context.Context, id string) (r5.CommunicationRequest, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.CommunicationRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for CommunicationRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "CommunicationRequest", id)
	if err != nil {
		return r5.CommunicationRequest{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.CommunicationRequest)
	if !ok {
		return r5.CommunicationRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "CommunicationRequest" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadCompartmentDefinition(ctx context.Context, id string) (r5.CompartmentDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.CompartmentDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for CompartmentDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "CompartmentDefinition", id)
	if err != nil {
		return r5.CompartmentDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.CompartmentDefinition)
	if !ok {
		return r5.CompartmentDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "CompartmentDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadComposition(ctx context.Context, id string) (r5.Composition, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Composition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Composition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Composition", id)
	if err != nil {
		return r5.Composition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Composition)
	if !ok {
		return r5.Composition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Composition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadConceptMap(ctx context.Context, id string) (r5.ConceptMap, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.ConceptMap{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for ConceptMap")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "ConceptMap", id)
	if err != nil {
		return r5.ConceptMap{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ConceptMap)
	if !ok {
		return r5.ConceptMap{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ConceptMap" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadCondition(ctx context.Context, id string) (r5.Condition, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Condition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Condition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Condition", id)
	if err != nil {
		return r5.Condition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Condition)
	if !ok {
		return r5.Condition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Condition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadConditionDefinition(ctx context.Context, id string) (r5.ConditionDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.ConditionDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for ConditionDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "ConditionDefinition", id)
	if err != nil {
		return r5.ConditionDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ConditionDefinition)
	if !ok {
		return r5.ConditionDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ConditionDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadConsent(ctx context.Context, id string) (r5.Consent, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Consent{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Consent")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Consent", id)
	if err != nil {
		return r5.Consent{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Consent)
	if !ok {
		return r5.Consent{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Consent" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadContract(ctx context.Context, id string) (r5.Contract, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Contract{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Contract")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Contract", id)
	if err != nil {
		return r5.Contract{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Contract)
	if !ok {
		return r5.Contract{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Contract" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadCoverage(ctx context.Context, id string) (r5.Coverage, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Coverage{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Coverage")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Coverage", id)
	if err != nil {
		return r5.Coverage{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Coverage)
	if !ok {
		return r5.Coverage{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Coverage" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadCoverageEligibilityRequest(ctx context.Context, id string) (r5.CoverageEligibilityRequest, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.CoverageEligibilityRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for CoverageEligibilityRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "CoverageEligibilityRequest", id)
	if err != nil {
		return r5.CoverageEligibilityRequest{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.CoverageEligibilityRequest)
	if !ok {
		return r5.CoverageEligibilityRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "CoverageEligibilityRequest" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadCoverageEligibilityResponse(ctx context.Context, id string) (r5.CoverageEligibilityResponse, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.CoverageEligibilityResponse{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for CoverageEligibilityResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "CoverageEligibilityResponse", id)
	if err != nil {
		return r5.CoverageEligibilityResponse{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.CoverageEligibilityResponse)
	if !ok {
		return r5.CoverageEligibilityResponse{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "CoverageEligibilityResponse" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadDetectedIssue(ctx context.Context, id string) (r5.DetectedIssue, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.DetectedIssue{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for DetectedIssue")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "DetectedIssue", id)
	if err != nil {
		return r5.DetectedIssue{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.DetectedIssue)
	if !ok {
		return r5.DetectedIssue{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "DetectedIssue" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadDevice(ctx context.Context, id string) (r5.Device, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Device{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Device")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Device", id)
	if err != nil {
		return r5.Device{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Device)
	if !ok {
		return r5.Device{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Device" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadDeviceAssociation(ctx context.Context, id string) (r5.DeviceAssociation, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.DeviceAssociation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for DeviceAssociation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "DeviceAssociation", id)
	if err != nil {
		return r5.DeviceAssociation{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.DeviceAssociation)
	if !ok {
		return r5.DeviceAssociation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "DeviceAssociation" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadDeviceDefinition(ctx context.Context, id string) (r5.DeviceDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.DeviceDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for DeviceDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "DeviceDefinition", id)
	if err != nil {
		return r5.DeviceDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.DeviceDefinition)
	if !ok {
		return r5.DeviceDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "DeviceDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadDeviceDispense(ctx context.Context, id string) (r5.DeviceDispense, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.DeviceDispense{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for DeviceDispense")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "DeviceDispense", id)
	if err != nil {
		return r5.DeviceDispense{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.DeviceDispense)
	if !ok {
		return r5.DeviceDispense{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "DeviceDispense" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadDeviceMetric(ctx context.Context, id string) (r5.DeviceMetric, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.DeviceMetric{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for DeviceMetric")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "DeviceMetric", id)
	if err != nil {
		return r5.DeviceMetric{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.DeviceMetric)
	if !ok {
		return r5.DeviceMetric{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "DeviceMetric" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadDeviceRequest(ctx context.Context, id string) (r5.DeviceRequest, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.DeviceRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for DeviceRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "DeviceRequest", id)
	if err != nil {
		return r5.DeviceRequest{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.DeviceRequest)
	if !ok {
		return r5.DeviceRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "DeviceRequest" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadDeviceUsage(ctx context.Context, id string) (r5.DeviceUsage, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.DeviceUsage{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for DeviceUsage")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "DeviceUsage", id)
	if err != nil {
		return r5.DeviceUsage{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.DeviceUsage)
	if !ok {
		return r5.DeviceUsage{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "DeviceUsage" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadDiagnosticReport(ctx context.Context, id string) (r5.DiagnosticReport, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.DiagnosticReport{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for DiagnosticReport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "DiagnosticReport", id)
	if err != nil {
		return r5.DiagnosticReport{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.DiagnosticReport)
	if !ok {
		return r5.DiagnosticReport{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "DiagnosticReport" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadDocumentReference(ctx context.Context, id string) (r5.DocumentReference, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.DocumentReference{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for DocumentReference")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "DocumentReference", id)
	if err != nil {
		return r5.DocumentReference{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.DocumentReference)
	if !ok {
		return r5.DocumentReference{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "DocumentReference" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadEncounter(ctx context.Context, id string) (r5.Encounter, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Encounter{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Encounter")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Encounter", id)
	if err != nil {
		return r5.Encounter{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Encounter)
	if !ok {
		return r5.Encounter{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Encounter" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadEncounterHistory(ctx context.Context, id string) (r5.EncounterHistory, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.EncounterHistory{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for EncounterHistory")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "EncounterHistory", id)
	if err != nil {
		return r5.EncounterHistory{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.EncounterHistory)
	if !ok {
		return r5.EncounterHistory{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "EncounterHistory" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadEndpoint(ctx context.Context, id string) (r5.Endpoint, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Endpoint{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Endpoint")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Endpoint", id)
	if err != nil {
		return r5.Endpoint{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Endpoint)
	if !ok {
		return r5.Endpoint{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Endpoint" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadEnrollmentRequest(ctx context.Context, id string) (r5.EnrollmentRequest, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.EnrollmentRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for EnrollmentRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "EnrollmentRequest", id)
	if err != nil {
		return r5.EnrollmentRequest{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.EnrollmentRequest)
	if !ok {
		return r5.EnrollmentRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "EnrollmentRequest" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadEnrollmentResponse(ctx context.Context, id string) (r5.EnrollmentResponse, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.EnrollmentResponse{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for EnrollmentResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "EnrollmentResponse", id)
	if err != nil {
		return r5.EnrollmentResponse{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.EnrollmentResponse)
	if !ok {
		return r5.EnrollmentResponse{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "EnrollmentResponse" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadEpisodeOfCare(ctx context.Context, id string) (r5.EpisodeOfCare, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.EpisodeOfCare{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for EpisodeOfCare")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "EpisodeOfCare", id)
	if err != nil {
		return r5.EpisodeOfCare{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.EpisodeOfCare)
	if !ok {
		return r5.EpisodeOfCare{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "EpisodeOfCare" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadEventDefinition(ctx context.Context, id string) (r5.EventDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.EventDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for EventDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "EventDefinition", id)
	if err != nil {
		return r5.EventDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.EventDefinition)
	if !ok {
		return r5.EventDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "EventDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadEvidence(ctx context.Context, id string) (r5.Evidence, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Evidence{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Evidence")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Evidence", id)
	if err != nil {
		return r5.Evidence{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Evidence)
	if !ok {
		return r5.Evidence{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Evidence" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadEvidenceReport(ctx context.Context, id string) (r5.EvidenceReport, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.EvidenceReport{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for EvidenceReport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "EvidenceReport", id)
	if err != nil {
		return r5.EvidenceReport{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.EvidenceReport)
	if !ok {
		return r5.EvidenceReport{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "EvidenceReport" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadEvidenceVariable(ctx context.Context, id string) (r5.EvidenceVariable, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.EvidenceVariable{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for EvidenceVariable")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "EvidenceVariable", id)
	if err != nil {
		return r5.EvidenceVariable{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.EvidenceVariable)
	if !ok {
		return r5.EvidenceVariable{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "EvidenceVariable" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadExampleScenario(ctx context.Context, id string) (r5.ExampleScenario, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.ExampleScenario{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for ExampleScenario")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "ExampleScenario", id)
	if err != nil {
		return r5.ExampleScenario{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ExampleScenario)
	if !ok {
		return r5.ExampleScenario{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ExampleScenario" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadExplanationOfBenefit(ctx context.Context, id string) (r5.ExplanationOfBenefit, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.ExplanationOfBenefit{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for ExplanationOfBenefit")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "ExplanationOfBenefit", id)
	if err != nil {
		return r5.ExplanationOfBenefit{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ExplanationOfBenefit)
	if !ok {
		return r5.ExplanationOfBenefit{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ExplanationOfBenefit" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadFamilyMemberHistory(ctx context.Context, id string) (r5.FamilyMemberHistory, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.FamilyMemberHistory{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for FamilyMemberHistory")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "FamilyMemberHistory", id)
	if err != nil {
		return r5.FamilyMemberHistory{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.FamilyMemberHistory)
	if !ok {
		return r5.FamilyMemberHistory{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "FamilyMemberHistory" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadFlag(ctx context.Context, id string) (r5.Flag, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Flag{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Flag")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Flag", id)
	if err != nil {
		return r5.Flag{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Flag)
	if !ok {
		return r5.Flag{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Flag" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadFormularyItem(ctx context.Context, id string) (r5.FormularyItem, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.FormularyItem{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for FormularyItem")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "FormularyItem", id)
	if err != nil {
		return r5.FormularyItem{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.FormularyItem)
	if !ok {
		return r5.FormularyItem{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "FormularyItem" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadGenomicStudy(ctx context.Context, id string) (r5.GenomicStudy, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.GenomicStudy{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for GenomicStudy")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "GenomicStudy", id)
	if err != nil {
		return r5.GenomicStudy{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.GenomicStudy)
	if !ok {
		return r5.GenomicStudy{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "GenomicStudy" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadGoal(ctx context.Context, id string) (r5.Goal, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Goal{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Goal")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Goal", id)
	if err != nil {
		return r5.Goal{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Goal)
	if !ok {
		return r5.Goal{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Goal" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadGraphDefinition(ctx context.Context, id string) (r5.GraphDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.GraphDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for GraphDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "GraphDefinition", id)
	if err != nil {
		return r5.GraphDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.GraphDefinition)
	if !ok {
		return r5.GraphDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "GraphDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadGroup(ctx context.Context, id string) (r5.Group, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Group{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Group")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Group", id)
	if err != nil {
		return r5.Group{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Group)
	if !ok {
		return r5.Group{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Group" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadGuidanceResponse(ctx context.Context, id string) (r5.GuidanceResponse, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.GuidanceResponse{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for GuidanceResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "GuidanceResponse", id)
	if err != nil {
		return r5.GuidanceResponse{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.GuidanceResponse)
	if !ok {
		return r5.GuidanceResponse{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "GuidanceResponse" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadHealthcareService(ctx context.Context, id string) (r5.HealthcareService, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.HealthcareService{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for HealthcareService")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "HealthcareService", id)
	if err != nil {
		return r5.HealthcareService{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.HealthcareService)
	if !ok {
		return r5.HealthcareService{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "HealthcareService" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadImagingSelection(ctx context.Context, id string) (r5.ImagingSelection, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.ImagingSelection{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for ImagingSelection")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "ImagingSelection", id)
	if err != nil {
		return r5.ImagingSelection{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ImagingSelection)
	if !ok {
		return r5.ImagingSelection{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ImagingSelection" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadImagingStudy(ctx context.Context, id string) (r5.ImagingStudy, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.ImagingStudy{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for ImagingStudy")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "ImagingStudy", id)
	if err != nil {
		return r5.ImagingStudy{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ImagingStudy)
	if !ok {
		return r5.ImagingStudy{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ImagingStudy" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadImmunization(ctx context.Context, id string) (r5.Immunization, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Immunization{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Immunization")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Immunization", id)
	if err != nil {
		return r5.Immunization{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Immunization)
	if !ok {
		return r5.Immunization{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Immunization" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadImmunizationEvaluation(ctx context.Context, id string) (r5.ImmunizationEvaluation, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.ImmunizationEvaluation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for ImmunizationEvaluation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "ImmunizationEvaluation", id)
	if err != nil {
		return r5.ImmunizationEvaluation{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ImmunizationEvaluation)
	if !ok {
		return r5.ImmunizationEvaluation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ImmunizationEvaluation" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadImmunizationRecommendation(ctx context.Context, id string) (r5.ImmunizationRecommendation, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.ImmunizationRecommendation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for ImmunizationRecommendation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "ImmunizationRecommendation", id)
	if err != nil {
		return r5.ImmunizationRecommendation{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ImmunizationRecommendation)
	if !ok {
		return r5.ImmunizationRecommendation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ImmunizationRecommendation" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadImplementationGuide(ctx context.Context, id string) (r5.ImplementationGuide, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.ImplementationGuide{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for ImplementationGuide")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "ImplementationGuide", id)
	if err != nil {
		return r5.ImplementationGuide{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ImplementationGuide)
	if !ok {
		return r5.ImplementationGuide{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ImplementationGuide" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadIngredient(ctx context.Context, id string) (r5.Ingredient, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Ingredient{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Ingredient")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Ingredient", id)
	if err != nil {
		return r5.Ingredient{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Ingredient)
	if !ok {
		return r5.Ingredient{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Ingredient" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadInsurancePlan(ctx context.Context, id string) (r5.InsurancePlan, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.InsurancePlan{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for InsurancePlan")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "InsurancePlan", id)
	if err != nil {
		return r5.InsurancePlan{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.InsurancePlan)
	if !ok {
		return r5.InsurancePlan{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "InsurancePlan" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadInventoryItem(ctx context.Context, id string) (r5.InventoryItem, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.InventoryItem{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for InventoryItem")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "InventoryItem", id)
	if err != nil {
		return r5.InventoryItem{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.InventoryItem)
	if !ok {
		return r5.InventoryItem{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "InventoryItem" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadInventoryReport(ctx context.Context, id string) (r5.InventoryReport, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.InventoryReport{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for InventoryReport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "InventoryReport", id)
	if err != nil {
		return r5.InventoryReport{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.InventoryReport)
	if !ok {
		return r5.InventoryReport{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "InventoryReport" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadInvoice(ctx context.Context, id string) (r5.Invoice, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Invoice{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Invoice")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Invoice", id)
	if err != nil {
		return r5.Invoice{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Invoice)
	if !ok {
		return r5.Invoice{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Invoice" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadLibrary(ctx context.Context, id string) (r5.Library, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Library{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Library")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Library", id)
	if err != nil {
		return r5.Library{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Library)
	if !ok {
		return r5.Library{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Library" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadLinkage(ctx context.Context, id string) (r5.Linkage, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Linkage{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Linkage")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Linkage", id)
	if err != nil {
		return r5.Linkage{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Linkage)
	if !ok {
		return r5.Linkage{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Linkage" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadList(ctx context.Context, id string) (r5.List, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.List{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for List")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "List", id)
	if err != nil {
		return r5.List{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.List)
	if !ok {
		return r5.List{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "List" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadLocation(ctx context.Context, id string) (r5.Location, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Location{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Location")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Location", id)
	if err != nil {
		return r5.Location{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Location)
	if !ok {
		return r5.Location{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Location" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadManufacturedItemDefinition(ctx context.Context, id string) (r5.ManufacturedItemDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.ManufacturedItemDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for ManufacturedItemDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "ManufacturedItemDefinition", id)
	if err != nil {
		return r5.ManufacturedItemDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ManufacturedItemDefinition)
	if !ok {
		return r5.ManufacturedItemDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ManufacturedItemDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadMeasure(ctx context.Context, id string) (r5.Measure, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Measure{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Measure")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Measure", id)
	if err != nil {
		return r5.Measure{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Measure)
	if !ok {
		return r5.Measure{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Measure" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadMeasureReport(ctx context.Context, id string) (r5.MeasureReport, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.MeasureReport{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for MeasureReport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "MeasureReport", id)
	if err != nil {
		return r5.MeasureReport{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MeasureReport)
	if !ok {
		return r5.MeasureReport{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MeasureReport" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadMedication(ctx context.Context, id string) (r5.Medication, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Medication{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Medication")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Medication", id)
	if err != nil {
		return r5.Medication{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Medication)
	if !ok {
		return r5.Medication{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Medication" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadMedicationAdministration(ctx context.Context, id string) (r5.MedicationAdministration, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.MedicationAdministration{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for MedicationAdministration")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "MedicationAdministration", id)
	if err != nil {
		return r5.MedicationAdministration{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MedicationAdministration)
	if !ok {
		return r5.MedicationAdministration{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MedicationAdministration" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadMedicationDispense(ctx context.Context, id string) (r5.MedicationDispense, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.MedicationDispense{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for MedicationDispense")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "MedicationDispense", id)
	if err != nil {
		return r5.MedicationDispense{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MedicationDispense)
	if !ok {
		return r5.MedicationDispense{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MedicationDispense" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadMedicationKnowledge(ctx context.Context, id string) (r5.MedicationKnowledge, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.MedicationKnowledge{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for MedicationKnowledge")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "MedicationKnowledge", id)
	if err != nil {
		return r5.MedicationKnowledge{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MedicationKnowledge)
	if !ok {
		return r5.MedicationKnowledge{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MedicationKnowledge" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadMedicationRequest(ctx context.Context, id string) (r5.MedicationRequest, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.MedicationRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for MedicationRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "MedicationRequest", id)
	if err != nil {
		return r5.MedicationRequest{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MedicationRequest)
	if !ok {
		return r5.MedicationRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MedicationRequest" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadMedicationStatement(ctx context.Context, id string) (r5.MedicationStatement, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.MedicationStatement{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for MedicationStatement")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "MedicationStatement", id)
	if err != nil {
		return r5.MedicationStatement{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MedicationStatement)
	if !ok {
		return r5.MedicationStatement{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MedicationStatement" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadMedicinalProductDefinition(ctx context.Context, id string) (r5.MedicinalProductDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.MedicinalProductDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for MedicinalProductDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "MedicinalProductDefinition", id)
	if err != nil {
		return r5.MedicinalProductDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MedicinalProductDefinition)
	if !ok {
		return r5.MedicinalProductDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MedicinalProductDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadMessageDefinition(ctx context.Context, id string) (r5.MessageDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.MessageDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for MessageDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "MessageDefinition", id)
	if err != nil {
		return r5.MessageDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MessageDefinition)
	if !ok {
		return r5.MessageDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MessageDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadMessageHeader(ctx context.Context, id string) (r5.MessageHeader, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.MessageHeader{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for MessageHeader")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "MessageHeader", id)
	if err != nil {
		return r5.MessageHeader{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MessageHeader)
	if !ok {
		return r5.MessageHeader{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MessageHeader" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadMolecularSequence(ctx context.Context, id string) (r5.MolecularSequence, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.MolecularSequence{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for MolecularSequence")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "MolecularSequence", id)
	if err != nil {
		return r5.MolecularSequence{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MolecularSequence)
	if !ok {
		return r5.MolecularSequence{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MolecularSequence" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadNamingSystem(ctx context.Context, id string) (r5.NamingSystem, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.NamingSystem{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for NamingSystem")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "NamingSystem", id)
	if err != nil {
		return r5.NamingSystem{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.NamingSystem)
	if !ok {
		return r5.NamingSystem{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "NamingSystem" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadNutritionIntake(ctx context.Context, id string) (r5.NutritionIntake, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.NutritionIntake{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for NutritionIntake")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "NutritionIntake", id)
	if err != nil {
		return r5.NutritionIntake{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.NutritionIntake)
	if !ok {
		return r5.NutritionIntake{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "NutritionIntake" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadNutritionOrder(ctx context.Context, id string) (r5.NutritionOrder, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.NutritionOrder{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for NutritionOrder")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "NutritionOrder", id)
	if err != nil {
		return r5.NutritionOrder{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.NutritionOrder)
	if !ok {
		return r5.NutritionOrder{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "NutritionOrder" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadNutritionProduct(ctx context.Context, id string) (r5.NutritionProduct, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.NutritionProduct{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for NutritionProduct")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "NutritionProduct", id)
	if err != nil {
		return r5.NutritionProduct{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.NutritionProduct)
	if !ok {
		return r5.NutritionProduct{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "NutritionProduct" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadObservation(ctx context.Context, id string) (r5.Observation, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Observation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Observation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Observation", id)
	if err != nil {
		return r5.Observation{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Observation)
	if !ok {
		return r5.Observation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Observation" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadObservationDefinition(ctx context.Context, id string) (r5.ObservationDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.ObservationDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for ObservationDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "ObservationDefinition", id)
	if err != nil {
		return r5.ObservationDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ObservationDefinition)
	if !ok {
		return r5.ObservationDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ObservationDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadOperationDefinition(ctx context.Context, id string) (r5.OperationDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.OperationDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for OperationDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "OperationDefinition", id)
	if err != nil {
		return r5.OperationDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.OperationDefinition)
	if !ok {
		return r5.OperationDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "OperationDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadOperationOutcome(ctx context.Context, id string) (r5.OperationOutcome, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.OperationOutcome{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for OperationOutcome")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "OperationOutcome", id)
	if err != nil {
		return r5.OperationOutcome{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.OperationOutcome)
	if !ok {
		return r5.OperationOutcome{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "OperationOutcome" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadOrganization(ctx context.Context, id string) (r5.Organization, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Organization{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Organization")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Organization", id)
	if err != nil {
		return r5.Organization{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Organization)
	if !ok {
		return r5.Organization{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Organization" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadOrganizationAffiliation(ctx context.Context, id string) (r5.OrganizationAffiliation, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.OrganizationAffiliation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for OrganizationAffiliation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "OrganizationAffiliation", id)
	if err != nil {
		return r5.OrganizationAffiliation{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.OrganizationAffiliation)
	if !ok {
		return r5.OrganizationAffiliation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "OrganizationAffiliation" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadPackagedProductDefinition(ctx context.Context, id string) (r5.PackagedProductDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.PackagedProductDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for PackagedProductDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "PackagedProductDefinition", id)
	if err != nil {
		return r5.PackagedProductDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.PackagedProductDefinition)
	if !ok {
		return r5.PackagedProductDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "PackagedProductDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadParameters(ctx context.Context, id string) (r5.Parameters, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Parameters{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Parameters")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Parameters", id)
	if err != nil {
		return r5.Parameters{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Parameters)
	if !ok {
		return r5.Parameters{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Parameters" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadPatient(ctx context.Context, id string) (r5.Patient, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Patient{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Patient")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Patient", id)
	if err != nil {
		return r5.Patient{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Patient)
	if !ok {
		return r5.Patient{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Patient" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadPaymentNotice(ctx context.Context, id string) (r5.PaymentNotice, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.PaymentNotice{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for PaymentNotice")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "PaymentNotice", id)
	if err != nil {
		return r5.PaymentNotice{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.PaymentNotice)
	if !ok {
		return r5.PaymentNotice{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "PaymentNotice" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadPaymentReconciliation(ctx context.Context, id string) (r5.PaymentReconciliation, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.PaymentReconciliation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for PaymentReconciliation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "PaymentReconciliation", id)
	if err != nil {
		return r5.PaymentReconciliation{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.PaymentReconciliation)
	if !ok {
		return r5.PaymentReconciliation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "PaymentReconciliation" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadPermission(ctx context.Context, id string) (r5.Permission, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Permission{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Permission")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Permission", id)
	if err != nil {
		return r5.Permission{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Permission)
	if !ok {
		return r5.Permission{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Permission" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadPerson(ctx context.Context, id string) (r5.Person, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Person{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Person")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Person", id)
	if err != nil {
		return r5.Person{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Person)
	if !ok {
		return r5.Person{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Person" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadPlanDefinition(ctx context.Context, id string) (r5.PlanDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.PlanDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for PlanDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "PlanDefinition", id)
	if err != nil {
		return r5.PlanDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.PlanDefinition)
	if !ok {
		return r5.PlanDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "PlanDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadPractitioner(ctx context.Context, id string) (r5.Practitioner, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Practitioner{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Practitioner")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Practitioner", id)
	if err != nil {
		return r5.Practitioner{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Practitioner)
	if !ok {
		return r5.Practitioner{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Practitioner" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadPractitionerRole(ctx context.Context, id string) (r5.PractitionerRole, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.PractitionerRole{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for PractitionerRole")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "PractitionerRole", id)
	if err != nil {
		return r5.PractitionerRole{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.PractitionerRole)
	if !ok {
		return r5.PractitionerRole{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "PractitionerRole" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadProcedure(ctx context.Context, id string) (r5.Procedure, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Procedure{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Procedure")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Procedure", id)
	if err != nil {
		return r5.Procedure{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Procedure)
	if !ok {
		return r5.Procedure{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Procedure" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadProvenance(ctx context.Context, id string) (r5.Provenance, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Provenance{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Provenance")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Provenance", id)
	if err != nil {
		return r5.Provenance{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Provenance)
	if !ok {
		return r5.Provenance{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Provenance" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadQuestionnaire(ctx context.Context, id string) (r5.Questionnaire, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Questionnaire{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Questionnaire")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Questionnaire", id)
	if err != nil {
		return r5.Questionnaire{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Questionnaire)
	if !ok {
		return r5.Questionnaire{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Questionnaire" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadQuestionnaireResponse(ctx context.Context, id string) (r5.QuestionnaireResponse, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.QuestionnaireResponse{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for QuestionnaireResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "QuestionnaireResponse", id)
	if err != nil {
		return r5.QuestionnaireResponse{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.QuestionnaireResponse)
	if !ok {
		return r5.QuestionnaireResponse{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "QuestionnaireResponse" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadRegulatedAuthorization(ctx context.Context, id string) (r5.RegulatedAuthorization, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.RegulatedAuthorization{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for RegulatedAuthorization")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "RegulatedAuthorization", id)
	if err != nil {
		return r5.RegulatedAuthorization{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.RegulatedAuthorization)
	if !ok {
		return r5.RegulatedAuthorization{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "RegulatedAuthorization" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadRelatedPerson(ctx context.Context, id string) (r5.RelatedPerson, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.RelatedPerson{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for RelatedPerson")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "RelatedPerson", id)
	if err != nil {
		return r5.RelatedPerson{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.RelatedPerson)
	if !ok {
		return r5.RelatedPerson{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "RelatedPerson" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadRequestOrchestration(ctx context.Context, id string) (r5.RequestOrchestration, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.RequestOrchestration{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for RequestOrchestration")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "RequestOrchestration", id)
	if err != nil {
		return r5.RequestOrchestration{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.RequestOrchestration)
	if !ok {
		return r5.RequestOrchestration{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "RequestOrchestration" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadRequirements(ctx context.Context, id string) (r5.Requirements, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Requirements{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Requirements")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Requirements", id)
	if err != nil {
		return r5.Requirements{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Requirements)
	if !ok {
		return r5.Requirements{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Requirements" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadResearchStudy(ctx context.Context, id string) (r5.ResearchStudy, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.ResearchStudy{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for ResearchStudy")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "ResearchStudy", id)
	if err != nil {
		return r5.ResearchStudy{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ResearchStudy)
	if !ok {
		return r5.ResearchStudy{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ResearchStudy" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadResearchSubject(ctx context.Context, id string) (r5.ResearchSubject, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.ResearchSubject{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for ResearchSubject")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "ResearchSubject", id)
	if err != nil {
		return r5.ResearchSubject{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ResearchSubject)
	if !ok {
		return r5.ResearchSubject{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ResearchSubject" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadRiskAssessment(ctx context.Context, id string) (r5.RiskAssessment, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.RiskAssessment{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for RiskAssessment")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "RiskAssessment", id)
	if err != nil {
		return r5.RiskAssessment{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.RiskAssessment)
	if !ok {
		return r5.RiskAssessment{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "RiskAssessment" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadSchedule(ctx context.Context, id string) (r5.Schedule, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Schedule{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Schedule")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Schedule", id)
	if err != nil {
		return r5.Schedule{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Schedule)
	if !ok {
		return r5.Schedule{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Schedule" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadSearchParameter(ctx context.Context, id string) (r5.SearchParameter, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.SearchParameter{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for SearchParameter")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "SearchParameter", id)
	if err != nil {
		return r5.SearchParameter{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SearchParameter)
	if !ok {
		return r5.SearchParameter{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SearchParameter" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadServiceRequest(ctx context.Context, id string) (r5.ServiceRequest, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.ServiceRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for ServiceRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "ServiceRequest", id)
	if err != nil {
		return r5.ServiceRequest{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ServiceRequest)
	if !ok {
		return r5.ServiceRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ServiceRequest" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadSlot(ctx context.Context, id string) (r5.Slot, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Slot{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Slot")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Slot", id)
	if err != nil {
		return r5.Slot{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Slot)
	if !ok {
		return r5.Slot{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Slot" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadSpecimen(ctx context.Context, id string) (r5.Specimen, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Specimen{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Specimen")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Specimen", id)
	if err != nil {
		return r5.Specimen{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Specimen)
	if !ok {
		return r5.Specimen{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Specimen" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadSpecimenDefinition(ctx context.Context, id string) (r5.SpecimenDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.SpecimenDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for SpecimenDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "SpecimenDefinition", id)
	if err != nil {
		return r5.SpecimenDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SpecimenDefinition)
	if !ok {
		return r5.SpecimenDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SpecimenDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadStructureDefinition(ctx context.Context, id string) (r5.StructureDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.StructureDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for StructureDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "StructureDefinition", id)
	if err != nil {
		return r5.StructureDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.StructureDefinition)
	if !ok {
		return r5.StructureDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "StructureDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadStructureMap(ctx context.Context, id string) (r5.StructureMap, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.StructureMap{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for StructureMap")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "StructureMap", id)
	if err != nil {
		return r5.StructureMap{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.StructureMap)
	if !ok {
		return r5.StructureMap{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "StructureMap" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadSubscription(ctx context.Context, id string) (r5.Subscription, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Subscription{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Subscription")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Subscription", id)
	if err != nil {
		return r5.Subscription{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Subscription)
	if !ok {
		return r5.Subscription{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Subscription" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadSubscriptionStatus(ctx context.Context, id string) (r5.SubscriptionStatus, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.SubscriptionStatus{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for SubscriptionStatus")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "SubscriptionStatus", id)
	if err != nil {
		return r5.SubscriptionStatus{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SubscriptionStatus)
	if !ok {
		return r5.SubscriptionStatus{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SubscriptionStatus" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadSubscriptionTopic(ctx context.Context, id string) (r5.SubscriptionTopic, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.SubscriptionTopic{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for SubscriptionTopic")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "SubscriptionTopic", id)
	if err != nil {
		return r5.SubscriptionTopic{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SubscriptionTopic)
	if !ok {
		return r5.SubscriptionTopic{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SubscriptionTopic" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadSubstance(ctx context.Context, id string) (r5.Substance, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Substance{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Substance")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Substance", id)
	if err != nil {
		return r5.Substance{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Substance)
	if !ok {
		return r5.Substance{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Substance" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadSubstanceDefinition(ctx context.Context, id string) (r5.SubstanceDefinition, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.SubstanceDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for SubstanceDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "SubstanceDefinition", id)
	if err != nil {
		return r5.SubstanceDefinition{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SubstanceDefinition)
	if !ok {
		return r5.SubstanceDefinition{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SubstanceDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadSubstanceNucleicAcid(ctx context.Context, id string) (r5.SubstanceNucleicAcid, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.SubstanceNucleicAcid{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for SubstanceNucleicAcid")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "SubstanceNucleicAcid", id)
	if err != nil {
		return r5.SubstanceNucleicAcid{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SubstanceNucleicAcid)
	if !ok {
		return r5.SubstanceNucleicAcid{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SubstanceNucleicAcid" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadSubstancePolymer(ctx context.Context, id string) (r5.SubstancePolymer, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.SubstancePolymer{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for SubstancePolymer")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "SubstancePolymer", id)
	if err != nil {
		return r5.SubstancePolymer{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SubstancePolymer)
	if !ok {
		return r5.SubstancePolymer{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SubstancePolymer" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadSubstanceProtein(ctx context.Context, id string) (r5.SubstanceProtein, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.SubstanceProtein{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for SubstanceProtein")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "SubstanceProtein", id)
	if err != nil {
		return r5.SubstanceProtein{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SubstanceProtein)
	if !ok {
		return r5.SubstanceProtein{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SubstanceProtein" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadSubstanceReferenceInformation(ctx context.Context, id string) (r5.SubstanceReferenceInformation, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.SubstanceReferenceInformation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for SubstanceReferenceInformation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "SubstanceReferenceInformation", id)
	if err != nil {
		return r5.SubstanceReferenceInformation{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SubstanceReferenceInformation)
	if !ok {
		return r5.SubstanceReferenceInformation{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SubstanceReferenceInformation" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadSubstanceSourceMaterial(ctx context.Context, id string) (r5.SubstanceSourceMaterial, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.SubstanceSourceMaterial{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for SubstanceSourceMaterial")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "SubstanceSourceMaterial", id)
	if err != nil {
		return r5.SubstanceSourceMaterial{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SubstanceSourceMaterial)
	if !ok {
		return r5.SubstanceSourceMaterial{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SubstanceSourceMaterial" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadSupplyDelivery(ctx context.Context, id string) (r5.SupplyDelivery, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.SupplyDelivery{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for SupplyDelivery")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "SupplyDelivery", id)
	if err != nil {
		return r5.SupplyDelivery{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SupplyDelivery)
	if !ok {
		return r5.SupplyDelivery{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SupplyDelivery" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadSupplyRequest(ctx context.Context, id string) (r5.SupplyRequest, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.SupplyRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for SupplyRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "SupplyRequest", id)
	if err != nil {
		return r5.SupplyRequest{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SupplyRequest)
	if !ok {
		return r5.SupplyRequest{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SupplyRequest" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadTask(ctx context.Context, id string) (r5.Task, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Task{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Task")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Task", id)
	if err != nil {
		return r5.Task{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Task)
	if !ok {
		return r5.Task{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Task" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadTerminologyCapabilities(ctx context.Context, id string) (r5.TerminologyCapabilities, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.TerminologyCapabilities{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for TerminologyCapabilities")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "TerminologyCapabilities", id)
	if err != nil {
		return r5.TerminologyCapabilities{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.TerminologyCapabilities)
	if !ok {
		return r5.TerminologyCapabilities{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "TerminologyCapabilities" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadTestPlan(ctx context.Context, id string) (r5.TestPlan, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.TestPlan{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for TestPlan")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "TestPlan", id)
	if err != nil {
		return r5.TestPlan{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.TestPlan)
	if !ok {
		return r5.TestPlan{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "TestPlan" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadTestReport(ctx context.Context, id string) (r5.TestReport, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.TestReport{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for TestReport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "TestReport", id)
	if err != nil {
		return r5.TestReport{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.TestReport)
	if !ok {
		return r5.TestReport{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "TestReport" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadTestScript(ctx context.Context, id string) (r5.TestScript, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.TestScript{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for TestScript")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "TestScript", id)
	if err != nil {
		return r5.TestScript{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.TestScript)
	if !ok {
		return r5.TestScript{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "TestScript" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadTransport(ctx context.Context, id string) (r5.Transport, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.Transport{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for Transport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "Transport", id)
	if err != nil {
		return r5.Transport{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Transport)
	if !ok {
		return r5.Transport{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Transport" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadValueSet(ctx context.Context, id string) (r5.ValueSet, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.ValueSet{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for ValueSet")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "ValueSet", id)
	if err != nil {
		return r5.ValueSet{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ValueSet)
	if !ok {
		return r5.ValueSet{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ValueSet" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadVerificationResult(ctx context.Context, id string) (r5.VerificationResult, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.VerificationResult{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for VerificationResult")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "VerificationResult", id)
	if err != nil {
		return r5.VerificationResult{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.VerificationResult)
	if !ok {
		return r5.VerificationResult{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "VerificationResult" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) ReadVisionPrescription(ctx context.Context, id string) (r5.VisionPrescription, error) {
	g, ok := w.Generic.(capabilities.GenericRead)
	if !ok {
		return r5.VisionPrescription{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Read not implemented for VisionPrescription")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	v, err := g.Read(ctx, "VisionPrescription", id)
	if err != nil {
		return r5.VisionPrescription{}, err
	}
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.VisionPrescription)
	if !ok {
		return r5.VisionPrescription{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "VisionPrescription" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return r, nil
}
func (w Concrete) UpdateAccount(ctx context.Context, resource r5.Account) (update.Result[r5.Account], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Account]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Account")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Account]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Account)
	if !ok {
		return update.Result[r5.Account]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Account" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Account]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesAccount(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(AccountUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesAccount(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateActivityDefinition(ctx context.Context, resource r5.ActivityDefinition) (update.Result[r5.ActivityDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.ActivityDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for ActivityDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.ActivityDefinition]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ActivityDefinition)
	if !ok {
		return update.Result[r5.ActivityDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ActivityDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.ActivityDefinition]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesActivityDefinition(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ActivityDefinitionUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesActivityDefinition(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateActorDefinition(ctx context.Context, resource r5.ActorDefinition) (update.Result[r5.ActorDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.ActorDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for ActorDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.ActorDefinition]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ActorDefinition)
	if !ok {
		return update.Result[r5.ActorDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ActorDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.ActorDefinition]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesActorDefinition(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ActorDefinitionUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesActorDefinition(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateAdministrableProductDefinition(ctx context.Context, resource r5.AdministrableProductDefinition) (update.Result[r5.AdministrableProductDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.AdministrableProductDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for AdministrableProductDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.AdministrableProductDefinition]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.AdministrableProductDefinition)
	if !ok {
		return update.Result[r5.AdministrableProductDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "AdministrableProductDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.AdministrableProductDefinition]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesAdministrableProductDefinition(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(AdministrableProductDefinitionUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesAdministrableProductDefinition(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateAdverseEvent(ctx context.Context, resource r5.AdverseEvent) (update.Result[r5.AdverseEvent], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.AdverseEvent]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for AdverseEvent")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.AdverseEvent]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.AdverseEvent)
	if !ok {
		return update.Result[r5.AdverseEvent]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "AdverseEvent" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.AdverseEvent]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesAdverseEvent(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(AdverseEventUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesAdverseEvent(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateAllergyIntolerance(ctx context.Context, resource r5.AllergyIntolerance) (update.Result[r5.AllergyIntolerance], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.AllergyIntolerance]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for AllergyIntolerance")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.AllergyIntolerance]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.AllergyIntolerance)
	if !ok {
		return update.Result[r5.AllergyIntolerance]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "AllergyIntolerance" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.AllergyIntolerance]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesAllergyIntolerance(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(AllergyIntoleranceUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesAllergyIntolerance(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateAppointment(ctx context.Context, resource r5.Appointment) (update.Result[r5.Appointment], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Appointment]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Appointment")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Appointment]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Appointment)
	if !ok {
		return update.Result[r5.Appointment]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Appointment" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Appointment]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesAppointment(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(AppointmentUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesAppointment(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateAppointmentResponse(ctx context.Context, resource r5.AppointmentResponse) (update.Result[r5.AppointmentResponse], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.AppointmentResponse]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for AppointmentResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.AppointmentResponse]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.AppointmentResponse)
	if !ok {
		return update.Result[r5.AppointmentResponse]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "AppointmentResponse" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.AppointmentResponse]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesAppointmentResponse(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(AppointmentResponseUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesAppointmentResponse(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateArtifactAssessment(ctx context.Context, resource r5.ArtifactAssessment) (update.Result[r5.ArtifactAssessment], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.ArtifactAssessment]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for ArtifactAssessment")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.ArtifactAssessment]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ArtifactAssessment)
	if !ok {
		return update.Result[r5.ArtifactAssessment]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ArtifactAssessment" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.ArtifactAssessment]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesArtifactAssessment(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ArtifactAssessmentUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesArtifactAssessment(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateAuditEvent(ctx context.Context, resource r5.AuditEvent) (update.Result[r5.AuditEvent], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.AuditEvent]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for AuditEvent")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.AuditEvent]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.AuditEvent)
	if !ok {
		return update.Result[r5.AuditEvent]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "AuditEvent" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.AuditEvent]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesAuditEvent(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(AuditEventUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesAuditEvent(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateBasic(ctx context.Context, resource r5.Basic) (update.Result[r5.Basic], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Basic]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Basic")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Basic]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Basic)
	if !ok {
		return update.Result[r5.Basic]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Basic" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Basic]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesBasic(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(BasicUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesBasic(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateBinary(ctx context.Context, resource r5.Binary) (update.Result[r5.Binary], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Binary]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Binary")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Binary]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Binary)
	if !ok {
		return update.Result[r5.Binary]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Binary" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Binary]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesBinary(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(BinaryUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesBinary(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateBiologicallyDerivedProduct(ctx context.Context, resource r5.BiologicallyDerivedProduct) (update.Result[r5.BiologicallyDerivedProduct], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.BiologicallyDerivedProduct]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for BiologicallyDerivedProduct")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.BiologicallyDerivedProduct]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.BiologicallyDerivedProduct)
	if !ok {
		return update.Result[r5.BiologicallyDerivedProduct]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "BiologicallyDerivedProduct" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.BiologicallyDerivedProduct]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesBiologicallyDerivedProduct(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(BiologicallyDerivedProductUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesBiologicallyDerivedProduct(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateBiologicallyDerivedProductDispense(ctx context.Context, resource r5.BiologicallyDerivedProductDispense) (update.Result[r5.BiologicallyDerivedProductDispense], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.BiologicallyDerivedProductDispense]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for BiologicallyDerivedProductDispense")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.BiologicallyDerivedProductDispense]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.BiologicallyDerivedProductDispense)
	if !ok {
		return update.Result[r5.BiologicallyDerivedProductDispense]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "BiologicallyDerivedProductDispense" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.BiologicallyDerivedProductDispense]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesBiologicallyDerivedProductDispense(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(BiologicallyDerivedProductDispenseUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesBiologicallyDerivedProductDispense(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateBodyStructure(ctx context.Context, resource r5.BodyStructure) (update.Result[r5.BodyStructure], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.BodyStructure]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for BodyStructure")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.BodyStructure]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.BodyStructure)
	if !ok {
		return update.Result[r5.BodyStructure]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "BodyStructure" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.BodyStructure]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesBodyStructure(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(BodyStructureUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesBodyStructure(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateBundle(ctx context.Context, resource r5.Bundle) (update.Result[r5.Bundle], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Bundle]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Bundle")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Bundle]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Bundle)
	if !ok {
		return update.Result[r5.Bundle]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Bundle" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Bundle]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesBundle(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(BundleUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesBundle(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateCapabilityStatement(ctx context.Context, resource r5.CapabilityStatement) (update.Result[r5.CapabilityStatement], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.CapabilityStatement]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for CapabilityStatement")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.CapabilityStatement]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.CapabilityStatement)
	if !ok {
		return update.Result[r5.CapabilityStatement]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "CapabilityStatement" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.CapabilityStatement]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesCapabilityStatement(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(CapabilityStatementUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesCapabilityStatement(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateCarePlan(ctx context.Context, resource r5.CarePlan) (update.Result[r5.CarePlan], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.CarePlan]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for CarePlan")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.CarePlan]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.CarePlan)
	if !ok {
		return update.Result[r5.CarePlan]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "CarePlan" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.CarePlan]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesCarePlan(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(CarePlanUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesCarePlan(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateCareTeam(ctx context.Context, resource r5.CareTeam) (update.Result[r5.CareTeam], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.CareTeam]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for CareTeam")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.CareTeam]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.CareTeam)
	if !ok {
		return update.Result[r5.CareTeam]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "CareTeam" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.CareTeam]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesCareTeam(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(CareTeamUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesCareTeam(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateChargeItem(ctx context.Context, resource r5.ChargeItem) (update.Result[r5.ChargeItem], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.ChargeItem]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for ChargeItem")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.ChargeItem]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ChargeItem)
	if !ok {
		return update.Result[r5.ChargeItem]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ChargeItem" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.ChargeItem]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesChargeItem(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ChargeItemUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesChargeItem(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateChargeItemDefinition(ctx context.Context, resource r5.ChargeItemDefinition) (update.Result[r5.ChargeItemDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.ChargeItemDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for ChargeItemDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.ChargeItemDefinition]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ChargeItemDefinition)
	if !ok {
		return update.Result[r5.ChargeItemDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ChargeItemDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.ChargeItemDefinition]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesChargeItemDefinition(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ChargeItemDefinitionUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesChargeItemDefinition(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateCitation(ctx context.Context, resource r5.Citation) (update.Result[r5.Citation], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Citation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Citation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Citation]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Citation)
	if !ok {
		return update.Result[r5.Citation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Citation" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Citation]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesCitation(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(CitationUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesCitation(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateClaim(ctx context.Context, resource r5.Claim) (update.Result[r5.Claim], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Claim]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Claim")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Claim]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Claim)
	if !ok {
		return update.Result[r5.Claim]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Claim" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Claim]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesClaim(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ClaimUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesClaim(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateClaimResponse(ctx context.Context, resource r5.ClaimResponse) (update.Result[r5.ClaimResponse], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.ClaimResponse]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for ClaimResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.ClaimResponse]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ClaimResponse)
	if !ok {
		return update.Result[r5.ClaimResponse]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ClaimResponse" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.ClaimResponse]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesClaimResponse(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ClaimResponseUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesClaimResponse(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateClinicalImpression(ctx context.Context, resource r5.ClinicalImpression) (update.Result[r5.ClinicalImpression], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.ClinicalImpression]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for ClinicalImpression")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.ClinicalImpression]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ClinicalImpression)
	if !ok {
		return update.Result[r5.ClinicalImpression]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ClinicalImpression" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.ClinicalImpression]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesClinicalImpression(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ClinicalImpressionUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesClinicalImpression(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateClinicalUseDefinition(ctx context.Context, resource r5.ClinicalUseDefinition) (update.Result[r5.ClinicalUseDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.ClinicalUseDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for ClinicalUseDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.ClinicalUseDefinition]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ClinicalUseDefinition)
	if !ok {
		return update.Result[r5.ClinicalUseDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ClinicalUseDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.ClinicalUseDefinition]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesClinicalUseDefinition(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ClinicalUseDefinitionUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesClinicalUseDefinition(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateCodeSystem(ctx context.Context, resource r5.CodeSystem) (update.Result[r5.CodeSystem], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.CodeSystem]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for CodeSystem")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.CodeSystem]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.CodeSystem)
	if !ok {
		return update.Result[r5.CodeSystem]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "CodeSystem" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.CodeSystem]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesCodeSystem(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(CodeSystemUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesCodeSystem(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateCommunication(ctx context.Context, resource r5.Communication) (update.Result[r5.Communication], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Communication]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Communication")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Communication]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Communication)
	if !ok {
		return update.Result[r5.Communication]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Communication" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Communication]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesCommunication(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(CommunicationUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesCommunication(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateCommunicationRequest(ctx context.Context, resource r5.CommunicationRequest) (update.Result[r5.CommunicationRequest], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.CommunicationRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for CommunicationRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.CommunicationRequest]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.CommunicationRequest)
	if !ok {
		return update.Result[r5.CommunicationRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "CommunicationRequest" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.CommunicationRequest]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesCommunicationRequest(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(CommunicationRequestUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesCommunicationRequest(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateCompartmentDefinition(ctx context.Context, resource r5.CompartmentDefinition) (update.Result[r5.CompartmentDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.CompartmentDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for CompartmentDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.CompartmentDefinition]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.CompartmentDefinition)
	if !ok {
		return update.Result[r5.CompartmentDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "CompartmentDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.CompartmentDefinition]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesCompartmentDefinition(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(CompartmentDefinitionUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesCompartmentDefinition(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateComposition(ctx context.Context, resource r5.Composition) (update.Result[r5.Composition], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Composition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Composition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Composition]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Composition)
	if !ok {
		return update.Result[r5.Composition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Composition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Composition]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesComposition(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(CompositionUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesComposition(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateConceptMap(ctx context.Context, resource r5.ConceptMap) (update.Result[r5.ConceptMap], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.ConceptMap]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for ConceptMap")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.ConceptMap]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ConceptMap)
	if !ok {
		return update.Result[r5.ConceptMap]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ConceptMap" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.ConceptMap]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesConceptMap(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ConceptMapUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesConceptMap(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateCondition(ctx context.Context, resource r5.Condition) (update.Result[r5.Condition], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Condition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Condition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Condition]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Condition)
	if !ok {
		return update.Result[r5.Condition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Condition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Condition]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesCondition(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ConditionUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesCondition(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateConditionDefinition(ctx context.Context, resource r5.ConditionDefinition) (update.Result[r5.ConditionDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.ConditionDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for ConditionDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.ConditionDefinition]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ConditionDefinition)
	if !ok {
		return update.Result[r5.ConditionDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ConditionDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.ConditionDefinition]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesConditionDefinition(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ConditionDefinitionUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesConditionDefinition(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateConsent(ctx context.Context, resource r5.Consent) (update.Result[r5.Consent], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Consent]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Consent")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Consent]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Consent)
	if !ok {
		return update.Result[r5.Consent]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Consent" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Consent]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesConsent(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ConsentUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesConsent(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateContract(ctx context.Context, resource r5.Contract) (update.Result[r5.Contract], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Contract]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Contract")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Contract]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Contract)
	if !ok {
		return update.Result[r5.Contract]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Contract" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Contract]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesContract(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ContractUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesContract(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateCoverage(ctx context.Context, resource r5.Coverage) (update.Result[r5.Coverage], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Coverage]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Coverage")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Coverage]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Coverage)
	if !ok {
		return update.Result[r5.Coverage]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Coverage" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Coverage]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesCoverage(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(CoverageUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesCoverage(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateCoverageEligibilityRequest(ctx context.Context, resource r5.CoverageEligibilityRequest) (update.Result[r5.CoverageEligibilityRequest], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.CoverageEligibilityRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for CoverageEligibilityRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.CoverageEligibilityRequest]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.CoverageEligibilityRequest)
	if !ok {
		return update.Result[r5.CoverageEligibilityRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "CoverageEligibilityRequest" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.CoverageEligibilityRequest]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesCoverageEligibilityRequest(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(CoverageEligibilityRequestUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesCoverageEligibilityRequest(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateCoverageEligibilityResponse(ctx context.Context, resource r5.CoverageEligibilityResponse) (update.Result[r5.CoverageEligibilityResponse], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.CoverageEligibilityResponse]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for CoverageEligibilityResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.CoverageEligibilityResponse]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.CoverageEligibilityResponse)
	if !ok {
		return update.Result[r5.CoverageEligibilityResponse]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "CoverageEligibilityResponse" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.CoverageEligibilityResponse]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesCoverageEligibilityResponse(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(CoverageEligibilityResponseUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesCoverageEligibilityResponse(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateDetectedIssue(ctx context.Context, resource r5.DetectedIssue) (update.Result[r5.DetectedIssue], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.DetectedIssue]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for DetectedIssue")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.DetectedIssue]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.DetectedIssue)
	if !ok {
		return update.Result[r5.DetectedIssue]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "DetectedIssue" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.DetectedIssue]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesDetectedIssue(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(DetectedIssueUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesDetectedIssue(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateDevice(ctx context.Context, resource r5.Device) (update.Result[r5.Device], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Device]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Device")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Device]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Device)
	if !ok {
		return update.Result[r5.Device]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Device" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Device]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesDevice(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(DeviceUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesDevice(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateDeviceAssociation(ctx context.Context, resource r5.DeviceAssociation) (update.Result[r5.DeviceAssociation], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.DeviceAssociation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for DeviceAssociation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.DeviceAssociation]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.DeviceAssociation)
	if !ok {
		return update.Result[r5.DeviceAssociation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "DeviceAssociation" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.DeviceAssociation]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesDeviceAssociation(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(DeviceAssociationUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesDeviceAssociation(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateDeviceDefinition(ctx context.Context, resource r5.DeviceDefinition) (update.Result[r5.DeviceDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.DeviceDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for DeviceDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.DeviceDefinition]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.DeviceDefinition)
	if !ok {
		return update.Result[r5.DeviceDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "DeviceDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.DeviceDefinition]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesDeviceDefinition(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(DeviceDefinitionUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesDeviceDefinition(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateDeviceDispense(ctx context.Context, resource r5.DeviceDispense) (update.Result[r5.DeviceDispense], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.DeviceDispense]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for DeviceDispense")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.DeviceDispense]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.DeviceDispense)
	if !ok {
		return update.Result[r5.DeviceDispense]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "DeviceDispense" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.DeviceDispense]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesDeviceDispense(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(DeviceDispenseUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesDeviceDispense(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateDeviceMetric(ctx context.Context, resource r5.DeviceMetric) (update.Result[r5.DeviceMetric], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.DeviceMetric]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for DeviceMetric")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.DeviceMetric]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.DeviceMetric)
	if !ok {
		return update.Result[r5.DeviceMetric]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "DeviceMetric" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.DeviceMetric]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesDeviceMetric(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(DeviceMetricUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesDeviceMetric(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateDeviceRequest(ctx context.Context, resource r5.DeviceRequest) (update.Result[r5.DeviceRequest], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.DeviceRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for DeviceRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.DeviceRequest]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.DeviceRequest)
	if !ok {
		return update.Result[r5.DeviceRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "DeviceRequest" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.DeviceRequest]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesDeviceRequest(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(DeviceRequestUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesDeviceRequest(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateDeviceUsage(ctx context.Context, resource r5.DeviceUsage) (update.Result[r5.DeviceUsage], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.DeviceUsage]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for DeviceUsage")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.DeviceUsage]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.DeviceUsage)
	if !ok {
		return update.Result[r5.DeviceUsage]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "DeviceUsage" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.DeviceUsage]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesDeviceUsage(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(DeviceUsageUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesDeviceUsage(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateDiagnosticReport(ctx context.Context, resource r5.DiagnosticReport) (update.Result[r5.DiagnosticReport], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.DiagnosticReport]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for DiagnosticReport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.DiagnosticReport]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.DiagnosticReport)
	if !ok {
		return update.Result[r5.DiagnosticReport]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "DiagnosticReport" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.DiagnosticReport]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesDiagnosticReport(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(DiagnosticReportUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesDiagnosticReport(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateDocumentReference(ctx context.Context, resource r5.DocumentReference) (update.Result[r5.DocumentReference], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.DocumentReference]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for DocumentReference")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.DocumentReference]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.DocumentReference)
	if !ok {
		return update.Result[r5.DocumentReference]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "DocumentReference" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.DocumentReference]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesDocumentReference(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(DocumentReferenceUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesDocumentReference(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateEncounter(ctx context.Context, resource r5.Encounter) (update.Result[r5.Encounter], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Encounter]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Encounter")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Encounter]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Encounter)
	if !ok {
		return update.Result[r5.Encounter]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Encounter" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Encounter]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesEncounter(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(EncounterUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesEncounter(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateEncounterHistory(ctx context.Context, resource r5.EncounterHistory) (update.Result[r5.EncounterHistory], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.EncounterHistory]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for EncounterHistory")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.EncounterHistory]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.EncounterHistory)
	if !ok {
		return update.Result[r5.EncounterHistory]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "EncounterHistory" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.EncounterHistory]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesEncounterHistory(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(EncounterHistoryUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesEncounterHistory(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateEndpoint(ctx context.Context, resource r5.Endpoint) (update.Result[r5.Endpoint], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Endpoint]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Endpoint")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Endpoint]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Endpoint)
	if !ok {
		return update.Result[r5.Endpoint]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Endpoint" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Endpoint]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesEndpoint(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(EndpointUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesEndpoint(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateEnrollmentRequest(ctx context.Context, resource r5.EnrollmentRequest) (update.Result[r5.EnrollmentRequest], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.EnrollmentRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for EnrollmentRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.EnrollmentRequest]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.EnrollmentRequest)
	if !ok {
		return update.Result[r5.EnrollmentRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "EnrollmentRequest" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.EnrollmentRequest]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesEnrollmentRequest(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(EnrollmentRequestUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesEnrollmentRequest(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateEnrollmentResponse(ctx context.Context, resource r5.EnrollmentResponse) (update.Result[r5.EnrollmentResponse], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.EnrollmentResponse]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for EnrollmentResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.EnrollmentResponse]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.EnrollmentResponse)
	if !ok {
		return update.Result[r5.EnrollmentResponse]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "EnrollmentResponse" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.EnrollmentResponse]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesEnrollmentResponse(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(EnrollmentResponseUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesEnrollmentResponse(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateEpisodeOfCare(ctx context.Context, resource r5.EpisodeOfCare) (update.Result[r5.EpisodeOfCare], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.EpisodeOfCare]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for EpisodeOfCare")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.EpisodeOfCare]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.EpisodeOfCare)
	if !ok {
		return update.Result[r5.EpisodeOfCare]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "EpisodeOfCare" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.EpisodeOfCare]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesEpisodeOfCare(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(EpisodeOfCareUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesEpisodeOfCare(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateEventDefinition(ctx context.Context, resource r5.EventDefinition) (update.Result[r5.EventDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.EventDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for EventDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.EventDefinition]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.EventDefinition)
	if !ok {
		return update.Result[r5.EventDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "EventDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.EventDefinition]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesEventDefinition(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(EventDefinitionUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesEventDefinition(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateEvidence(ctx context.Context, resource r5.Evidence) (update.Result[r5.Evidence], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Evidence]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Evidence")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Evidence]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Evidence)
	if !ok {
		return update.Result[r5.Evidence]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Evidence" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Evidence]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesEvidence(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(EvidenceUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesEvidence(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateEvidenceReport(ctx context.Context, resource r5.EvidenceReport) (update.Result[r5.EvidenceReport], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.EvidenceReport]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for EvidenceReport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.EvidenceReport]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.EvidenceReport)
	if !ok {
		return update.Result[r5.EvidenceReport]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "EvidenceReport" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.EvidenceReport]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesEvidenceReport(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(EvidenceReportUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesEvidenceReport(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateEvidenceVariable(ctx context.Context, resource r5.EvidenceVariable) (update.Result[r5.EvidenceVariable], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.EvidenceVariable]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for EvidenceVariable")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.EvidenceVariable]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.EvidenceVariable)
	if !ok {
		return update.Result[r5.EvidenceVariable]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "EvidenceVariable" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.EvidenceVariable]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesEvidenceVariable(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(EvidenceVariableUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesEvidenceVariable(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateExampleScenario(ctx context.Context, resource r5.ExampleScenario) (update.Result[r5.ExampleScenario], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.ExampleScenario]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for ExampleScenario")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.ExampleScenario]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ExampleScenario)
	if !ok {
		return update.Result[r5.ExampleScenario]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ExampleScenario" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.ExampleScenario]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesExampleScenario(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ExampleScenarioUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesExampleScenario(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateExplanationOfBenefit(ctx context.Context, resource r5.ExplanationOfBenefit) (update.Result[r5.ExplanationOfBenefit], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.ExplanationOfBenefit]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for ExplanationOfBenefit")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.ExplanationOfBenefit]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ExplanationOfBenefit)
	if !ok {
		return update.Result[r5.ExplanationOfBenefit]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ExplanationOfBenefit" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.ExplanationOfBenefit]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesExplanationOfBenefit(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ExplanationOfBenefitUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesExplanationOfBenefit(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateFamilyMemberHistory(ctx context.Context, resource r5.FamilyMemberHistory) (update.Result[r5.FamilyMemberHistory], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.FamilyMemberHistory]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for FamilyMemberHistory")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.FamilyMemberHistory]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.FamilyMemberHistory)
	if !ok {
		return update.Result[r5.FamilyMemberHistory]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "FamilyMemberHistory" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.FamilyMemberHistory]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesFamilyMemberHistory(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(FamilyMemberHistoryUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesFamilyMemberHistory(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateFlag(ctx context.Context, resource r5.Flag) (update.Result[r5.Flag], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Flag]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Flag")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Flag]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Flag)
	if !ok {
		return update.Result[r5.Flag]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Flag" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Flag]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesFlag(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(FlagUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesFlag(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateFormularyItem(ctx context.Context, resource r5.FormularyItem) (update.Result[r5.FormularyItem], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.FormularyItem]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for FormularyItem")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.FormularyItem]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.FormularyItem)
	if !ok {
		return update.Result[r5.FormularyItem]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "FormularyItem" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.FormularyItem]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesFormularyItem(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(FormularyItemUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesFormularyItem(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateGenomicStudy(ctx context.Context, resource r5.GenomicStudy) (update.Result[r5.GenomicStudy], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.GenomicStudy]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for GenomicStudy")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.GenomicStudy]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.GenomicStudy)
	if !ok {
		return update.Result[r5.GenomicStudy]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "GenomicStudy" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.GenomicStudy]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesGenomicStudy(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(GenomicStudyUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesGenomicStudy(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateGoal(ctx context.Context, resource r5.Goal) (update.Result[r5.Goal], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Goal]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Goal")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Goal]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Goal)
	if !ok {
		return update.Result[r5.Goal]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Goal" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Goal]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesGoal(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(GoalUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesGoal(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateGraphDefinition(ctx context.Context, resource r5.GraphDefinition) (update.Result[r5.GraphDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.GraphDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for GraphDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.GraphDefinition]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.GraphDefinition)
	if !ok {
		return update.Result[r5.GraphDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "GraphDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.GraphDefinition]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesGraphDefinition(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(GraphDefinitionUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesGraphDefinition(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateGroup(ctx context.Context, resource r5.Group) (update.Result[r5.Group], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Group]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Group")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Group]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Group)
	if !ok {
		return update.Result[r5.Group]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Group" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Group]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesGroup(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(GroupUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesGroup(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateGuidanceResponse(ctx context.Context, resource r5.GuidanceResponse) (update.Result[r5.GuidanceResponse], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.GuidanceResponse]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for GuidanceResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.GuidanceResponse]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.GuidanceResponse)
	if !ok {
		return update.Result[r5.GuidanceResponse]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "GuidanceResponse" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.GuidanceResponse]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesGuidanceResponse(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(GuidanceResponseUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesGuidanceResponse(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateHealthcareService(ctx context.Context, resource r5.HealthcareService) (update.Result[r5.HealthcareService], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.HealthcareService]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for HealthcareService")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.HealthcareService]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.HealthcareService)
	if !ok {
		return update.Result[r5.HealthcareService]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "HealthcareService" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.HealthcareService]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesHealthcareService(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(HealthcareServiceUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesHealthcareService(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateImagingSelection(ctx context.Context, resource r5.ImagingSelection) (update.Result[r5.ImagingSelection], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.ImagingSelection]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for ImagingSelection")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.ImagingSelection]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ImagingSelection)
	if !ok {
		return update.Result[r5.ImagingSelection]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ImagingSelection" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.ImagingSelection]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesImagingSelection(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ImagingSelectionUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesImagingSelection(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateImagingStudy(ctx context.Context, resource r5.ImagingStudy) (update.Result[r5.ImagingStudy], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.ImagingStudy]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for ImagingStudy")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.ImagingStudy]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ImagingStudy)
	if !ok {
		return update.Result[r5.ImagingStudy]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ImagingStudy" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.ImagingStudy]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesImagingStudy(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ImagingStudyUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesImagingStudy(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateImmunization(ctx context.Context, resource r5.Immunization) (update.Result[r5.Immunization], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Immunization]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Immunization")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Immunization]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Immunization)
	if !ok {
		return update.Result[r5.Immunization]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Immunization" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Immunization]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesImmunization(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ImmunizationUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesImmunization(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateImmunizationEvaluation(ctx context.Context, resource r5.ImmunizationEvaluation) (update.Result[r5.ImmunizationEvaluation], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.ImmunizationEvaluation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for ImmunizationEvaluation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.ImmunizationEvaluation]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ImmunizationEvaluation)
	if !ok {
		return update.Result[r5.ImmunizationEvaluation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ImmunizationEvaluation" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.ImmunizationEvaluation]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesImmunizationEvaluation(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ImmunizationEvaluationUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesImmunizationEvaluation(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateImmunizationRecommendation(ctx context.Context, resource r5.ImmunizationRecommendation) (update.Result[r5.ImmunizationRecommendation], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.ImmunizationRecommendation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for ImmunizationRecommendation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.ImmunizationRecommendation]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ImmunizationRecommendation)
	if !ok {
		return update.Result[r5.ImmunizationRecommendation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ImmunizationRecommendation" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.ImmunizationRecommendation]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesImmunizationRecommendation(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ImmunizationRecommendationUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesImmunizationRecommendation(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateImplementationGuide(ctx context.Context, resource r5.ImplementationGuide) (update.Result[r5.ImplementationGuide], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.ImplementationGuide]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for ImplementationGuide")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.ImplementationGuide]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ImplementationGuide)
	if !ok {
		return update.Result[r5.ImplementationGuide]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ImplementationGuide" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.ImplementationGuide]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesImplementationGuide(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ImplementationGuideUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesImplementationGuide(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateIngredient(ctx context.Context, resource r5.Ingredient) (update.Result[r5.Ingredient], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Ingredient]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Ingredient")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Ingredient]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Ingredient)
	if !ok {
		return update.Result[r5.Ingredient]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Ingredient" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Ingredient]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesIngredient(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(IngredientUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesIngredient(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateInsurancePlan(ctx context.Context, resource r5.InsurancePlan) (update.Result[r5.InsurancePlan], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.InsurancePlan]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for InsurancePlan")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.InsurancePlan]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.InsurancePlan)
	if !ok {
		return update.Result[r5.InsurancePlan]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "InsurancePlan" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.InsurancePlan]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesInsurancePlan(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(InsurancePlanUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesInsurancePlan(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateInventoryItem(ctx context.Context, resource r5.InventoryItem) (update.Result[r5.InventoryItem], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.InventoryItem]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for InventoryItem")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.InventoryItem]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.InventoryItem)
	if !ok {
		return update.Result[r5.InventoryItem]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "InventoryItem" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.InventoryItem]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesInventoryItem(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(InventoryItemUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesInventoryItem(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateInventoryReport(ctx context.Context, resource r5.InventoryReport) (update.Result[r5.InventoryReport], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.InventoryReport]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for InventoryReport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.InventoryReport]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.InventoryReport)
	if !ok {
		return update.Result[r5.InventoryReport]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "InventoryReport" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.InventoryReport]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesInventoryReport(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(InventoryReportUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesInventoryReport(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateInvoice(ctx context.Context, resource r5.Invoice) (update.Result[r5.Invoice], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Invoice]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Invoice")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Invoice]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Invoice)
	if !ok {
		return update.Result[r5.Invoice]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Invoice" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Invoice]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesInvoice(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(InvoiceUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesInvoice(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateLibrary(ctx context.Context, resource r5.Library) (update.Result[r5.Library], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Library]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Library")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Library]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Library)
	if !ok {
		return update.Result[r5.Library]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Library" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Library]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesLibrary(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(LibraryUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesLibrary(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateLinkage(ctx context.Context, resource r5.Linkage) (update.Result[r5.Linkage], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Linkage]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Linkage")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Linkage]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Linkage)
	if !ok {
		return update.Result[r5.Linkage]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Linkage" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Linkage]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesLinkage(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(LinkageUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesLinkage(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateList(ctx context.Context, resource r5.List) (update.Result[r5.List], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.List]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for List")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.List]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.List)
	if !ok {
		return update.Result[r5.List]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "List" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.List]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesList(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ListUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesList(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateLocation(ctx context.Context, resource r5.Location) (update.Result[r5.Location], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Location]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Location")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Location]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Location)
	if !ok {
		return update.Result[r5.Location]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Location" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Location]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesLocation(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(LocationUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesLocation(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateManufacturedItemDefinition(ctx context.Context, resource r5.ManufacturedItemDefinition) (update.Result[r5.ManufacturedItemDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.ManufacturedItemDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for ManufacturedItemDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.ManufacturedItemDefinition]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ManufacturedItemDefinition)
	if !ok {
		return update.Result[r5.ManufacturedItemDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ManufacturedItemDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.ManufacturedItemDefinition]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesManufacturedItemDefinition(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ManufacturedItemDefinitionUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesManufacturedItemDefinition(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateMeasure(ctx context.Context, resource r5.Measure) (update.Result[r5.Measure], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Measure]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Measure")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Measure]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Measure)
	if !ok {
		return update.Result[r5.Measure]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Measure" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Measure]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesMeasure(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(MeasureUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesMeasure(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateMeasureReport(ctx context.Context, resource r5.MeasureReport) (update.Result[r5.MeasureReport], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.MeasureReport]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for MeasureReport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.MeasureReport]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MeasureReport)
	if !ok {
		return update.Result[r5.MeasureReport]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MeasureReport" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.MeasureReport]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesMeasureReport(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(MeasureReportUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesMeasureReport(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateMedication(ctx context.Context, resource r5.Medication) (update.Result[r5.Medication], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Medication]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Medication")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Medication]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Medication)
	if !ok {
		return update.Result[r5.Medication]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Medication" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Medication]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesMedication(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(MedicationUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesMedication(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateMedicationAdministration(ctx context.Context, resource r5.MedicationAdministration) (update.Result[r5.MedicationAdministration], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.MedicationAdministration]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for MedicationAdministration")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.MedicationAdministration]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MedicationAdministration)
	if !ok {
		return update.Result[r5.MedicationAdministration]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MedicationAdministration" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.MedicationAdministration]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesMedicationAdministration(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(MedicationAdministrationUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesMedicationAdministration(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateMedicationDispense(ctx context.Context, resource r5.MedicationDispense) (update.Result[r5.MedicationDispense], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.MedicationDispense]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for MedicationDispense")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.MedicationDispense]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MedicationDispense)
	if !ok {
		return update.Result[r5.MedicationDispense]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MedicationDispense" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.MedicationDispense]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesMedicationDispense(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(MedicationDispenseUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesMedicationDispense(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateMedicationKnowledge(ctx context.Context, resource r5.MedicationKnowledge) (update.Result[r5.MedicationKnowledge], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.MedicationKnowledge]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for MedicationKnowledge")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.MedicationKnowledge]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MedicationKnowledge)
	if !ok {
		return update.Result[r5.MedicationKnowledge]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MedicationKnowledge" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.MedicationKnowledge]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesMedicationKnowledge(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(MedicationKnowledgeUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesMedicationKnowledge(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateMedicationRequest(ctx context.Context, resource r5.MedicationRequest) (update.Result[r5.MedicationRequest], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.MedicationRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for MedicationRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.MedicationRequest]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MedicationRequest)
	if !ok {
		return update.Result[r5.MedicationRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MedicationRequest" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.MedicationRequest]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesMedicationRequest(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(MedicationRequestUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesMedicationRequest(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateMedicationStatement(ctx context.Context, resource r5.MedicationStatement) (update.Result[r5.MedicationStatement], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.MedicationStatement]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for MedicationStatement")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.MedicationStatement]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MedicationStatement)
	if !ok {
		return update.Result[r5.MedicationStatement]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MedicationStatement" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.MedicationStatement]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesMedicationStatement(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(MedicationStatementUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesMedicationStatement(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateMedicinalProductDefinition(ctx context.Context, resource r5.MedicinalProductDefinition) (update.Result[r5.MedicinalProductDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.MedicinalProductDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for MedicinalProductDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.MedicinalProductDefinition]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MedicinalProductDefinition)
	if !ok {
		return update.Result[r5.MedicinalProductDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MedicinalProductDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.MedicinalProductDefinition]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesMedicinalProductDefinition(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(MedicinalProductDefinitionUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesMedicinalProductDefinition(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateMessageDefinition(ctx context.Context, resource r5.MessageDefinition) (update.Result[r5.MessageDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.MessageDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for MessageDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.MessageDefinition]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MessageDefinition)
	if !ok {
		return update.Result[r5.MessageDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MessageDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.MessageDefinition]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesMessageDefinition(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(MessageDefinitionUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesMessageDefinition(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateMessageHeader(ctx context.Context, resource r5.MessageHeader) (update.Result[r5.MessageHeader], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.MessageHeader]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for MessageHeader")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.MessageHeader]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MessageHeader)
	if !ok {
		return update.Result[r5.MessageHeader]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MessageHeader" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.MessageHeader]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesMessageHeader(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(MessageHeaderUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesMessageHeader(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateMolecularSequence(ctx context.Context, resource r5.MolecularSequence) (update.Result[r5.MolecularSequence], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.MolecularSequence]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for MolecularSequence")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.MolecularSequence]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.MolecularSequence)
	if !ok {
		return update.Result[r5.MolecularSequence]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "MolecularSequence" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.MolecularSequence]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesMolecularSequence(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(MolecularSequenceUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesMolecularSequence(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateNamingSystem(ctx context.Context, resource r5.NamingSystem) (update.Result[r5.NamingSystem], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.NamingSystem]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for NamingSystem")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.NamingSystem]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.NamingSystem)
	if !ok {
		return update.Result[r5.NamingSystem]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "NamingSystem" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.NamingSystem]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesNamingSystem(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(NamingSystemUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesNamingSystem(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateNutritionIntake(ctx context.Context, resource r5.NutritionIntake) (update.Result[r5.NutritionIntake], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.NutritionIntake]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for NutritionIntake")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.NutritionIntake]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.NutritionIntake)
	if !ok {
		return update.Result[r5.NutritionIntake]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "NutritionIntake" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.NutritionIntake]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesNutritionIntake(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(NutritionIntakeUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesNutritionIntake(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateNutritionOrder(ctx context.Context, resource r5.NutritionOrder) (update.Result[r5.NutritionOrder], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.NutritionOrder]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for NutritionOrder")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.NutritionOrder]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.NutritionOrder)
	if !ok {
		return update.Result[r5.NutritionOrder]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "NutritionOrder" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.NutritionOrder]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesNutritionOrder(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(NutritionOrderUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesNutritionOrder(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateNutritionProduct(ctx context.Context, resource r5.NutritionProduct) (update.Result[r5.NutritionProduct], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.NutritionProduct]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for NutritionProduct")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.NutritionProduct]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.NutritionProduct)
	if !ok {
		return update.Result[r5.NutritionProduct]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "NutritionProduct" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.NutritionProduct]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesNutritionProduct(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(NutritionProductUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesNutritionProduct(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateObservation(ctx context.Context, resource r5.Observation) (update.Result[r5.Observation], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Observation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Observation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Observation]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Observation)
	if !ok {
		return update.Result[r5.Observation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Observation" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Observation]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesObservation(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ObservationUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesObservation(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateObservationDefinition(ctx context.Context, resource r5.ObservationDefinition) (update.Result[r5.ObservationDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.ObservationDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for ObservationDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.ObservationDefinition]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ObservationDefinition)
	if !ok {
		return update.Result[r5.ObservationDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ObservationDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.ObservationDefinition]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesObservationDefinition(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ObservationDefinitionUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesObservationDefinition(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateOperationDefinition(ctx context.Context, resource r5.OperationDefinition) (update.Result[r5.OperationDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.OperationDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for OperationDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.OperationDefinition]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.OperationDefinition)
	if !ok {
		return update.Result[r5.OperationDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "OperationDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.OperationDefinition]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesOperationDefinition(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(OperationDefinitionUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesOperationDefinition(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateOperationOutcome(ctx context.Context, resource r5.OperationOutcome) (update.Result[r5.OperationOutcome], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.OperationOutcome]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for OperationOutcome")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.OperationOutcome]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.OperationOutcome)
	if !ok {
		return update.Result[r5.OperationOutcome]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "OperationOutcome" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.OperationOutcome]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesOperationOutcome(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(OperationOutcomeUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesOperationOutcome(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateOrganization(ctx context.Context, resource r5.Organization) (update.Result[r5.Organization], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Organization]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Organization")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Organization]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Organization)
	if !ok {
		return update.Result[r5.Organization]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Organization" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Organization]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesOrganization(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(OrganizationUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesOrganization(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateOrganizationAffiliation(ctx context.Context, resource r5.OrganizationAffiliation) (update.Result[r5.OrganizationAffiliation], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.OrganizationAffiliation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for OrganizationAffiliation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.OrganizationAffiliation]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.OrganizationAffiliation)
	if !ok {
		return update.Result[r5.OrganizationAffiliation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "OrganizationAffiliation" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.OrganizationAffiliation]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesOrganizationAffiliation(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(OrganizationAffiliationUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesOrganizationAffiliation(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdatePackagedProductDefinition(ctx context.Context, resource r5.PackagedProductDefinition) (update.Result[r5.PackagedProductDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.PackagedProductDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for PackagedProductDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.PackagedProductDefinition]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.PackagedProductDefinition)
	if !ok {
		return update.Result[r5.PackagedProductDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "PackagedProductDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.PackagedProductDefinition]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesPackagedProductDefinition(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(PackagedProductDefinitionUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesPackagedProductDefinition(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateParameters(ctx context.Context, resource r5.Parameters) (update.Result[r5.Parameters], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Parameters]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Parameters")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Parameters]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Parameters)
	if !ok {
		return update.Result[r5.Parameters]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Parameters" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Parameters]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesParameters(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ParametersUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesParameters(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdatePatient(ctx context.Context, resource r5.Patient) (update.Result[r5.Patient], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Patient]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Patient")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Patient]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Patient)
	if !ok {
		return update.Result[r5.Patient]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Patient" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Patient]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesPatient(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(PatientUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesPatient(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdatePaymentNotice(ctx context.Context, resource r5.PaymentNotice) (update.Result[r5.PaymentNotice], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.PaymentNotice]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for PaymentNotice")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.PaymentNotice]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.PaymentNotice)
	if !ok {
		return update.Result[r5.PaymentNotice]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "PaymentNotice" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.PaymentNotice]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesPaymentNotice(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(PaymentNoticeUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesPaymentNotice(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdatePaymentReconciliation(ctx context.Context, resource r5.PaymentReconciliation) (update.Result[r5.PaymentReconciliation], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.PaymentReconciliation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for PaymentReconciliation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.PaymentReconciliation]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.PaymentReconciliation)
	if !ok {
		return update.Result[r5.PaymentReconciliation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "PaymentReconciliation" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.PaymentReconciliation]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesPaymentReconciliation(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(PaymentReconciliationUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesPaymentReconciliation(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdatePermission(ctx context.Context, resource r5.Permission) (update.Result[r5.Permission], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Permission]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Permission")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Permission]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Permission)
	if !ok {
		return update.Result[r5.Permission]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Permission" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Permission]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesPermission(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(PermissionUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesPermission(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdatePerson(ctx context.Context, resource r5.Person) (update.Result[r5.Person], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Person]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Person")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Person]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Person)
	if !ok {
		return update.Result[r5.Person]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Person" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Person]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesPerson(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(PersonUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesPerson(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdatePlanDefinition(ctx context.Context, resource r5.PlanDefinition) (update.Result[r5.PlanDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.PlanDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for PlanDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.PlanDefinition]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.PlanDefinition)
	if !ok {
		return update.Result[r5.PlanDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "PlanDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.PlanDefinition]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesPlanDefinition(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(PlanDefinitionUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesPlanDefinition(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdatePractitioner(ctx context.Context, resource r5.Practitioner) (update.Result[r5.Practitioner], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Practitioner]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Practitioner")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Practitioner]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Practitioner)
	if !ok {
		return update.Result[r5.Practitioner]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Practitioner" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Practitioner]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesPractitioner(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(PractitionerUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesPractitioner(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdatePractitionerRole(ctx context.Context, resource r5.PractitionerRole) (update.Result[r5.PractitionerRole], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.PractitionerRole]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for PractitionerRole")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.PractitionerRole]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.PractitionerRole)
	if !ok {
		return update.Result[r5.PractitionerRole]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "PractitionerRole" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.PractitionerRole]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesPractitionerRole(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(PractitionerRoleUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesPractitionerRole(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateProcedure(ctx context.Context, resource r5.Procedure) (update.Result[r5.Procedure], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Procedure]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Procedure")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Procedure]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Procedure)
	if !ok {
		return update.Result[r5.Procedure]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Procedure" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Procedure]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesProcedure(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ProcedureUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesProcedure(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateProvenance(ctx context.Context, resource r5.Provenance) (update.Result[r5.Provenance], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Provenance]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Provenance")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Provenance]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Provenance)
	if !ok {
		return update.Result[r5.Provenance]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Provenance" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Provenance]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesProvenance(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ProvenanceUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesProvenance(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateQuestionnaire(ctx context.Context, resource r5.Questionnaire) (update.Result[r5.Questionnaire], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Questionnaire]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Questionnaire")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Questionnaire]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Questionnaire)
	if !ok {
		return update.Result[r5.Questionnaire]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Questionnaire" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Questionnaire]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesQuestionnaire(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(QuestionnaireUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesQuestionnaire(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateQuestionnaireResponse(ctx context.Context, resource r5.QuestionnaireResponse) (update.Result[r5.QuestionnaireResponse], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.QuestionnaireResponse]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for QuestionnaireResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.QuestionnaireResponse]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.QuestionnaireResponse)
	if !ok {
		return update.Result[r5.QuestionnaireResponse]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "QuestionnaireResponse" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.QuestionnaireResponse]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesQuestionnaireResponse(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(QuestionnaireResponseUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesQuestionnaireResponse(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateRegulatedAuthorization(ctx context.Context, resource r5.RegulatedAuthorization) (update.Result[r5.RegulatedAuthorization], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.RegulatedAuthorization]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for RegulatedAuthorization")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.RegulatedAuthorization]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.RegulatedAuthorization)
	if !ok {
		return update.Result[r5.RegulatedAuthorization]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "RegulatedAuthorization" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.RegulatedAuthorization]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesRegulatedAuthorization(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(RegulatedAuthorizationUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesRegulatedAuthorization(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateRelatedPerson(ctx context.Context, resource r5.RelatedPerson) (update.Result[r5.RelatedPerson], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.RelatedPerson]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for RelatedPerson")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.RelatedPerson]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.RelatedPerson)
	if !ok {
		return update.Result[r5.RelatedPerson]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "RelatedPerson" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.RelatedPerson]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesRelatedPerson(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(RelatedPersonUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesRelatedPerson(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateRequestOrchestration(ctx context.Context, resource r5.RequestOrchestration) (update.Result[r5.RequestOrchestration], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.RequestOrchestration]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for RequestOrchestration")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.RequestOrchestration]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.RequestOrchestration)
	if !ok {
		return update.Result[r5.RequestOrchestration]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "RequestOrchestration" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.RequestOrchestration]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesRequestOrchestration(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(RequestOrchestrationUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesRequestOrchestration(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateRequirements(ctx context.Context, resource r5.Requirements) (update.Result[r5.Requirements], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Requirements]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Requirements")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Requirements]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Requirements)
	if !ok {
		return update.Result[r5.Requirements]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Requirements" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Requirements]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesRequirements(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(RequirementsUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesRequirements(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateResearchStudy(ctx context.Context, resource r5.ResearchStudy) (update.Result[r5.ResearchStudy], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.ResearchStudy]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for ResearchStudy")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.ResearchStudy]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ResearchStudy)
	if !ok {
		return update.Result[r5.ResearchStudy]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ResearchStudy" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.ResearchStudy]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesResearchStudy(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ResearchStudyUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesResearchStudy(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateResearchSubject(ctx context.Context, resource r5.ResearchSubject) (update.Result[r5.ResearchSubject], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.ResearchSubject]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for ResearchSubject")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.ResearchSubject]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ResearchSubject)
	if !ok {
		return update.Result[r5.ResearchSubject]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ResearchSubject" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.ResearchSubject]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesResearchSubject(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ResearchSubjectUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesResearchSubject(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateRiskAssessment(ctx context.Context, resource r5.RiskAssessment) (update.Result[r5.RiskAssessment], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.RiskAssessment]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for RiskAssessment")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.RiskAssessment]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.RiskAssessment)
	if !ok {
		return update.Result[r5.RiskAssessment]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "RiskAssessment" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.RiskAssessment]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesRiskAssessment(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(RiskAssessmentUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesRiskAssessment(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateSchedule(ctx context.Context, resource r5.Schedule) (update.Result[r5.Schedule], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Schedule]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Schedule")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Schedule]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Schedule)
	if !ok {
		return update.Result[r5.Schedule]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Schedule" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Schedule]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesSchedule(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ScheduleUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesSchedule(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateSearchParameter(ctx context.Context, resource r5.SearchParameter) (update.Result[r5.SearchParameter], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.SearchParameter]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for SearchParameter")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.SearchParameter]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SearchParameter)
	if !ok {
		return update.Result[r5.SearchParameter]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SearchParameter" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.SearchParameter]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesSearchParameter(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(SearchParameterUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesSearchParameter(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateServiceRequest(ctx context.Context, resource r5.ServiceRequest) (update.Result[r5.ServiceRequest], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.ServiceRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for ServiceRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.ServiceRequest]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ServiceRequest)
	if !ok {
		return update.Result[r5.ServiceRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ServiceRequest" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.ServiceRequest]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesServiceRequest(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ServiceRequestUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesServiceRequest(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateSlot(ctx context.Context, resource r5.Slot) (update.Result[r5.Slot], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Slot]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Slot")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Slot]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Slot)
	if !ok {
		return update.Result[r5.Slot]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Slot" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Slot]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesSlot(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(SlotUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesSlot(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateSpecimen(ctx context.Context, resource r5.Specimen) (update.Result[r5.Specimen], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Specimen]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Specimen")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Specimen]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Specimen)
	if !ok {
		return update.Result[r5.Specimen]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Specimen" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Specimen]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesSpecimen(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(SpecimenUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesSpecimen(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateSpecimenDefinition(ctx context.Context, resource r5.SpecimenDefinition) (update.Result[r5.SpecimenDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.SpecimenDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for SpecimenDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.SpecimenDefinition]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SpecimenDefinition)
	if !ok {
		return update.Result[r5.SpecimenDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SpecimenDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.SpecimenDefinition]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesSpecimenDefinition(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(SpecimenDefinitionUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesSpecimenDefinition(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateStructureDefinition(ctx context.Context, resource r5.StructureDefinition) (update.Result[r5.StructureDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.StructureDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for StructureDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.StructureDefinition]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.StructureDefinition)
	if !ok {
		return update.Result[r5.StructureDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "StructureDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.StructureDefinition]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesStructureDefinition(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(StructureDefinitionUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesStructureDefinition(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateStructureMap(ctx context.Context, resource r5.StructureMap) (update.Result[r5.StructureMap], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.StructureMap]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for StructureMap")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.StructureMap]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.StructureMap)
	if !ok {
		return update.Result[r5.StructureMap]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "StructureMap" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.StructureMap]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesStructureMap(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(StructureMapUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesStructureMap(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateSubscription(ctx context.Context, resource r5.Subscription) (update.Result[r5.Subscription], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Subscription]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Subscription")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Subscription]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Subscription)
	if !ok {
		return update.Result[r5.Subscription]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Subscription" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Subscription]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesSubscription(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(SubscriptionUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesSubscription(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateSubscriptionStatus(ctx context.Context, resource r5.SubscriptionStatus) (update.Result[r5.SubscriptionStatus], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.SubscriptionStatus]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for SubscriptionStatus")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.SubscriptionStatus]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SubscriptionStatus)
	if !ok {
		return update.Result[r5.SubscriptionStatus]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SubscriptionStatus" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.SubscriptionStatus]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesSubscriptionStatus(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(SubscriptionStatusUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesSubscriptionStatus(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateSubscriptionTopic(ctx context.Context, resource r5.SubscriptionTopic) (update.Result[r5.SubscriptionTopic], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.SubscriptionTopic]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for SubscriptionTopic")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.SubscriptionTopic]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SubscriptionTopic)
	if !ok {
		return update.Result[r5.SubscriptionTopic]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SubscriptionTopic" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.SubscriptionTopic]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesSubscriptionTopic(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(SubscriptionTopicUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesSubscriptionTopic(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateSubstance(ctx context.Context, resource r5.Substance) (update.Result[r5.Substance], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Substance]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Substance")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Substance]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Substance)
	if !ok {
		return update.Result[r5.Substance]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Substance" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Substance]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesSubstance(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(SubstanceUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesSubstance(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateSubstanceDefinition(ctx context.Context, resource r5.SubstanceDefinition) (update.Result[r5.SubstanceDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.SubstanceDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for SubstanceDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.SubstanceDefinition]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SubstanceDefinition)
	if !ok {
		return update.Result[r5.SubstanceDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SubstanceDefinition" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.SubstanceDefinition]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesSubstanceDefinition(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(SubstanceDefinitionUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesSubstanceDefinition(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateSubstanceNucleicAcid(ctx context.Context, resource r5.SubstanceNucleicAcid) (update.Result[r5.SubstanceNucleicAcid], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.SubstanceNucleicAcid]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for SubstanceNucleicAcid")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.SubstanceNucleicAcid]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SubstanceNucleicAcid)
	if !ok {
		return update.Result[r5.SubstanceNucleicAcid]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SubstanceNucleicAcid" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.SubstanceNucleicAcid]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesSubstanceNucleicAcid(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(SubstanceNucleicAcidUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesSubstanceNucleicAcid(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateSubstancePolymer(ctx context.Context, resource r5.SubstancePolymer) (update.Result[r5.SubstancePolymer], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.SubstancePolymer]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for SubstancePolymer")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.SubstancePolymer]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SubstancePolymer)
	if !ok {
		return update.Result[r5.SubstancePolymer]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SubstancePolymer" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.SubstancePolymer]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesSubstancePolymer(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(SubstancePolymerUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesSubstancePolymer(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateSubstanceProtein(ctx context.Context, resource r5.SubstanceProtein) (update.Result[r5.SubstanceProtein], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.SubstanceProtein]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for SubstanceProtein")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.SubstanceProtein]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SubstanceProtein)
	if !ok {
		return update.Result[r5.SubstanceProtein]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SubstanceProtein" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.SubstanceProtein]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesSubstanceProtein(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(SubstanceProteinUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesSubstanceProtein(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateSubstanceReferenceInformation(ctx context.Context, resource r5.SubstanceReferenceInformation) (update.Result[r5.SubstanceReferenceInformation], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.SubstanceReferenceInformation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for SubstanceReferenceInformation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.SubstanceReferenceInformation]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SubstanceReferenceInformation)
	if !ok {
		return update.Result[r5.SubstanceReferenceInformation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SubstanceReferenceInformation" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.SubstanceReferenceInformation]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesSubstanceReferenceInformation(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(SubstanceReferenceInformationUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesSubstanceReferenceInformation(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateSubstanceSourceMaterial(ctx context.Context, resource r5.SubstanceSourceMaterial) (update.Result[r5.SubstanceSourceMaterial], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.SubstanceSourceMaterial]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for SubstanceSourceMaterial")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.SubstanceSourceMaterial]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SubstanceSourceMaterial)
	if !ok {
		return update.Result[r5.SubstanceSourceMaterial]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SubstanceSourceMaterial" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.SubstanceSourceMaterial]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesSubstanceSourceMaterial(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(SubstanceSourceMaterialUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesSubstanceSourceMaterial(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateSupplyDelivery(ctx context.Context, resource r5.SupplyDelivery) (update.Result[r5.SupplyDelivery], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.SupplyDelivery]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for SupplyDelivery")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.SupplyDelivery]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SupplyDelivery)
	if !ok {
		return update.Result[r5.SupplyDelivery]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SupplyDelivery" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.SupplyDelivery]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesSupplyDelivery(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(SupplyDeliveryUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesSupplyDelivery(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateSupplyRequest(ctx context.Context, resource r5.SupplyRequest) (update.Result[r5.SupplyRequest], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.SupplyRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for SupplyRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.SupplyRequest]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.SupplyRequest)
	if !ok {
		return update.Result[r5.SupplyRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "SupplyRequest" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.SupplyRequest]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesSupplyRequest(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(SupplyRequestUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesSupplyRequest(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateTask(ctx context.Context, resource r5.Task) (update.Result[r5.Task], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Task]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Task")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Task]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Task)
	if !ok {
		return update.Result[r5.Task]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Task" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Task]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesTask(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(TaskUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesTask(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateTerminologyCapabilities(ctx context.Context, resource r5.TerminologyCapabilities) (update.Result[r5.TerminologyCapabilities], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.TerminologyCapabilities]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for TerminologyCapabilities")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.TerminologyCapabilities]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.TerminologyCapabilities)
	if !ok {
		return update.Result[r5.TerminologyCapabilities]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "TerminologyCapabilities" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.TerminologyCapabilities]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesTerminologyCapabilities(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(TerminologyCapabilitiesUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesTerminologyCapabilities(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateTestPlan(ctx context.Context, resource r5.TestPlan) (update.Result[r5.TestPlan], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.TestPlan]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for TestPlan")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.TestPlan]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.TestPlan)
	if !ok {
		return update.Result[r5.TestPlan]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "TestPlan" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.TestPlan]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesTestPlan(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(TestPlanUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesTestPlan(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateTestReport(ctx context.Context, resource r5.TestReport) (update.Result[r5.TestReport], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.TestReport]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for TestReport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.TestReport]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.TestReport)
	if !ok {
		return update.Result[r5.TestReport]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "TestReport" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.TestReport]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesTestReport(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(TestReportUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesTestReport(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateTestScript(ctx context.Context, resource r5.TestScript) (update.Result[r5.TestScript], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.TestScript]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for TestScript")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.TestScript]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.TestScript)
	if !ok {
		return update.Result[r5.TestScript]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "TestScript" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.TestScript]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesTestScript(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(TestScriptUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesTestScript(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateTransport(ctx context.Context, resource r5.Transport) (update.Result[r5.Transport], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.Transport]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for Transport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.Transport]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.Transport)
	if !ok {
		return update.Result[r5.Transport]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "Transport" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.Transport]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesTransport(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(TransportUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesTransport(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateValueSet(ctx context.Context, resource r5.ValueSet) (update.Result[r5.ValueSet], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.ValueSet]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for ValueSet")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.ValueSet]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.ValueSet)
	if !ok {
		return update.Result[r5.ValueSet]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "ValueSet" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.ValueSet]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesValueSet(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(ValueSetUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesValueSet(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateVerificationResult(ctx context.Context, resource r5.VerificationResult) (update.Result[r5.VerificationResult], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.VerificationResult]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for VerificationResult")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.VerificationResult]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.VerificationResult)
	if !ok {
		return update.Result[r5.VerificationResult]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "VerificationResult" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.VerificationResult]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesVerificationResult(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(VerificationResultUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesVerificationResult(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) UpdateVisionPrescription(ctx context.Context, resource r5.VisionPrescription) (update.Result[r5.VisionPrescription], error) {
	g, ok := w.Generic.(capabilities.GenericUpdate)
	if !ok {
		return update.Result[r5.VisionPrescription]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Update not implemented for VisionPrescription")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Update(ctx, resource)
	if err != nil {
		return update.Result[r5.VisionPrescription]{}, err
	}
	v := result.Resource
	contained, ok := v.(r5.ContainedResource)
	if ok {
		v = contained.Resource
	}
	r, ok := v.(r5.VisionPrescription)
	if !ok {
		return update.Result[r5.VisionPrescription]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("processing")},
			Diagnostics: &r5.String{Value: ptr.To("expected " + "VisionPrescription" + " but got " + v.ResourceType())},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return update.Result[r5.VisionPrescription]{

		Created:  result.Created,
		Resource: r,
	}, nil
}
func (w Concrete) UpdateCapabilitiesVisionPrescription(ctx context.Context) (update.Capabilities, error) {
	updateImpl, ok := w.Generic.(VisionPrescriptionUpdateCapabilities)
	if ok {
		return updateImpl.UpdateCapabilitiesVisionPrescription(ctx)
	}
	return update.Capabilities{}, nil
}
func (w Concrete) DeleteAccount(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Account")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Account", id)
}
func (w Concrete) DeleteActivityDefinition(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for ActivityDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "ActivityDefinition", id)
}
func (w Concrete) DeleteActorDefinition(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for ActorDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "ActorDefinition", id)
}
func (w Concrete) DeleteAdministrableProductDefinition(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for AdministrableProductDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "AdministrableProductDefinition", id)
}
func (w Concrete) DeleteAdverseEvent(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for AdverseEvent")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "AdverseEvent", id)
}
func (w Concrete) DeleteAllergyIntolerance(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for AllergyIntolerance")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "AllergyIntolerance", id)
}
func (w Concrete) DeleteAppointment(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Appointment")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Appointment", id)
}
func (w Concrete) DeleteAppointmentResponse(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for AppointmentResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "AppointmentResponse", id)
}
func (w Concrete) DeleteArtifactAssessment(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for ArtifactAssessment")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "ArtifactAssessment", id)
}
func (w Concrete) DeleteAuditEvent(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for AuditEvent")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "AuditEvent", id)
}
func (w Concrete) DeleteBasic(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Basic")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Basic", id)
}
func (w Concrete) DeleteBinary(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Binary")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Binary", id)
}
func (w Concrete) DeleteBiologicallyDerivedProduct(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for BiologicallyDerivedProduct")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "BiologicallyDerivedProduct", id)
}
func (w Concrete) DeleteBiologicallyDerivedProductDispense(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for BiologicallyDerivedProductDispense")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "BiologicallyDerivedProductDispense", id)
}
func (w Concrete) DeleteBodyStructure(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for BodyStructure")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "BodyStructure", id)
}
func (w Concrete) DeleteBundle(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Bundle")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Bundle", id)
}
func (w Concrete) DeleteCapabilityStatement(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for CapabilityStatement")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "CapabilityStatement", id)
}
func (w Concrete) DeleteCarePlan(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for CarePlan")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "CarePlan", id)
}
func (w Concrete) DeleteCareTeam(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for CareTeam")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "CareTeam", id)
}
func (w Concrete) DeleteChargeItem(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for ChargeItem")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "ChargeItem", id)
}
func (w Concrete) DeleteChargeItemDefinition(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for ChargeItemDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "ChargeItemDefinition", id)
}
func (w Concrete) DeleteCitation(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Citation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Citation", id)
}
func (w Concrete) DeleteClaim(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Claim")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Claim", id)
}
func (w Concrete) DeleteClaimResponse(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for ClaimResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "ClaimResponse", id)
}
func (w Concrete) DeleteClinicalImpression(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for ClinicalImpression")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "ClinicalImpression", id)
}
func (w Concrete) DeleteClinicalUseDefinition(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for ClinicalUseDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "ClinicalUseDefinition", id)
}
func (w Concrete) DeleteCodeSystem(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for CodeSystem")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "CodeSystem", id)
}
func (w Concrete) DeleteCommunication(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Communication")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Communication", id)
}
func (w Concrete) DeleteCommunicationRequest(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for CommunicationRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "CommunicationRequest", id)
}
func (w Concrete) DeleteCompartmentDefinition(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for CompartmentDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "CompartmentDefinition", id)
}
func (w Concrete) DeleteComposition(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Composition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Composition", id)
}
func (w Concrete) DeleteConceptMap(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for ConceptMap")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "ConceptMap", id)
}
func (w Concrete) DeleteCondition(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Condition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Condition", id)
}
func (w Concrete) DeleteConditionDefinition(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for ConditionDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "ConditionDefinition", id)
}
func (w Concrete) DeleteConsent(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Consent")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Consent", id)
}
func (w Concrete) DeleteContract(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Contract")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Contract", id)
}
func (w Concrete) DeleteCoverage(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Coverage")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Coverage", id)
}
func (w Concrete) DeleteCoverageEligibilityRequest(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for CoverageEligibilityRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "CoverageEligibilityRequest", id)
}
func (w Concrete) DeleteCoverageEligibilityResponse(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for CoverageEligibilityResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "CoverageEligibilityResponse", id)
}
func (w Concrete) DeleteDetectedIssue(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for DetectedIssue")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "DetectedIssue", id)
}
func (w Concrete) DeleteDevice(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Device")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Device", id)
}
func (w Concrete) DeleteDeviceAssociation(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for DeviceAssociation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "DeviceAssociation", id)
}
func (w Concrete) DeleteDeviceDefinition(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for DeviceDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "DeviceDefinition", id)
}
func (w Concrete) DeleteDeviceDispense(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for DeviceDispense")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "DeviceDispense", id)
}
func (w Concrete) DeleteDeviceMetric(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for DeviceMetric")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "DeviceMetric", id)
}
func (w Concrete) DeleteDeviceRequest(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for DeviceRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "DeviceRequest", id)
}
func (w Concrete) DeleteDeviceUsage(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for DeviceUsage")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "DeviceUsage", id)
}
func (w Concrete) DeleteDiagnosticReport(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for DiagnosticReport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "DiagnosticReport", id)
}
func (w Concrete) DeleteDocumentReference(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for DocumentReference")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "DocumentReference", id)
}
func (w Concrete) DeleteEncounter(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Encounter")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Encounter", id)
}
func (w Concrete) DeleteEncounterHistory(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for EncounterHistory")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "EncounterHistory", id)
}
func (w Concrete) DeleteEndpoint(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Endpoint")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Endpoint", id)
}
func (w Concrete) DeleteEnrollmentRequest(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for EnrollmentRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "EnrollmentRequest", id)
}
func (w Concrete) DeleteEnrollmentResponse(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for EnrollmentResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "EnrollmentResponse", id)
}
func (w Concrete) DeleteEpisodeOfCare(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for EpisodeOfCare")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "EpisodeOfCare", id)
}
func (w Concrete) DeleteEventDefinition(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for EventDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "EventDefinition", id)
}
func (w Concrete) DeleteEvidence(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Evidence")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Evidence", id)
}
func (w Concrete) DeleteEvidenceReport(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for EvidenceReport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "EvidenceReport", id)
}
func (w Concrete) DeleteEvidenceVariable(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for EvidenceVariable")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "EvidenceVariable", id)
}
func (w Concrete) DeleteExampleScenario(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for ExampleScenario")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "ExampleScenario", id)
}
func (w Concrete) DeleteExplanationOfBenefit(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for ExplanationOfBenefit")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "ExplanationOfBenefit", id)
}
func (w Concrete) DeleteFamilyMemberHistory(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for FamilyMemberHistory")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "FamilyMemberHistory", id)
}
func (w Concrete) DeleteFlag(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Flag")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Flag", id)
}
func (w Concrete) DeleteFormularyItem(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for FormularyItem")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "FormularyItem", id)
}
func (w Concrete) DeleteGenomicStudy(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for GenomicStudy")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "GenomicStudy", id)
}
func (w Concrete) DeleteGoal(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Goal")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Goal", id)
}
func (w Concrete) DeleteGraphDefinition(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for GraphDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "GraphDefinition", id)
}
func (w Concrete) DeleteGroup(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Group")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Group", id)
}
func (w Concrete) DeleteGuidanceResponse(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for GuidanceResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "GuidanceResponse", id)
}
func (w Concrete) DeleteHealthcareService(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for HealthcareService")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "HealthcareService", id)
}
func (w Concrete) DeleteImagingSelection(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for ImagingSelection")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "ImagingSelection", id)
}
func (w Concrete) DeleteImagingStudy(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for ImagingStudy")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "ImagingStudy", id)
}
func (w Concrete) DeleteImmunization(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Immunization")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Immunization", id)
}
func (w Concrete) DeleteImmunizationEvaluation(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for ImmunizationEvaluation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "ImmunizationEvaluation", id)
}
func (w Concrete) DeleteImmunizationRecommendation(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for ImmunizationRecommendation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "ImmunizationRecommendation", id)
}
func (w Concrete) DeleteImplementationGuide(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for ImplementationGuide")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "ImplementationGuide", id)
}
func (w Concrete) DeleteIngredient(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Ingredient")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Ingredient", id)
}
func (w Concrete) DeleteInsurancePlan(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for InsurancePlan")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "InsurancePlan", id)
}
func (w Concrete) DeleteInventoryItem(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for InventoryItem")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "InventoryItem", id)
}
func (w Concrete) DeleteInventoryReport(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for InventoryReport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "InventoryReport", id)
}
func (w Concrete) DeleteInvoice(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Invoice")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Invoice", id)
}
func (w Concrete) DeleteLibrary(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Library")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Library", id)
}
func (w Concrete) DeleteLinkage(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Linkage")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Linkage", id)
}
func (w Concrete) DeleteList(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for List")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "List", id)
}
func (w Concrete) DeleteLocation(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Location")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Location", id)
}
func (w Concrete) DeleteManufacturedItemDefinition(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for ManufacturedItemDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "ManufacturedItemDefinition", id)
}
func (w Concrete) DeleteMeasure(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Measure")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Measure", id)
}
func (w Concrete) DeleteMeasureReport(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for MeasureReport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "MeasureReport", id)
}
func (w Concrete) DeleteMedication(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Medication")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Medication", id)
}
func (w Concrete) DeleteMedicationAdministration(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for MedicationAdministration")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "MedicationAdministration", id)
}
func (w Concrete) DeleteMedicationDispense(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for MedicationDispense")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "MedicationDispense", id)
}
func (w Concrete) DeleteMedicationKnowledge(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for MedicationKnowledge")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "MedicationKnowledge", id)
}
func (w Concrete) DeleteMedicationRequest(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for MedicationRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "MedicationRequest", id)
}
func (w Concrete) DeleteMedicationStatement(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for MedicationStatement")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "MedicationStatement", id)
}
func (w Concrete) DeleteMedicinalProductDefinition(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for MedicinalProductDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "MedicinalProductDefinition", id)
}
func (w Concrete) DeleteMessageDefinition(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for MessageDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "MessageDefinition", id)
}
func (w Concrete) DeleteMessageHeader(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for MessageHeader")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "MessageHeader", id)
}
func (w Concrete) DeleteMolecularSequence(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for MolecularSequence")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "MolecularSequence", id)
}
func (w Concrete) DeleteNamingSystem(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for NamingSystem")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "NamingSystem", id)
}
func (w Concrete) DeleteNutritionIntake(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for NutritionIntake")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "NutritionIntake", id)
}
func (w Concrete) DeleteNutritionOrder(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for NutritionOrder")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "NutritionOrder", id)
}
func (w Concrete) DeleteNutritionProduct(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for NutritionProduct")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "NutritionProduct", id)
}
func (w Concrete) DeleteObservation(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Observation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Observation", id)
}
func (w Concrete) DeleteObservationDefinition(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for ObservationDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "ObservationDefinition", id)
}
func (w Concrete) DeleteOperationDefinition(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for OperationDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "OperationDefinition", id)
}
func (w Concrete) DeleteOperationOutcome(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for OperationOutcome")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "OperationOutcome", id)
}
func (w Concrete) DeleteOrganization(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Organization")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Organization", id)
}
func (w Concrete) DeleteOrganizationAffiliation(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for OrganizationAffiliation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "OrganizationAffiliation", id)
}
func (w Concrete) DeletePackagedProductDefinition(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for PackagedProductDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "PackagedProductDefinition", id)
}
func (w Concrete) DeleteParameters(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Parameters")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Parameters", id)
}
func (w Concrete) DeletePatient(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Patient")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Patient", id)
}
func (w Concrete) DeletePaymentNotice(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for PaymentNotice")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "PaymentNotice", id)
}
func (w Concrete) DeletePaymentReconciliation(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for PaymentReconciliation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "PaymentReconciliation", id)
}
func (w Concrete) DeletePermission(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Permission")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Permission", id)
}
func (w Concrete) DeletePerson(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Person")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Person", id)
}
func (w Concrete) DeletePlanDefinition(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for PlanDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "PlanDefinition", id)
}
func (w Concrete) DeletePractitioner(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Practitioner")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Practitioner", id)
}
func (w Concrete) DeletePractitionerRole(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for PractitionerRole")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "PractitionerRole", id)
}
func (w Concrete) DeleteProcedure(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Procedure")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Procedure", id)
}
func (w Concrete) DeleteProvenance(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Provenance")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Provenance", id)
}
func (w Concrete) DeleteQuestionnaire(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Questionnaire")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Questionnaire", id)
}
func (w Concrete) DeleteQuestionnaireResponse(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for QuestionnaireResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "QuestionnaireResponse", id)
}
func (w Concrete) DeleteRegulatedAuthorization(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for RegulatedAuthorization")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "RegulatedAuthorization", id)
}
func (w Concrete) DeleteRelatedPerson(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for RelatedPerson")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "RelatedPerson", id)
}
func (w Concrete) DeleteRequestOrchestration(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for RequestOrchestration")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "RequestOrchestration", id)
}
func (w Concrete) DeleteRequirements(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Requirements")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Requirements", id)
}
func (w Concrete) DeleteResearchStudy(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for ResearchStudy")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "ResearchStudy", id)
}
func (w Concrete) DeleteResearchSubject(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for ResearchSubject")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "ResearchSubject", id)
}
func (w Concrete) DeleteRiskAssessment(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for RiskAssessment")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "RiskAssessment", id)
}
func (w Concrete) DeleteSchedule(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Schedule")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Schedule", id)
}
func (w Concrete) DeleteSearchParameter(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for SearchParameter")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "SearchParameter", id)
}
func (w Concrete) DeleteServiceRequest(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for ServiceRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "ServiceRequest", id)
}
func (w Concrete) DeleteSlot(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Slot")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Slot", id)
}
func (w Concrete) DeleteSpecimen(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Specimen")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Specimen", id)
}
func (w Concrete) DeleteSpecimenDefinition(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for SpecimenDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "SpecimenDefinition", id)
}
func (w Concrete) DeleteStructureDefinition(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for StructureDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "StructureDefinition", id)
}
func (w Concrete) DeleteStructureMap(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for StructureMap")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "StructureMap", id)
}
func (w Concrete) DeleteSubscription(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Subscription")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Subscription", id)
}
func (w Concrete) DeleteSubscriptionStatus(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for SubscriptionStatus")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "SubscriptionStatus", id)
}
func (w Concrete) DeleteSubscriptionTopic(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for SubscriptionTopic")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "SubscriptionTopic", id)
}
func (w Concrete) DeleteSubstance(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Substance")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Substance", id)
}
func (w Concrete) DeleteSubstanceDefinition(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for SubstanceDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "SubstanceDefinition", id)
}
func (w Concrete) DeleteSubstanceNucleicAcid(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for SubstanceNucleicAcid")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "SubstanceNucleicAcid", id)
}
func (w Concrete) DeleteSubstancePolymer(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for SubstancePolymer")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "SubstancePolymer", id)
}
func (w Concrete) DeleteSubstanceProtein(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for SubstanceProtein")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "SubstanceProtein", id)
}
func (w Concrete) DeleteSubstanceReferenceInformation(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for SubstanceReferenceInformation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "SubstanceReferenceInformation", id)
}
func (w Concrete) DeleteSubstanceSourceMaterial(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for SubstanceSourceMaterial")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "SubstanceSourceMaterial", id)
}
func (w Concrete) DeleteSupplyDelivery(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for SupplyDelivery")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "SupplyDelivery", id)
}
func (w Concrete) DeleteSupplyRequest(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for SupplyRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "SupplyRequest", id)
}
func (w Concrete) DeleteTask(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Task")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Task", id)
}
func (w Concrete) DeleteTerminologyCapabilities(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for TerminologyCapabilities")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "TerminologyCapabilities", id)
}
func (w Concrete) DeleteTestPlan(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for TestPlan")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "TestPlan", id)
}
func (w Concrete) DeleteTestReport(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for TestReport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "TestReport", id)
}
func (w Concrete) DeleteTestScript(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for TestScript")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "TestScript", id)
}
func (w Concrete) DeleteTransport(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for Transport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "Transport", id)
}
func (w Concrete) DeleteValueSet(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for ValueSet")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "ValueSet", id)
}
func (w Concrete) DeleteVerificationResult(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for VerificationResult")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "VerificationResult", id)
}
func (w Concrete) DeleteVisionPrescription(ctx context.Context, id string) error {
	g, ok := w.Generic.(capabilities.GenericDelete)
	if !ok {
		return r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Delete not implemented for VisionPrescription")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	return g.Delete(ctx, "VisionPrescription", id)
}
func (w Concrete) SearchAccount(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Account], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Account]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Account")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Account", parameters, options)
	if err != nil {
		return search.Result[r5.Account]{}, err
	}
	resources := make([]r5.Account, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Account)
		if !ok {
			return search.Result[r5.Account]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Account" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Account]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesAccount(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Account" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchActivityDefinition(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.ActivityDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.ActivityDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for ActivityDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "ActivityDefinition", parameters, options)
	if err != nil {
		return search.Result[r5.ActivityDefinition]{}, err
	}
	resources := make([]r5.ActivityDefinition, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.ActivityDefinition)
		if !ok {
			return search.Result[r5.ActivityDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "ActivityDefinition" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.ActivityDefinition]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesActivityDefinition(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "ActivityDefinition" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchActorDefinition(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.ActorDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.ActorDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for ActorDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "ActorDefinition", parameters, options)
	if err != nil {
		return search.Result[r5.ActorDefinition]{}, err
	}
	resources := make([]r5.ActorDefinition, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.ActorDefinition)
		if !ok {
			return search.Result[r5.ActorDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "ActorDefinition" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.ActorDefinition]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesActorDefinition(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "ActorDefinition" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchAdministrableProductDefinition(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.AdministrableProductDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.AdministrableProductDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for AdministrableProductDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "AdministrableProductDefinition", parameters, options)
	if err != nil {
		return search.Result[r5.AdministrableProductDefinition]{}, err
	}
	resources := make([]r5.AdministrableProductDefinition, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.AdministrableProductDefinition)
		if !ok {
			return search.Result[r5.AdministrableProductDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "AdministrableProductDefinition" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.AdministrableProductDefinition]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesAdministrableProductDefinition(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "AdministrableProductDefinition" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchAdverseEvent(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.AdverseEvent], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.AdverseEvent]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for AdverseEvent")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "AdverseEvent", parameters, options)
	if err != nil {
		return search.Result[r5.AdverseEvent]{}, err
	}
	resources := make([]r5.AdverseEvent, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.AdverseEvent)
		if !ok {
			return search.Result[r5.AdverseEvent]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "AdverseEvent" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.AdverseEvent]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesAdverseEvent(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "AdverseEvent" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchAllergyIntolerance(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.AllergyIntolerance], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.AllergyIntolerance]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for AllergyIntolerance")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "AllergyIntolerance", parameters, options)
	if err != nil {
		return search.Result[r5.AllergyIntolerance]{}, err
	}
	resources := make([]r5.AllergyIntolerance, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.AllergyIntolerance)
		if !ok {
			return search.Result[r5.AllergyIntolerance]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "AllergyIntolerance" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.AllergyIntolerance]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesAllergyIntolerance(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "AllergyIntolerance" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchAppointment(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Appointment], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Appointment]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Appointment")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Appointment", parameters, options)
	if err != nil {
		return search.Result[r5.Appointment]{}, err
	}
	resources := make([]r5.Appointment, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Appointment)
		if !ok {
			return search.Result[r5.Appointment]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Appointment" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Appointment]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesAppointment(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Appointment" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchAppointmentResponse(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.AppointmentResponse], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.AppointmentResponse]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for AppointmentResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "AppointmentResponse", parameters, options)
	if err != nil {
		return search.Result[r5.AppointmentResponse]{}, err
	}
	resources := make([]r5.AppointmentResponse, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.AppointmentResponse)
		if !ok {
			return search.Result[r5.AppointmentResponse]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "AppointmentResponse" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.AppointmentResponse]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesAppointmentResponse(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "AppointmentResponse" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchArtifactAssessment(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.ArtifactAssessment], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.ArtifactAssessment]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for ArtifactAssessment")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "ArtifactAssessment", parameters, options)
	if err != nil {
		return search.Result[r5.ArtifactAssessment]{}, err
	}
	resources := make([]r5.ArtifactAssessment, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.ArtifactAssessment)
		if !ok {
			return search.Result[r5.ArtifactAssessment]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "ArtifactAssessment" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.ArtifactAssessment]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesArtifactAssessment(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "ArtifactAssessment" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchAuditEvent(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.AuditEvent], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.AuditEvent]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for AuditEvent")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "AuditEvent", parameters, options)
	if err != nil {
		return search.Result[r5.AuditEvent]{}, err
	}
	resources := make([]r5.AuditEvent, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.AuditEvent)
		if !ok {
			return search.Result[r5.AuditEvent]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "AuditEvent" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.AuditEvent]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesAuditEvent(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "AuditEvent" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchBasic(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Basic], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Basic]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Basic")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Basic", parameters, options)
	if err != nil {
		return search.Result[r5.Basic]{}, err
	}
	resources := make([]r5.Basic, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Basic)
		if !ok {
			return search.Result[r5.Basic]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Basic" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Basic]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesBasic(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Basic" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchBinary(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Binary], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Binary]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Binary")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Binary", parameters, options)
	if err != nil {
		return search.Result[r5.Binary]{}, err
	}
	resources := make([]r5.Binary, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Binary)
		if !ok {
			return search.Result[r5.Binary]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Binary" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Binary]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesBinary(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Binary" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchBiologicallyDerivedProduct(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.BiologicallyDerivedProduct], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.BiologicallyDerivedProduct]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for BiologicallyDerivedProduct")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "BiologicallyDerivedProduct", parameters, options)
	if err != nil {
		return search.Result[r5.BiologicallyDerivedProduct]{}, err
	}
	resources := make([]r5.BiologicallyDerivedProduct, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.BiologicallyDerivedProduct)
		if !ok {
			return search.Result[r5.BiologicallyDerivedProduct]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "BiologicallyDerivedProduct" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.BiologicallyDerivedProduct]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesBiologicallyDerivedProduct(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "BiologicallyDerivedProduct" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchBiologicallyDerivedProductDispense(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.BiologicallyDerivedProductDispense], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.BiologicallyDerivedProductDispense]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for BiologicallyDerivedProductDispense")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "BiologicallyDerivedProductDispense", parameters, options)
	if err != nil {
		return search.Result[r5.BiologicallyDerivedProductDispense]{}, err
	}
	resources := make([]r5.BiologicallyDerivedProductDispense, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.BiologicallyDerivedProductDispense)
		if !ok {
			return search.Result[r5.BiologicallyDerivedProductDispense]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "BiologicallyDerivedProductDispense" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.BiologicallyDerivedProductDispense]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesBiologicallyDerivedProductDispense(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "BiologicallyDerivedProductDispense" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchBodyStructure(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.BodyStructure], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.BodyStructure]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for BodyStructure")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "BodyStructure", parameters, options)
	if err != nil {
		return search.Result[r5.BodyStructure]{}, err
	}
	resources := make([]r5.BodyStructure, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.BodyStructure)
		if !ok {
			return search.Result[r5.BodyStructure]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "BodyStructure" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.BodyStructure]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesBodyStructure(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "BodyStructure" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchBundle(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Bundle], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Bundle]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Bundle")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Bundle", parameters, options)
	if err != nil {
		return search.Result[r5.Bundle]{}, err
	}
	resources := make([]r5.Bundle, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Bundle)
		if !ok {
			return search.Result[r5.Bundle]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Bundle" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Bundle]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesBundle(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Bundle" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchCapabilityStatement(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.CapabilityStatement], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.CapabilityStatement]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for CapabilityStatement")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "CapabilityStatement", parameters, options)
	if err != nil {
		return search.Result[r5.CapabilityStatement]{}, err
	}
	resources := make([]r5.CapabilityStatement, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.CapabilityStatement)
		if !ok {
			return search.Result[r5.CapabilityStatement]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "CapabilityStatement" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.CapabilityStatement]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesCapabilityStatement(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "CapabilityStatement" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchCarePlan(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.CarePlan], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.CarePlan]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for CarePlan")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "CarePlan", parameters, options)
	if err != nil {
		return search.Result[r5.CarePlan]{}, err
	}
	resources := make([]r5.CarePlan, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.CarePlan)
		if !ok {
			return search.Result[r5.CarePlan]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "CarePlan" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.CarePlan]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesCarePlan(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "CarePlan" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchCareTeam(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.CareTeam], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.CareTeam]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for CareTeam")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "CareTeam", parameters, options)
	if err != nil {
		return search.Result[r5.CareTeam]{}, err
	}
	resources := make([]r5.CareTeam, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.CareTeam)
		if !ok {
			return search.Result[r5.CareTeam]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "CareTeam" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.CareTeam]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesCareTeam(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "CareTeam" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchChargeItem(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.ChargeItem], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.ChargeItem]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for ChargeItem")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "ChargeItem", parameters, options)
	if err != nil {
		return search.Result[r5.ChargeItem]{}, err
	}
	resources := make([]r5.ChargeItem, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.ChargeItem)
		if !ok {
			return search.Result[r5.ChargeItem]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "ChargeItem" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.ChargeItem]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesChargeItem(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "ChargeItem" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchChargeItemDefinition(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.ChargeItemDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.ChargeItemDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for ChargeItemDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "ChargeItemDefinition", parameters, options)
	if err != nil {
		return search.Result[r5.ChargeItemDefinition]{}, err
	}
	resources := make([]r5.ChargeItemDefinition, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.ChargeItemDefinition)
		if !ok {
			return search.Result[r5.ChargeItemDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "ChargeItemDefinition" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.ChargeItemDefinition]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesChargeItemDefinition(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "ChargeItemDefinition" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchCitation(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Citation], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Citation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Citation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Citation", parameters, options)
	if err != nil {
		return search.Result[r5.Citation]{}, err
	}
	resources := make([]r5.Citation, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Citation)
		if !ok {
			return search.Result[r5.Citation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Citation" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Citation]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesCitation(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Citation" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchClaim(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Claim], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Claim]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Claim")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Claim", parameters, options)
	if err != nil {
		return search.Result[r5.Claim]{}, err
	}
	resources := make([]r5.Claim, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Claim)
		if !ok {
			return search.Result[r5.Claim]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Claim" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Claim]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesClaim(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Claim" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchClaimResponse(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.ClaimResponse], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.ClaimResponse]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for ClaimResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "ClaimResponse", parameters, options)
	if err != nil {
		return search.Result[r5.ClaimResponse]{}, err
	}
	resources := make([]r5.ClaimResponse, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.ClaimResponse)
		if !ok {
			return search.Result[r5.ClaimResponse]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "ClaimResponse" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.ClaimResponse]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesClaimResponse(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "ClaimResponse" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchClinicalImpression(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.ClinicalImpression], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.ClinicalImpression]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for ClinicalImpression")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "ClinicalImpression", parameters, options)
	if err != nil {
		return search.Result[r5.ClinicalImpression]{}, err
	}
	resources := make([]r5.ClinicalImpression, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.ClinicalImpression)
		if !ok {
			return search.Result[r5.ClinicalImpression]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "ClinicalImpression" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.ClinicalImpression]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesClinicalImpression(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "ClinicalImpression" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchClinicalUseDefinition(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.ClinicalUseDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.ClinicalUseDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for ClinicalUseDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "ClinicalUseDefinition", parameters, options)
	if err != nil {
		return search.Result[r5.ClinicalUseDefinition]{}, err
	}
	resources := make([]r5.ClinicalUseDefinition, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.ClinicalUseDefinition)
		if !ok {
			return search.Result[r5.ClinicalUseDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "ClinicalUseDefinition" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.ClinicalUseDefinition]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesClinicalUseDefinition(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "ClinicalUseDefinition" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchCodeSystem(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.CodeSystem], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.CodeSystem]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for CodeSystem")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "CodeSystem", parameters, options)
	if err != nil {
		return search.Result[r5.CodeSystem]{}, err
	}
	resources := make([]r5.CodeSystem, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.CodeSystem)
		if !ok {
			return search.Result[r5.CodeSystem]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "CodeSystem" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.CodeSystem]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesCodeSystem(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "CodeSystem" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchCommunication(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Communication], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Communication]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Communication")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Communication", parameters, options)
	if err != nil {
		return search.Result[r5.Communication]{}, err
	}
	resources := make([]r5.Communication, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Communication)
		if !ok {
			return search.Result[r5.Communication]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Communication" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Communication]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesCommunication(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Communication" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchCommunicationRequest(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.CommunicationRequest], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.CommunicationRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for CommunicationRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "CommunicationRequest", parameters, options)
	if err != nil {
		return search.Result[r5.CommunicationRequest]{}, err
	}
	resources := make([]r5.CommunicationRequest, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.CommunicationRequest)
		if !ok {
			return search.Result[r5.CommunicationRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "CommunicationRequest" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.CommunicationRequest]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesCommunicationRequest(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "CommunicationRequest" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchCompartmentDefinition(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.CompartmentDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.CompartmentDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for CompartmentDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "CompartmentDefinition", parameters, options)
	if err != nil {
		return search.Result[r5.CompartmentDefinition]{}, err
	}
	resources := make([]r5.CompartmentDefinition, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.CompartmentDefinition)
		if !ok {
			return search.Result[r5.CompartmentDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "CompartmentDefinition" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.CompartmentDefinition]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesCompartmentDefinition(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "CompartmentDefinition" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchComposition(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Composition], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Composition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Composition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Composition", parameters, options)
	if err != nil {
		return search.Result[r5.Composition]{}, err
	}
	resources := make([]r5.Composition, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Composition)
		if !ok {
			return search.Result[r5.Composition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Composition" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Composition]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesComposition(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Composition" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchConceptMap(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.ConceptMap], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.ConceptMap]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for ConceptMap")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "ConceptMap", parameters, options)
	if err != nil {
		return search.Result[r5.ConceptMap]{}, err
	}
	resources := make([]r5.ConceptMap, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.ConceptMap)
		if !ok {
			return search.Result[r5.ConceptMap]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "ConceptMap" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.ConceptMap]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesConceptMap(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "ConceptMap" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchCondition(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Condition], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Condition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Condition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Condition", parameters, options)
	if err != nil {
		return search.Result[r5.Condition]{}, err
	}
	resources := make([]r5.Condition, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Condition)
		if !ok {
			return search.Result[r5.Condition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Condition" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Condition]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesCondition(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Condition" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchConditionDefinition(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.ConditionDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.ConditionDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for ConditionDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "ConditionDefinition", parameters, options)
	if err != nil {
		return search.Result[r5.ConditionDefinition]{}, err
	}
	resources := make([]r5.ConditionDefinition, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.ConditionDefinition)
		if !ok {
			return search.Result[r5.ConditionDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "ConditionDefinition" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.ConditionDefinition]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesConditionDefinition(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "ConditionDefinition" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchConsent(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Consent], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Consent]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Consent")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Consent", parameters, options)
	if err != nil {
		return search.Result[r5.Consent]{}, err
	}
	resources := make([]r5.Consent, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Consent)
		if !ok {
			return search.Result[r5.Consent]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Consent" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Consent]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesConsent(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Consent" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchContract(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Contract], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Contract]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Contract")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Contract", parameters, options)
	if err != nil {
		return search.Result[r5.Contract]{}, err
	}
	resources := make([]r5.Contract, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Contract)
		if !ok {
			return search.Result[r5.Contract]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Contract" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Contract]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesContract(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Contract" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchCoverage(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Coverage], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Coverage]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Coverage")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Coverage", parameters, options)
	if err != nil {
		return search.Result[r5.Coverage]{}, err
	}
	resources := make([]r5.Coverage, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Coverage)
		if !ok {
			return search.Result[r5.Coverage]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Coverage" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Coverage]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesCoverage(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Coverage" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchCoverageEligibilityRequest(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.CoverageEligibilityRequest], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.CoverageEligibilityRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for CoverageEligibilityRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "CoverageEligibilityRequest", parameters, options)
	if err != nil {
		return search.Result[r5.CoverageEligibilityRequest]{}, err
	}
	resources := make([]r5.CoverageEligibilityRequest, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.CoverageEligibilityRequest)
		if !ok {
			return search.Result[r5.CoverageEligibilityRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "CoverageEligibilityRequest" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.CoverageEligibilityRequest]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesCoverageEligibilityRequest(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "CoverageEligibilityRequest" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchCoverageEligibilityResponse(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.CoverageEligibilityResponse], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.CoverageEligibilityResponse]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for CoverageEligibilityResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "CoverageEligibilityResponse", parameters, options)
	if err != nil {
		return search.Result[r5.CoverageEligibilityResponse]{}, err
	}
	resources := make([]r5.CoverageEligibilityResponse, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.CoverageEligibilityResponse)
		if !ok {
			return search.Result[r5.CoverageEligibilityResponse]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "CoverageEligibilityResponse" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.CoverageEligibilityResponse]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesCoverageEligibilityResponse(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "CoverageEligibilityResponse" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchDetectedIssue(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.DetectedIssue], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.DetectedIssue]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for DetectedIssue")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "DetectedIssue", parameters, options)
	if err != nil {
		return search.Result[r5.DetectedIssue]{}, err
	}
	resources := make([]r5.DetectedIssue, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.DetectedIssue)
		if !ok {
			return search.Result[r5.DetectedIssue]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "DetectedIssue" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.DetectedIssue]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesDetectedIssue(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "DetectedIssue" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchDevice(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Device], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Device]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Device")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Device", parameters, options)
	if err != nil {
		return search.Result[r5.Device]{}, err
	}
	resources := make([]r5.Device, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Device)
		if !ok {
			return search.Result[r5.Device]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Device" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Device]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesDevice(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Device" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchDeviceAssociation(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.DeviceAssociation], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.DeviceAssociation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for DeviceAssociation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "DeviceAssociation", parameters, options)
	if err != nil {
		return search.Result[r5.DeviceAssociation]{}, err
	}
	resources := make([]r5.DeviceAssociation, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.DeviceAssociation)
		if !ok {
			return search.Result[r5.DeviceAssociation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "DeviceAssociation" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.DeviceAssociation]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesDeviceAssociation(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "DeviceAssociation" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchDeviceDefinition(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.DeviceDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.DeviceDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for DeviceDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "DeviceDefinition", parameters, options)
	if err != nil {
		return search.Result[r5.DeviceDefinition]{}, err
	}
	resources := make([]r5.DeviceDefinition, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.DeviceDefinition)
		if !ok {
			return search.Result[r5.DeviceDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "DeviceDefinition" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.DeviceDefinition]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesDeviceDefinition(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "DeviceDefinition" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchDeviceDispense(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.DeviceDispense], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.DeviceDispense]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for DeviceDispense")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "DeviceDispense", parameters, options)
	if err != nil {
		return search.Result[r5.DeviceDispense]{}, err
	}
	resources := make([]r5.DeviceDispense, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.DeviceDispense)
		if !ok {
			return search.Result[r5.DeviceDispense]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "DeviceDispense" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.DeviceDispense]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesDeviceDispense(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "DeviceDispense" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchDeviceMetric(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.DeviceMetric], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.DeviceMetric]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for DeviceMetric")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "DeviceMetric", parameters, options)
	if err != nil {
		return search.Result[r5.DeviceMetric]{}, err
	}
	resources := make([]r5.DeviceMetric, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.DeviceMetric)
		if !ok {
			return search.Result[r5.DeviceMetric]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "DeviceMetric" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.DeviceMetric]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesDeviceMetric(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "DeviceMetric" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchDeviceRequest(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.DeviceRequest], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.DeviceRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for DeviceRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "DeviceRequest", parameters, options)
	if err != nil {
		return search.Result[r5.DeviceRequest]{}, err
	}
	resources := make([]r5.DeviceRequest, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.DeviceRequest)
		if !ok {
			return search.Result[r5.DeviceRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "DeviceRequest" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.DeviceRequest]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesDeviceRequest(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "DeviceRequest" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchDeviceUsage(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.DeviceUsage], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.DeviceUsage]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for DeviceUsage")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "DeviceUsage", parameters, options)
	if err != nil {
		return search.Result[r5.DeviceUsage]{}, err
	}
	resources := make([]r5.DeviceUsage, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.DeviceUsage)
		if !ok {
			return search.Result[r5.DeviceUsage]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "DeviceUsage" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.DeviceUsage]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesDeviceUsage(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "DeviceUsage" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchDiagnosticReport(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.DiagnosticReport], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.DiagnosticReport]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for DiagnosticReport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "DiagnosticReport", parameters, options)
	if err != nil {
		return search.Result[r5.DiagnosticReport]{}, err
	}
	resources := make([]r5.DiagnosticReport, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.DiagnosticReport)
		if !ok {
			return search.Result[r5.DiagnosticReport]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "DiagnosticReport" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.DiagnosticReport]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesDiagnosticReport(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "DiagnosticReport" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchDocumentReference(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.DocumentReference], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.DocumentReference]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for DocumentReference")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "DocumentReference", parameters, options)
	if err != nil {
		return search.Result[r5.DocumentReference]{}, err
	}
	resources := make([]r5.DocumentReference, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.DocumentReference)
		if !ok {
			return search.Result[r5.DocumentReference]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "DocumentReference" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.DocumentReference]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesDocumentReference(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "DocumentReference" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchEncounter(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Encounter], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Encounter]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Encounter")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Encounter", parameters, options)
	if err != nil {
		return search.Result[r5.Encounter]{}, err
	}
	resources := make([]r5.Encounter, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Encounter)
		if !ok {
			return search.Result[r5.Encounter]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Encounter" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Encounter]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesEncounter(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Encounter" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchEncounterHistory(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.EncounterHistory], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.EncounterHistory]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for EncounterHistory")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "EncounterHistory", parameters, options)
	if err != nil {
		return search.Result[r5.EncounterHistory]{}, err
	}
	resources := make([]r5.EncounterHistory, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.EncounterHistory)
		if !ok {
			return search.Result[r5.EncounterHistory]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "EncounterHistory" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.EncounterHistory]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesEncounterHistory(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "EncounterHistory" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchEndpoint(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Endpoint], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Endpoint]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Endpoint")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Endpoint", parameters, options)
	if err != nil {
		return search.Result[r5.Endpoint]{}, err
	}
	resources := make([]r5.Endpoint, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Endpoint)
		if !ok {
			return search.Result[r5.Endpoint]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Endpoint" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Endpoint]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesEndpoint(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Endpoint" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchEnrollmentRequest(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.EnrollmentRequest], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.EnrollmentRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for EnrollmentRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "EnrollmentRequest", parameters, options)
	if err != nil {
		return search.Result[r5.EnrollmentRequest]{}, err
	}
	resources := make([]r5.EnrollmentRequest, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.EnrollmentRequest)
		if !ok {
			return search.Result[r5.EnrollmentRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "EnrollmentRequest" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.EnrollmentRequest]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesEnrollmentRequest(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "EnrollmentRequest" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchEnrollmentResponse(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.EnrollmentResponse], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.EnrollmentResponse]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for EnrollmentResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "EnrollmentResponse", parameters, options)
	if err != nil {
		return search.Result[r5.EnrollmentResponse]{}, err
	}
	resources := make([]r5.EnrollmentResponse, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.EnrollmentResponse)
		if !ok {
			return search.Result[r5.EnrollmentResponse]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "EnrollmentResponse" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.EnrollmentResponse]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesEnrollmentResponse(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "EnrollmentResponse" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchEpisodeOfCare(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.EpisodeOfCare], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.EpisodeOfCare]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for EpisodeOfCare")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "EpisodeOfCare", parameters, options)
	if err != nil {
		return search.Result[r5.EpisodeOfCare]{}, err
	}
	resources := make([]r5.EpisodeOfCare, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.EpisodeOfCare)
		if !ok {
			return search.Result[r5.EpisodeOfCare]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "EpisodeOfCare" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.EpisodeOfCare]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesEpisodeOfCare(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "EpisodeOfCare" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchEventDefinition(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.EventDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.EventDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for EventDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "EventDefinition", parameters, options)
	if err != nil {
		return search.Result[r5.EventDefinition]{}, err
	}
	resources := make([]r5.EventDefinition, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.EventDefinition)
		if !ok {
			return search.Result[r5.EventDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "EventDefinition" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.EventDefinition]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesEventDefinition(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "EventDefinition" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchEvidence(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Evidence], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Evidence]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Evidence")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Evidence", parameters, options)
	if err != nil {
		return search.Result[r5.Evidence]{}, err
	}
	resources := make([]r5.Evidence, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Evidence)
		if !ok {
			return search.Result[r5.Evidence]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Evidence" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Evidence]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesEvidence(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Evidence" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchEvidenceReport(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.EvidenceReport], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.EvidenceReport]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for EvidenceReport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "EvidenceReport", parameters, options)
	if err != nil {
		return search.Result[r5.EvidenceReport]{}, err
	}
	resources := make([]r5.EvidenceReport, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.EvidenceReport)
		if !ok {
			return search.Result[r5.EvidenceReport]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "EvidenceReport" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.EvidenceReport]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesEvidenceReport(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "EvidenceReport" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchEvidenceVariable(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.EvidenceVariable], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.EvidenceVariable]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for EvidenceVariable")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "EvidenceVariable", parameters, options)
	if err != nil {
		return search.Result[r5.EvidenceVariable]{}, err
	}
	resources := make([]r5.EvidenceVariable, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.EvidenceVariable)
		if !ok {
			return search.Result[r5.EvidenceVariable]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "EvidenceVariable" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.EvidenceVariable]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesEvidenceVariable(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "EvidenceVariable" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchExampleScenario(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.ExampleScenario], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.ExampleScenario]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for ExampleScenario")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "ExampleScenario", parameters, options)
	if err != nil {
		return search.Result[r5.ExampleScenario]{}, err
	}
	resources := make([]r5.ExampleScenario, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.ExampleScenario)
		if !ok {
			return search.Result[r5.ExampleScenario]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "ExampleScenario" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.ExampleScenario]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesExampleScenario(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "ExampleScenario" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchExplanationOfBenefit(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.ExplanationOfBenefit], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.ExplanationOfBenefit]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for ExplanationOfBenefit")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "ExplanationOfBenefit", parameters, options)
	if err != nil {
		return search.Result[r5.ExplanationOfBenefit]{}, err
	}
	resources := make([]r5.ExplanationOfBenefit, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.ExplanationOfBenefit)
		if !ok {
			return search.Result[r5.ExplanationOfBenefit]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "ExplanationOfBenefit" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.ExplanationOfBenefit]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesExplanationOfBenefit(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "ExplanationOfBenefit" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchFamilyMemberHistory(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.FamilyMemberHistory], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.FamilyMemberHistory]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for FamilyMemberHistory")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "FamilyMemberHistory", parameters, options)
	if err != nil {
		return search.Result[r5.FamilyMemberHistory]{}, err
	}
	resources := make([]r5.FamilyMemberHistory, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.FamilyMemberHistory)
		if !ok {
			return search.Result[r5.FamilyMemberHistory]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "FamilyMemberHistory" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.FamilyMemberHistory]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesFamilyMemberHistory(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "FamilyMemberHistory" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchFlag(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Flag], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Flag]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Flag")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Flag", parameters, options)
	if err != nil {
		return search.Result[r5.Flag]{}, err
	}
	resources := make([]r5.Flag, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Flag)
		if !ok {
			return search.Result[r5.Flag]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Flag" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Flag]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesFlag(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Flag" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchFormularyItem(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.FormularyItem], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.FormularyItem]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for FormularyItem")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "FormularyItem", parameters, options)
	if err != nil {
		return search.Result[r5.FormularyItem]{}, err
	}
	resources := make([]r5.FormularyItem, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.FormularyItem)
		if !ok {
			return search.Result[r5.FormularyItem]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "FormularyItem" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.FormularyItem]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesFormularyItem(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "FormularyItem" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchGenomicStudy(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.GenomicStudy], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.GenomicStudy]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for GenomicStudy")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "GenomicStudy", parameters, options)
	if err != nil {
		return search.Result[r5.GenomicStudy]{}, err
	}
	resources := make([]r5.GenomicStudy, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.GenomicStudy)
		if !ok {
			return search.Result[r5.GenomicStudy]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "GenomicStudy" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.GenomicStudy]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesGenomicStudy(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "GenomicStudy" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchGoal(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Goal], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Goal]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Goal")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Goal", parameters, options)
	if err != nil {
		return search.Result[r5.Goal]{}, err
	}
	resources := make([]r5.Goal, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Goal)
		if !ok {
			return search.Result[r5.Goal]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Goal" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Goal]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesGoal(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Goal" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchGraphDefinition(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.GraphDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.GraphDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for GraphDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "GraphDefinition", parameters, options)
	if err != nil {
		return search.Result[r5.GraphDefinition]{}, err
	}
	resources := make([]r5.GraphDefinition, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.GraphDefinition)
		if !ok {
			return search.Result[r5.GraphDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "GraphDefinition" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.GraphDefinition]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesGraphDefinition(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "GraphDefinition" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchGroup(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Group], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Group]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Group")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Group", parameters, options)
	if err != nil {
		return search.Result[r5.Group]{}, err
	}
	resources := make([]r5.Group, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Group)
		if !ok {
			return search.Result[r5.Group]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Group" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Group]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesGroup(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Group" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchGuidanceResponse(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.GuidanceResponse], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.GuidanceResponse]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for GuidanceResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "GuidanceResponse", parameters, options)
	if err != nil {
		return search.Result[r5.GuidanceResponse]{}, err
	}
	resources := make([]r5.GuidanceResponse, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.GuidanceResponse)
		if !ok {
			return search.Result[r5.GuidanceResponse]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "GuidanceResponse" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.GuidanceResponse]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesGuidanceResponse(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "GuidanceResponse" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchHealthcareService(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.HealthcareService], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.HealthcareService]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for HealthcareService")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "HealthcareService", parameters, options)
	if err != nil {
		return search.Result[r5.HealthcareService]{}, err
	}
	resources := make([]r5.HealthcareService, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.HealthcareService)
		if !ok {
			return search.Result[r5.HealthcareService]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "HealthcareService" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.HealthcareService]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesHealthcareService(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "HealthcareService" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchImagingSelection(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.ImagingSelection], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.ImagingSelection]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for ImagingSelection")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "ImagingSelection", parameters, options)
	if err != nil {
		return search.Result[r5.ImagingSelection]{}, err
	}
	resources := make([]r5.ImagingSelection, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.ImagingSelection)
		if !ok {
			return search.Result[r5.ImagingSelection]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "ImagingSelection" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.ImagingSelection]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesImagingSelection(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "ImagingSelection" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchImagingStudy(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.ImagingStudy], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.ImagingStudy]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for ImagingStudy")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "ImagingStudy", parameters, options)
	if err != nil {
		return search.Result[r5.ImagingStudy]{}, err
	}
	resources := make([]r5.ImagingStudy, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.ImagingStudy)
		if !ok {
			return search.Result[r5.ImagingStudy]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "ImagingStudy" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.ImagingStudy]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesImagingStudy(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "ImagingStudy" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchImmunization(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Immunization], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Immunization]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Immunization")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Immunization", parameters, options)
	if err != nil {
		return search.Result[r5.Immunization]{}, err
	}
	resources := make([]r5.Immunization, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Immunization)
		if !ok {
			return search.Result[r5.Immunization]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Immunization" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Immunization]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesImmunization(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Immunization" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchImmunizationEvaluation(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.ImmunizationEvaluation], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.ImmunizationEvaluation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for ImmunizationEvaluation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "ImmunizationEvaluation", parameters, options)
	if err != nil {
		return search.Result[r5.ImmunizationEvaluation]{}, err
	}
	resources := make([]r5.ImmunizationEvaluation, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.ImmunizationEvaluation)
		if !ok {
			return search.Result[r5.ImmunizationEvaluation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "ImmunizationEvaluation" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.ImmunizationEvaluation]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesImmunizationEvaluation(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "ImmunizationEvaluation" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchImmunizationRecommendation(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.ImmunizationRecommendation], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.ImmunizationRecommendation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for ImmunizationRecommendation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "ImmunizationRecommendation", parameters, options)
	if err != nil {
		return search.Result[r5.ImmunizationRecommendation]{}, err
	}
	resources := make([]r5.ImmunizationRecommendation, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.ImmunizationRecommendation)
		if !ok {
			return search.Result[r5.ImmunizationRecommendation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "ImmunizationRecommendation" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.ImmunizationRecommendation]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesImmunizationRecommendation(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "ImmunizationRecommendation" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchImplementationGuide(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.ImplementationGuide], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.ImplementationGuide]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for ImplementationGuide")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "ImplementationGuide", parameters, options)
	if err != nil {
		return search.Result[r5.ImplementationGuide]{}, err
	}
	resources := make([]r5.ImplementationGuide, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.ImplementationGuide)
		if !ok {
			return search.Result[r5.ImplementationGuide]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "ImplementationGuide" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.ImplementationGuide]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesImplementationGuide(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "ImplementationGuide" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchIngredient(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Ingredient], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Ingredient]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Ingredient")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Ingredient", parameters, options)
	if err != nil {
		return search.Result[r5.Ingredient]{}, err
	}
	resources := make([]r5.Ingredient, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Ingredient)
		if !ok {
			return search.Result[r5.Ingredient]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Ingredient" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Ingredient]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesIngredient(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Ingredient" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchInsurancePlan(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.InsurancePlan], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.InsurancePlan]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for InsurancePlan")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "InsurancePlan", parameters, options)
	if err != nil {
		return search.Result[r5.InsurancePlan]{}, err
	}
	resources := make([]r5.InsurancePlan, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.InsurancePlan)
		if !ok {
			return search.Result[r5.InsurancePlan]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "InsurancePlan" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.InsurancePlan]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesInsurancePlan(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "InsurancePlan" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchInventoryItem(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.InventoryItem], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.InventoryItem]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for InventoryItem")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "InventoryItem", parameters, options)
	if err != nil {
		return search.Result[r5.InventoryItem]{}, err
	}
	resources := make([]r5.InventoryItem, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.InventoryItem)
		if !ok {
			return search.Result[r5.InventoryItem]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "InventoryItem" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.InventoryItem]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesInventoryItem(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "InventoryItem" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchInventoryReport(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.InventoryReport], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.InventoryReport]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for InventoryReport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "InventoryReport", parameters, options)
	if err != nil {
		return search.Result[r5.InventoryReport]{}, err
	}
	resources := make([]r5.InventoryReport, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.InventoryReport)
		if !ok {
			return search.Result[r5.InventoryReport]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "InventoryReport" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.InventoryReport]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesInventoryReport(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "InventoryReport" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchInvoice(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Invoice], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Invoice]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Invoice")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Invoice", parameters, options)
	if err != nil {
		return search.Result[r5.Invoice]{}, err
	}
	resources := make([]r5.Invoice, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Invoice)
		if !ok {
			return search.Result[r5.Invoice]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Invoice" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Invoice]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesInvoice(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Invoice" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchLibrary(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Library], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Library]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Library")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Library", parameters, options)
	if err != nil {
		return search.Result[r5.Library]{}, err
	}
	resources := make([]r5.Library, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Library)
		if !ok {
			return search.Result[r5.Library]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Library" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Library]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesLibrary(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Library" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchLinkage(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Linkage], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Linkage]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Linkage")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Linkage", parameters, options)
	if err != nil {
		return search.Result[r5.Linkage]{}, err
	}
	resources := make([]r5.Linkage, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Linkage)
		if !ok {
			return search.Result[r5.Linkage]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Linkage" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Linkage]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesLinkage(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Linkage" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchList(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.List], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.List]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for List")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "List", parameters, options)
	if err != nil {
		return search.Result[r5.List]{}, err
	}
	resources := make([]r5.List, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.List)
		if !ok {
			return search.Result[r5.List]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "List" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.List]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesList(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "List" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchLocation(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Location], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Location]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Location")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Location", parameters, options)
	if err != nil {
		return search.Result[r5.Location]{}, err
	}
	resources := make([]r5.Location, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Location)
		if !ok {
			return search.Result[r5.Location]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Location" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Location]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesLocation(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Location" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchManufacturedItemDefinition(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.ManufacturedItemDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.ManufacturedItemDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for ManufacturedItemDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "ManufacturedItemDefinition", parameters, options)
	if err != nil {
		return search.Result[r5.ManufacturedItemDefinition]{}, err
	}
	resources := make([]r5.ManufacturedItemDefinition, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.ManufacturedItemDefinition)
		if !ok {
			return search.Result[r5.ManufacturedItemDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "ManufacturedItemDefinition" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.ManufacturedItemDefinition]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesManufacturedItemDefinition(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "ManufacturedItemDefinition" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchMeasure(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Measure], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Measure]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Measure")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Measure", parameters, options)
	if err != nil {
		return search.Result[r5.Measure]{}, err
	}
	resources := make([]r5.Measure, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Measure)
		if !ok {
			return search.Result[r5.Measure]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Measure" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Measure]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesMeasure(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Measure" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchMeasureReport(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.MeasureReport], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.MeasureReport]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for MeasureReport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "MeasureReport", parameters, options)
	if err != nil {
		return search.Result[r5.MeasureReport]{}, err
	}
	resources := make([]r5.MeasureReport, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.MeasureReport)
		if !ok {
			return search.Result[r5.MeasureReport]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "MeasureReport" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.MeasureReport]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesMeasureReport(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "MeasureReport" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchMedication(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Medication], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Medication]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Medication")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Medication", parameters, options)
	if err != nil {
		return search.Result[r5.Medication]{}, err
	}
	resources := make([]r5.Medication, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Medication)
		if !ok {
			return search.Result[r5.Medication]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Medication" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Medication]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesMedication(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Medication" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchMedicationAdministration(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.MedicationAdministration], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.MedicationAdministration]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for MedicationAdministration")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "MedicationAdministration", parameters, options)
	if err != nil {
		return search.Result[r5.MedicationAdministration]{}, err
	}
	resources := make([]r5.MedicationAdministration, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.MedicationAdministration)
		if !ok {
			return search.Result[r5.MedicationAdministration]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "MedicationAdministration" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.MedicationAdministration]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesMedicationAdministration(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "MedicationAdministration" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchMedicationDispense(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.MedicationDispense], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.MedicationDispense]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for MedicationDispense")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "MedicationDispense", parameters, options)
	if err != nil {
		return search.Result[r5.MedicationDispense]{}, err
	}
	resources := make([]r5.MedicationDispense, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.MedicationDispense)
		if !ok {
			return search.Result[r5.MedicationDispense]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "MedicationDispense" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.MedicationDispense]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesMedicationDispense(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "MedicationDispense" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchMedicationKnowledge(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.MedicationKnowledge], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.MedicationKnowledge]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for MedicationKnowledge")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "MedicationKnowledge", parameters, options)
	if err != nil {
		return search.Result[r5.MedicationKnowledge]{}, err
	}
	resources := make([]r5.MedicationKnowledge, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.MedicationKnowledge)
		if !ok {
			return search.Result[r5.MedicationKnowledge]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "MedicationKnowledge" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.MedicationKnowledge]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesMedicationKnowledge(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "MedicationKnowledge" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchMedicationRequest(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.MedicationRequest], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.MedicationRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for MedicationRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "MedicationRequest", parameters, options)
	if err != nil {
		return search.Result[r5.MedicationRequest]{}, err
	}
	resources := make([]r5.MedicationRequest, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.MedicationRequest)
		if !ok {
			return search.Result[r5.MedicationRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "MedicationRequest" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.MedicationRequest]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesMedicationRequest(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "MedicationRequest" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchMedicationStatement(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.MedicationStatement], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.MedicationStatement]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for MedicationStatement")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "MedicationStatement", parameters, options)
	if err != nil {
		return search.Result[r5.MedicationStatement]{}, err
	}
	resources := make([]r5.MedicationStatement, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.MedicationStatement)
		if !ok {
			return search.Result[r5.MedicationStatement]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "MedicationStatement" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.MedicationStatement]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesMedicationStatement(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "MedicationStatement" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchMedicinalProductDefinition(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.MedicinalProductDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.MedicinalProductDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for MedicinalProductDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "MedicinalProductDefinition", parameters, options)
	if err != nil {
		return search.Result[r5.MedicinalProductDefinition]{}, err
	}
	resources := make([]r5.MedicinalProductDefinition, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.MedicinalProductDefinition)
		if !ok {
			return search.Result[r5.MedicinalProductDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "MedicinalProductDefinition" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.MedicinalProductDefinition]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesMedicinalProductDefinition(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "MedicinalProductDefinition" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchMessageDefinition(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.MessageDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.MessageDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for MessageDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "MessageDefinition", parameters, options)
	if err != nil {
		return search.Result[r5.MessageDefinition]{}, err
	}
	resources := make([]r5.MessageDefinition, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.MessageDefinition)
		if !ok {
			return search.Result[r5.MessageDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "MessageDefinition" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.MessageDefinition]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesMessageDefinition(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "MessageDefinition" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchMessageHeader(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.MessageHeader], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.MessageHeader]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for MessageHeader")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "MessageHeader", parameters, options)
	if err != nil {
		return search.Result[r5.MessageHeader]{}, err
	}
	resources := make([]r5.MessageHeader, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.MessageHeader)
		if !ok {
			return search.Result[r5.MessageHeader]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "MessageHeader" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.MessageHeader]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesMessageHeader(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "MessageHeader" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchMolecularSequence(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.MolecularSequence], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.MolecularSequence]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for MolecularSequence")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "MolecularSequence", parameters, options)
	if err != nil {
		return search.Result[r5.MolecularSequence]{}, err
	}
	resources := make([]r5.MolecularSequence, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.MolecularSequence)
		if !ok {
			return search.Result[r5.MolecularSequence]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "MolecularSequence" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.MolecularSequence]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesMolecularSequence(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "MolecularSequence" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchNamingSystem(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.NamingSystem], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.NamingSystem]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for NamingSystem")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "NamingSystem", parameters, options)
	if err != nil {
		return search.Result[r5.NamingSystem]{}, err
	}
	resources := make([]r5.NamingSystem, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.NamingSystem)
		if !ok {
			return search.Result[r5.NamingSystem]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "NamingSystem" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.NamingSystem]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesNamingSystem(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "NamingSystem" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchNutritionIntake(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.NutritionIntake], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.NutritionIntake]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for NutritionIntake")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "NutritionIntake", parameters, options)
	if err != nil {
		return search.Result[r5.NutritionIntake]{}, err
	}
	resources := make([]r5.NutritionIntake, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.NutritionIntake)
		if !ok {
			return search.Result[r5.NutritionIntake]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "NutritionIntake" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.NutritionIntake]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesNutritionIntake(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "NutritionIntake" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchNutritionOrder(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.NutritionOrder], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.NutritionOrder]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for NutritionOrder")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "NutritionOrder", parameters, options)
	if err != nil {
		return search.Result[r5.NutritionOrder]{}, err
	}
	resources := make([]r5.NutritionOrder, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.NutritionOrder)
		if !ok {
			return search.Result[r5.NutritionOrder]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "NutritionOrder" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.NutritionOrder]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesNutritionOrder(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "NutritionOrder" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchNutritionProduct(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.NutritionProduct], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.NutritionProduct]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for NutritionProduct")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "NutritionProduct", parameters, options)
	if err != nil {
		return search.Result[r5.NutritionProduct]{}, err
	}
	resources := make([]r5.NutritionProduct, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.NutritionProduct)
		if !ok {
			return search.Result[r5.NutritionProduct]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "NutritionProduct" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.NutritionProduct]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesNutritionProduct(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "NutritionProduct" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchObservation(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Observation], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Observation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Observation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Observation", parameters, options)
	if err != nil {
		return search.Result[r5.Observation]{}, err
	}
	resources := make([]r5.Observation, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Observation)
		if !ok {
			return search.Result[r5.Observation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Observation" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Observation]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesObservation(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Observation" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchObservationDefinition(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.ObservationDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.ObservationDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for ObservationDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "ObservationDefinition", parameters, options)
	if err != nil {
		return search.Result[r5.ObservationDefinition]{}, err
	}
	resources := make([]r5.ObservationDefinition, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.ObservationDefinition)
		if !ok {
			return search.Result[r5.ObservationDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "ObservationDefinition" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.ObservationDefinition]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesObservationDefinition(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "ObservationDefinition" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchOperationDefinition(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.OperationDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.OperationDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for OperationDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "OperationDefinition", parameters, options)
	if err != nil {
		return search.Result[r5.OperationDefinition]{}, err
	}
	resources := make([]r5.OperationDefinition, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.OperationDefinition)
		if !ok {
			return search.Result[r5.OperationDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "OperationDefinition" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.OperationDefinition]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesOperationDefinition(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "OperationDefinition" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchOperationOutcome(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.OperationOutcome], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.OperationOutcome]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for OperationOutcome")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "OperationOutcome", parameters, options)
	if err != nil {
		return search.Result[r5.OperationOutcome]{}, err
	}
	resources := make([]r5.OperationOutcome, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.OperationOutcome)
		if !ok {
			return search.Result[r5.OperationOutcome]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "OperationOutcome" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.OperationOutcome]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesOperationOutcome(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "OperationOutcome" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchOrganization(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Organization], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Organization]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Organization")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Organization", parameters, options)
	if err != nil {
		return search.Result[r5.Organization]{}, err
	}
	resources := make([]r5.Organization, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Organization)
		if !ok {
			return search.Result[r5.Organization]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Organization" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Organization]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesOrganization(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Organization" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchOrganizationAffiliation(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.OrganizationAffiliation], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.OrganizationAffiliation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for OrganizationAffiliation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "OrganizationAffiliation", parameters, options)
	if err != nil {
		return search.Result[r5.OrganizationAffiliation]{}, err
	}
	resources := make([]r5.OrganizationAffiliation, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.OrganizationAffiliation)
		if !ok {
			return search.Result[r5.OrganizationAffiliation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "OrganizationAffiliation" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.OrganizationAffiliation]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesOrganizationAffiliation(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "OrganizationAffiliation" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchPackagedProductDefinition(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.PackagedProductDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.PackagedProductDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for PackagedProductDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "PackagedProductDefinition", parameters, options)
	if err != nil {
		return search.Result[r5.PackagedProductDefinition]{}, err
	}
	resources := make([]r5.PackagedProductDefinition, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.PackagedProductDefinition)
		if !ok {
			return search.Result[r5.PackagedProductDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "PackagedProductDefinition" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.PackagedProductDefinition]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesPackagedProductDefinition(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "PackagedProductDefinition" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchParameters(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Parameters], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Parameters]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Parameters")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Parameters", parameters, options)
	if err != nil {
		return search.Result[r5.Parameters]{}, err
	}
	resources := make([]r5.Parameters, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Parameters)
		if !ok {
			return search.Result[r5.Parameters]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Parameters" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Parameters]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesParameters(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Parameters" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchPatient(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Patient], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Patient]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Patient")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Patient", parameters, options)
	if err != nil {
		return search.Result[r5.Patient]{}, err
	}
	resources := make([]r5.Patient, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Patient)
		if !ok {
			return search.Result[r5.Patient]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Patient" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Patient]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesPatient(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Patient" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchPaymentNotice(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.PaymentNotice], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.PaymentNotice]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for PaymentNotice")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "PaymentNotice", parameters, options)
	if err != nil {
		return search.Result[r5.PaymentNotice]{}, err
	}
	resources := make([]r5.PaymentNotice, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.PaymentNotice)
		if !ok {
			return search.Result[r5.PaymentNotice]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "PaymentNotice" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.PaymentNotice]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesPaymentNotice(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "PaymentNotice" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchPaymentReconciliation(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.PaymentReconciliation], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.PaymentReconciliation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for PaymentReconciliation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "PaymentReconciliation", parameters, options)
	if err != nil {
		return search.Result[r5.PaymentReconciliation]{}, err
	}
	resources := make([]r5.PaymentReconciliation, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.PaymentReconciliation)
		if !ok {
			return search.Result[r5.PaymentReconciliation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "PaymentReconciliation" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.PaymentReconciliation]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesPaymentReconciliation(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "PaymentReconciliation" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchPermission(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Permission], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Permission]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Permission")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Permission", parameters, options)
	if err != nil {
		return search.Result[r5.Permission]{}, err
	}
	resources := make([]r5.Permission, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Permission)
		if !ok {
			return search.Result[r5.Permission]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Permission" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Permission]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesPermission(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Permission" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchPerson(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Person], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Person]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Person")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Person", parameters, options)
	if err != nil {
		return search.Result[r5.Person]{}, err
	}
	resources := make([]r5.Person, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Person)
		if !ok {
			return search.Result[r5.Person]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Person" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Person]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesPerson(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Person" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchPlanDefinition(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.PlanDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.PlanDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for PlanDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "PlanDefinition", parameters, options)
	if err != nil {
		return search.Result[r5.PlanDefinition]{}, err
	}
	resources := make([]r5.PlanDefinition, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.PlanDefinition)
		if !ok {
			return search.Result[r5.PlanDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "PlanDefinition" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.PlanDefinition]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesPlanDefinition(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "PlanDefinition" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchPractitioner(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Practitioner], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Practitioner]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Practitioner")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Practitioner", parameters, options)
	if err != nil {
		return search.Result[r5.Practitioner]{}, err
	}
	resources := make([]r5.Practitioner, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Practitioner)
		if !ok {
			return search.Result[r5.Practitioner]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Practitioner" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Practitioner]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesPractitioner(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Practitioner" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchPractitionerRole(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.PractitionerRole], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.PractitionerRole]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for PractitionerRole")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "PractitionerRole", parameters, options)
	if err != nil {
		return search.Result[r5.PractitionerRole]{}, err
	}
	resources := make([]r5.PractitionerRole, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.PractitionerRole)
		if !ok {
			return search.Result[r5.PractitionerRole]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "PractitionerRole" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.PractitionerRole]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesPractitionerRole(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "PractitionerRole" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchProcedure(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Procedure], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Procedure]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Procedure")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Procedure", parameters, options)
	if err != nil {
		return search.Result[r5.Procedure]{}, err
	}
	resources := make([]r5.Procedure, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Procedure)
		if !ok {
			return search.Result[r5.Procedure]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Procedure" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Procedure]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesProcedure(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Procedure" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchProvenance(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Provenance], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Provenance]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Provenance")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Provenance", parameters, options)
	if err != nil {
		return search.Result[r5.Provenance]{}, err
	}
	resources := make([]r5.Provenance, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Provenance)
		if !ok {
			return search.Result[r5.Provenance]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Provenance" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Provenance]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesProvenance(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Provenance" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchQuestionnaire(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Questionnaire], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Questionnaire]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Questionnaire")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Questionnaire", parameters, options)
	if err != nil {
		return search.Result[r5.Questionnaire]{}, err
	}
	resources := make([]r5.Questionnaire, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Questionnaire)
		if !ok {
			return search.Result[r5.Questionnaire]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Questionnaire" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Questionnaire]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesQuestionnaire(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Questionnaire" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchQuestionnaireResponse(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.QuestionnaireResponse], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.QuestionnaireResponse]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for QuestionnaireResponse")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "QuestionnaireResponse", parameters, options)
	if err != nil {
		return search.Result[r5.QuestionnaireResponse]{}, err
	}
	resources := make([]r5.QuestionnaireResponse, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.QuestionnaireResponse)
		if !ok {
			return search.Result[r5.QuestionnaireResponse]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "QuestionnaireResponse" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.QuestionnaireResponse]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesQuestionnaireResponse(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "QuestionnaireResponse" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchRegulatedAuthorization(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.RegulatedAuthorization], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.RegulatedAuthorization]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for RegulatedAuthorization")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "RegulatedAuthorization", parameters, options)
	if err != nil {
		return search.Result[r5.RegulatedAuthorization]{}, err
	}
	resources := make([]r5.RegulatedAuthorization, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.RegulatedAuthorization)
		if !ok {
			return search.Result[r5.RegulatedAuthorization]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "RegulatedAuthorization" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.RegulatedAuthorization]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesRegulatedAuthorization(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "RegulatedAuthorization" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchRelatedPerson(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.RelatedPerson], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.RelatedPerson]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for RelatedPerson")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "RelatedPerson", parameters, options)
	if err != nil {
		return search.Result[r5.RelatedPerson]{}, err
	}
	resources := make([]r5.RelatedPerson, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.RelatedPerson)
		if !ok {
			return search.Result[r5.RelatedPerson]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "RelatedPerson" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.RelatedPerson]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesRelatedPerson(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "RelatedPerson" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchRequestOrchestration(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.RequestOrchestration], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.RequestOrchestration]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for RequestOrchestration")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "RequestOrchestration", parameters, options)
	if err != nil {
		return search.Result[r5.RequestOrchestration]{}, err
	}
	resources := make([]r5.RequestOrchestration, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.RequestOrchestration)
		if !ok {
			return search.Result[r5.RequestOrchestration]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "RequestOrchestration" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.RequestOrchestration]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesRequestOrchestration(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "RequestOrchestration" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchRequirements(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Requirements], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Requirements]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Requirements")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Requirements", parameters, options)
	if err != nil {
		return search.Result[r5.Requirements]{}, err
	}
	resources := make([]r5.Requirements, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Requirements)
		if !ok {
			return search.Result[r5.Requirements]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Requirements" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Requirements]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesRequirements(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Requirements" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchResearchStudy(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.ResearchStudy], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.ResearchStudy]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for ResearchStudy")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "ResearchStudy", parameters, options)
	if err != nil {
		return search.Result[r5.ResearchStudy]{}, err
	}
	resources := make([]r5.ResearchStudy, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.ResearchStudy)
		if !ok {
			return search.Result[r5.ResearchStudy]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "ResearchStudy" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.ResearchStudy]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesResearchStudy(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "ResearchStudy" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchResearchSubject(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.ResearchSubject], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.ResearchSubject]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for ResearchSubject")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "ResearchSubject", parameters, options)
	if err != nil {
		return search.Result[r5.ResearchSubject]{}, err
	}
	resources := make([]r5.ResearchSubject, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.ResearchSubject)
		if !ok {
			return search.Result[r5.ResearchSubject]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "ResearchSubject" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.ResearchSubject]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesResearchSubject(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "ResearchSubject" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchRiskAssessment(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.RiskAssessment], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.RiskAssessment]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for RiskAssessment")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "RiskAssessment", parameters, options)
	if err != nil {
		return search.Result[r5.RiskAssessment]{}, err
	}
	resources := make([]r5.RiskAssessment, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.RiskAssessment)
		if !ok {
			return search.Result[r5.RiskAssessment]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "RiskAssessment" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.RiskAssessment]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesRiskAssessment(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "RiskAssessment" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchSchedule(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Schedule], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Schedule]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Schedule")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Schedule", parameters, options)
	if err != nil {
		return search.Result[r5.Schedule]{}, err
	}
	resources := make([]r5.Schedule, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Schedule)
		if !ok {
			return search.Result[r5.Schedule]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Schedule" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Schedule]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesSchedule(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Schedule" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchSearchParameter(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.SearchParameter], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.SearchParameter]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for SearchParameter")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "SearchParameter", parameters, options)
	if err != nil {
		return search.Result[r5.SearchParameter]{}, err
	}
	resources := make([]r5.SearchParameter, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.SearchParameter)
		if !ok {
			return search.Result[r5.SearchParameter]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "SearchParameter" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.SearchParameter]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesSearchParameter(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "SearchParameter" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchServiceRequest(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.ServiceRequest], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.ServiceRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for ServiceRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "ServiceRequest", parameters, options)
	if err != nil {
		return search.Result[r5.ServiceRequest]{}, err
	}
	resources := make([]r5.ServiceRequest, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.ServiceRequest)
		if !ok {
			return search.Result[r5.ServiceRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "ServiceRequest" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.ServiceRequest]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesServiceRequest(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "ServiceRequest" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchSlot(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Slot], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Slot]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Slot")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Slot", parameters, options)
	if err != nil {
		return search.Result[r5.Slot]{}, err
	}
	resources := make([]r5.Slot, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Slot)
		if !ok {
			return search.Result[r5.Slot]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Slot" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Slot]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesSlot(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Slot" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchSpecimen(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Specimen], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Specimen]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Specimen")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Specimen", parameters, options)
	if err != nil {
		return search.Result[r5.Specimen]{}, err
	}
	resources := make([]r5.Specimen, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Specimen)
		if !ok {
			return search.Result[r5.Specimen]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Specimen" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Specimen]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesSpecimen(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Specimen" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchSpecimenDefinition(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.SpecimenDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.SpecimenDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for SpecimenDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "SpecimenDefinition", parameters, options)
	if err != nil {
		return search.Result[r5.SpecimenDefinition]{}, err
	}
	resources := make([]r5.SpecimenDefinition, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.SpecimenDefinition)
		if !ok {
			return search.Result[r5.SpecimenDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "SpecimenDefinition" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.SpecimenDefinition]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesSpecimenDefinition(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "SpecimenDefinition" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchStructureDefinition(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.StructureDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.StructureDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for StructureDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "StructureDefinition", parameters, options)
	if err != nil {
		return search.Result[r5.StructureDefinition]{}, err
	}
	resources := make([]r5.StructureDefinition, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.StructureDefinition)
		if !ok {
			return search.Result[r5.StructureDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "StructureDefinition" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.StructureDefinition]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesStructureDefinition(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "StructureDefinition" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchStructureMap(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.StructureMap], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.StructureMap]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for StructureMap")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "StructureMap", parameters, options)
	if err != nil {
		return search.Result[r5.StructureMap]{}, err
	}
	resources := make([]r5.StructureMap, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.StructureMap)
		if !ok {
			return search.Result[r5.StructureMap]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "StructureMap" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.StructureMap]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesStructureMap(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "StructureMap" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchSubscription(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Subscription], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Subscription]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Subscription")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Subscription", parameters, options)
	if err != nil {
		return search.Result[r5.Subscription]{}, err
	}
	resources := make([]r5.Subscription, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Subscription)
		if !ok {
			return search.Result[r5.Subscription]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Subscription" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Subscription]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesSubscription(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Subscription" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchSubscriptionStatus(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.SubscriptionStatus], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.SubscriptionStatus]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for SubscriptionStatus")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "SubscriptionStatus", parameters, options)
	if err != nil {
		return search.Result[r5.SubscriptionStatus]{}, err
	}
	resources := make([]r5.SubscriptionStatus, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.SubscriptionStatus)
		if !ok {
			return search.Result[r5.SubscriptionStatus]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "SubscriptionStatus" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.SubscriptionStatus]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesSubscriptionStatus(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "SubscriptionStatus" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchSubscriptionTopic(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.SubscriptionTopic], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.SubscriptionTopic]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for SubscriptionTopic")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "SubscriptionTopic", parameters, options)
	if err != nil {
		return search.Result[r5.SubscriptionTopic]{}, err
	}
	resources := make([]r5.SubscriptionTopic, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.SubscriptionTopic)
		if !ok {
			return search.Result[r5.SubscriptionTopic]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "SubscriptionTopic" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.SubscriptionTopic]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesSubscriptionTopic(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "SubscriptionTopic" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchSubstance(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Substance], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Substance]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Substance")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Substance", parameters, options)
	if err != nil {
		return search.Result[r5.Substance]{}, err
	}
	resources := make([]r5.Substance, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Substance)
		if !ok {
			return search.Result[r5.Substance]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Substance" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Substance]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesSubstance(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Substance" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchSubstanceDefinition(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.SubstanceDefinition], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.SubstanceDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for SubstanceDefinition")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "SubstanceDefinition", parameters, options)
	if err != nil {
		return search.Result[r5.SubstanceDefinition]{}, err
	}
	resources := make([]r5.SubstanceDefinition, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.SubstanceDefinition)
		if !ok {
			return search.Result[r5.SubstanceDefinition]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "SubstanceDefinition" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.SubstanceDefinition]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesSubstanceDefinition(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "SubstanceDefinition" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchSubstanceNucleicAcid(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.SubstanceNucleicAcid], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.SubstanceNucleicAcid]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for SubstanceNucleicAcid")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "SubstanceNucleicAcid", parameters, options)
	if err != nil {
		return search.Result[r5.SubstanceNucleicAcid]{}, err
	}
	resources := make([]r5.SubstanceNucleicAcid, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.SubstanceNucleicAcid)
		if !ok {
			return search.Result[r5.SubstanceNucleicAcid]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "SubstanceNucleicAcid" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.SubstanceNucleicAcid]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesSubstanceNucleicAcid(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "SubstanceNucleicAcid" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchSubstancePolymer(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.SubstancePolymer], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.SubstancePolymer]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for SubstancePolymer")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "SubstancePolymer", parameters, options)
	if err != nil {
		return search.Result[r5.SubstancePolymer]{}, err
	}
	resources := make([]r5.SubstancePolymer, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.SubstancePolymer)
		if !ok {
			return search.Result[r5.SubstancePolymer]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "SubstancePolymer" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.SubstancePolymer]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesSubstancePolymer(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "SubstancePolymer" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchSubstanceProtein(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.SubstanceProtein], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.SubstanceProtein]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for SubstanceProtein")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "SubstanceProtein", parameters, options)
	if err != nil {
		return search.Result[r5.SubstanceProtein]{}, err
	}
	resources := make([]r5.SubstanceProtein, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.SubstanceProtein)
		if !ok {
			return search.Result[r5.SubstanceProtein]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "SubstanceProtein" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.SubstanceProtein]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesSubstanceProtein(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "SubstanceProtein" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchSubstanceReferenceInformation(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.SubstanceReferenceInformation], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.SubstanceReferenceInformation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for SubstanceReferenceInformation")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "SubstanceReferenceInformation", parameters, options)
	if err != nil {
		return search.Result[r5.SubstanceReferenceInformation]{}, err
	}
	resources := make([]r5.SubstanceReferenceInformation, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.SubstanceReferenceInformation)
		if !ok {
			return search.Result[r5.SubstanceReferenceInformation]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "SubstanceReferenceInformation" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.SubstanceReferenceInformation]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesSubstanceReferenceInformation(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "SubstanceReferenceInformation" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchSubstanceSourceMaterial(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.SubstanceSourceMaterial], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.SubstanceSourceMaterial]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for SubstanceSourceMaterial")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "SubstanceSourceMaterial", parameters, options)
	if err != nil {
		return search.Result[r5.SubstanceSourceMaterial]{}, err
	}
	resources := make([]r5.SubstanceSourceMaterial, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.SubstanceSourceMaterial)
		if !ok {
			return search.Result[r5.SubstanceSourceMaterial]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "SubstanceSourceMaterial" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.SubstanceSourceMaterial]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesSubstanceSourceMaterial(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "SubstanceSourceMaterial" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchSupplyDelivery(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.SupplyDelivery], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.SupplyDelivery]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for SupplyDelivery")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "SupplyDelivery", parameters, options)
	if err != nil {
		return search.Result[r5.SupplyDelivery]{}, err
	}
	resources := make([]r5.SupplyDelivery, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.SupplyDelivery)
		if !ok {
			return search.Result[r5.SupplyDelivery]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "SupplyDelivery" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.SupplyDelivery]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesSupplyDelivery(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "SupplyDelivery" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchSupplyRequest(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.SupplyRequest], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.SupplyRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for SupplyRequest")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "SupplyRequest", parameters, options)
	if err != nil {
		return search.Result[r5.SupplyRequest]{}, err
	}
	resources := make([]r5.SupplyRequest, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.SupplyRequest)
		if !ok {
			return search.Result[r5.SupplyRequest]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "SupplyRequest" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.SupplyRequest]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesSupplyRequest(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "SupplyRequest" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchTask(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Task], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Task]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Task")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Task", parameters, options)
	if err != nil {
		return search.Result[r5.Task]{}, err
	}
	resources := make([]r5.Task, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Task)
		if !ok {
			return search.Result[r5.Task]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Task" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Task]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesTask(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Task" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchTerminologyCapabilities(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.TerminologyCapabilities], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.TerminologyCapabilities]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for TerminologyCapabilities")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "TerminologyCapabilities", parameters, options)
	if err != nil {
		return search.Result[r5.TerminologyCapabilities]{}, err
	}
	resources := make([]r5.TerminologyCapabilities, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.TerminologyCapabilities)
		if !ok {
			return search.Result[r5.TerminologyCapabilities]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "TerminologyCapabilities" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.TerminologyCapabilities]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesTerminologyCapabilities(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "TerminologyCapabilities" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchTestPlan(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.TestPlan], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.TestPlan]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for TestPlan")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "TestPlan", parameters, options)
	if err != nil {
		return search.Result[r5.TestPlan]{}, err
	}
	resources := make([]r5.TestPlan, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.TestPlan)
		if !ok {
			return search.Result[r5.TestPlan]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "TestPlan" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.TestPlan]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesTestPlan(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "TestPlan" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchTestReport(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.TestReport], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.TestReport]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for TestReport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "TestReport", parameters, options)
	if err != nil {
		return search.Result[r5.TestReport]{}, err
	}
	resources := make([]r5.TestReport, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.TestReport)
		if !ok {
			return search.Result[r5.TestReport]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "TestReport" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.TestReport]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesTestReport(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "TestReport" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchTestScript(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.TestScript], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.TestScript]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for TestScript")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "TestScript", parameters, options)
	if err != nil {
		return search.Result[r5.TestScript]{}, err
	}
	resources := make([]r5.TestScript, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.TestScript)
		if !ok {
			return search.Result[r5.TestScript]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "TestScript" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.TestScript]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesTestScript(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "TestScript" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchTransport(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.Transport], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.Transport]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for Transport")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "Transport", parameters, options)
	if err != nil {
		return search.Result[r5.Transport]{}, err
	}
	resources := make([]r5.Transport, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.Transport)
		if !ok {
			return search.Result[r5.Transport]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "Transport" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.Transport]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesTransport(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "Transport" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchValueSet(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.ValueSet], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.ValueSet]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for ValueSet")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "ValueSet", parameters, options)
	if err != nil {
		return search.Result[r5.ValueSet]{}, err
	}
	resources := make([]r5.ValueSet, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.ValueSet)
		if !ok {
			return search.Result[r5.ValueSet]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "ValueSet" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.ValueSet]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesValueSet(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "ValueSet" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchVerificationResult(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.VerificationResult], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.VerificationResult]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for VerificationResult")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "VerificationResult", parameters, options)
	if err != nil {
		return search.Result[r5.VerificationResult]{}, err
	}
	resources := make([]r5.VerificationResult, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.VerificationResult)
		if !ok {
			return search.Result[r5.VerificationResult]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "VerificationResult" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.VerificationResult]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesVerificationResult(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "VerificationResult" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
func (w Concrete) SearchVisionPrescription(ctx context.Context, parameters search.Parameters, options search.Options) (search.Result[r5.VisionPrescription], error) {
	g, ok := w.Generic.(capabilities.GenericSearch)
	if !ok {
		return search.Result[r5.VisionPrescription]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
			Code:        r5.Code{Value: ptr.To("not-supported")},
			Diagnostics: &r5.String{Value: ptr.To("Search not implemented for VisionPrescription")},
			Severity:    r5.Code{Value: ptr.To("fatal")},
		}}}
	}
	result, err := g.Search(ctx, "VisionPrescription", parameters, options)
	if err != nil {
		return search.Result[r5.VisionPrescription]{}, err
	}
	resources := make([]r5.VisionPrescription, len(result.Resources))
	for i, v := range result.Resources {
		contained, ok := v.(r5.ContainedResource)
		if ok {
			v = contained.Resource
		}
		r, ok := v.(r5.VisionPrescription)
		if !ok {
			return search.Result[r5.VisionPrescription]{}, r5.OperationOutcome{Issue: []r5.OperationOutcomeIssue{{
				Code:        r5.Code{Value: ptr.To("processing")},
				Diagnostics: &r5.String{Value: ptr.To("expected " + "VisionPrescription" + " but got " + v.ResourceType())},
				Severity:    r5.Code{Value: ptr.To("fatal")},
			}}}
		}
		resources[i] = r
	}
	return search.Result[r5.VisionPrescription]{

		Included:  result.Included,
		Next:      result.Next,
		Resources: resources,
	}, nil
}
func (w Concrete) SearchCapabilitiesVisionPrescription(ctx context.Context) (r5.SearchCapabilities, error) {
	capabilityStatement, err := w.Generic.CapabilityStatement(ctx)
	if err != nil {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, err
	}
	cs, okCs := capabilityStatement.(r5.CapabilityStatement)
	if !okCs {
		return r5.SearchCapabilities{
			Includes:   []string{},
			Parameters: make(map[string]r5.SearchParameter),
		}, fmt.Errorf("CapabilityStatement type does not match release")
	}
	var searchParams []r5.CapabilityStatementRestResourceSearchParam
	for _, rest := range cs.Rest {
		for _, resource := range rest.Resource {
			if resource.Type.Value != nil && *resource.Type.Value == "VisionPrescription" {
				searchParams = resource.SearchParam
				break
			}
		}
	}
	parameters := make(map[string]r5.SearchParameter)
	for _, searchParam := range searchParams {
		if searchParam.Definition != nil && searchParam.Definition.Value != nil {
			canonicalUrl := *searchParam.Definition.Value
			lastSlash := strings.LastIndex(canonicalUrl, "/")
			if lastSlash != -1 && lastSlash < len(canonicalUrl)-1 {
				searchParamId := canonicalUrl[lastSlash+1:]
				readImpl, readOk := w.Generic.(capabilities.GenericRead)
				if readOk {
					searchParamResource, readErr := readImpl.Read(ctx, "SearchParameter", searchParamId)
					if readErr == nil {
						sp, ok := searchParamResource.(r5.SearchParameter)
						if ok {
							if sp.Code.Value != nil {
								parameters[*sp.Code.Value] = sp
							}
						}
					}
				}
			}
		}
	}
	return r5.SearchCapabilities{
		Includes:   []string{},
		Parameters: parameters,
	}, nil
}
