// DO NOT EDIT!
// Code generated by "github.com/damedic/fhir-toolbox-go/internal/generate";
// use `make generate` to regenerate.

// Package r4b contains FHIR R4B model types and search parameters.
package r4b

import search "github.com/damedic/fhir-toolbox-go/capabilities/search"

// Search parameter types and interfaces for typed search

// Search parameters use sealed interfaces that accept both typed values and search.String
// AccountParams contains typed search parameters for Account resources.
type AccountParams struct {
	// Account-specific search parameters
	Identifier search.TokenOrString     `json:"identifier,omitempty"`
	Name       search.StringOrString    `json:"name,omitempty"`
	Owner      search.ReferenceOrString `json:"owner,omitempty"`
	Patient    search.ReferenceOrString `json:"patient,omitempty"`
	Period     search.DateOrString      `json:"period,omitempty"`
	Status     search.TokenOrString     `json:"status,omitempty"`
	Subject    search.ReferenceOrString `json:"subject,omitempty"`
	Type       search.TokenOrString     `json:"type,omitempty"`
}

// Map implements the search.Parameters interface for AccountParams.
func (p AccountParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Owner != nil {
		m[search.ParameterKey{Name: "owner"}] = p.Owner.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Period != nil {
		m[search.ParameterKey{Name: "period"}] = p.Period.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}

	return m
}

// ActivityDefinitionParams contains typed search parameters for ActivityDefinition resources.
type ActivityDefinitionParams struct {
	// ActivityDefinition-specific search parameters
	ComposedOf          search.ReferenceOrString `json:"composed-of,omitempty"`
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Date                search.DateOrString      `json:"date,omitempty"`
	DependsOn           search.ReferenceOrString `json:"depends-on,omitempty"`
	DerivedFrom         search.ReferenceOrString `json:"derived-from,omitempty"`
	Description         search.StringOrString    `json:"description,omitempty"`
	Effective           search.DateOrString      `json:"effective,omitempty"`
	Identifier          search.TokenOrString     `json:"identifier,omitempty"`
	Jurisdiction        search.TokenOrString     `json:"jurisdiction,omitempty"`
	Name                search.StringOrString    `json:"name,omitempty"`
	Predecessor         search.ReferenceOrString `json:"predecessor,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	Successor           search.ReferenceOrString `json:"successor,omitempty"`
	Title               search.StringOrString    `json:"title,omitempty"`
	Topic               search.TokenOrString     `json:"topic,omitempty"`
	Url                 search.UriOrString       `json:"url,omitempty"`
	Version             search.TokenOrString     `json:"version,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
}

// Map implements the search.Parameters interface for ActivityDefinitionParams.
func (p ActivityDefinitionParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.ComposedOf != nil {
		m[search.ParameterKey{Name: "composed-of"}] = p.ComposedOf.MatchesAll()
	}
	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.DependsOn != nil {
		m[search.ParameterKey{Name: "depends-on"}] = p.DependsOn.MatchesAll()
	}
	if p.DerivedFrom != nil {
		m[search.ParameterKey{Name: "derived-from"}] = p.DerivedFrom.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Effective != nil {
		m[search.ParameterKey{Name: "effective"}] = p.Effective.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Jurisdiction != nil {
		m[search.ParameterKey{Name: "jurisdiction"}] = p.Jurisdiction.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Predecessor != nil {
		m[search.ParameterKey{Name: "predecessor"}] = p.Predecessor.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Successor != nil {
		m[search.ParameterKey{Name: "successor"}] = p.Successor.MatchesAll()
	}
	if p.Title != nil {
		m[search.ParameterKey{Name: "title"}] = p.Title.MatchesAll()
	}
	if p.Topic != nil {
		m[search.ParameterKey{Name: "topic"}] = p.Topic.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}

	return m
}

// AdministrableProductDefinitionParams contains typed search parameters for AdministrableProductDefinition resources.
type AdministrableProductDefinitionParams struct {
	// AdministrableProductDefinition-specific search parameters
	Device           search.ReferenceOrString `json:"device,omitempty"`
	DoseForm         search.TokenOrString     `json:"dose-form,omitempty"`
	FormOf           search.ReferenceOrString `json:"form-of,omitempty"`
	Identifier       search.TokenOrString     `json:"identifier,omitempty"`
	Ingredient       search.TokenOrString     `json:"ingredient,omitempty"`
	ManufacturedItem search.ReferenceOrString `json:"manufactured-item,omitempty"`
	Route            search.TokenOrString     `json:"route,omitempty"`
	TargetSpecies    search.TokenOrString     `json:"target-species,omitempty"`
}

// Map implements the search.Parameters interface for AdministrableProductDefinitionParams.
func (p AdministrableProductDefinitionParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Device != nil {
		m[search.ParameterKey{Name: "device"}] = p.Device.MatchesAll()
	}
	if p.DoseForm != nil {
		m[search.ParameterKey{Name: "dose-form"}] = p.DoseForm.MatchesAll()
	}
	if p.FormOf != nil {
		m[search.ParameterKey{Name: "form-of"}] = p.FormOf.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Ingredient != nil {
		m[search.ParameterKey{Name: "ingredient"}] = p.Ingredient.MatchesAll()
	}
	if p.ManufacturedItem != nil {
		m[search.ParameterKey{Name: "manufactured-item"}] = p.ManufacturedItem.MatchesAll()
	}
	if p.Route != nil {
		m[search.ParameterKey{Name: "route"}] = p.Route.MatchesAll()
	}
	if p.TargetSpecies != nil {
		m[search.ParameterKey{Name: "target-species"}] = p.TargetSpecies.MatchesAll()
	}

	return m
}

// AdverseEventParams contains typed search parameters for AdverseEvent resources.
type AdverseEventParams struct {
	// AdverseEvent-specific search parameters
	Actuality          search.TokenOrString     `json:"actuality,omitempty"`
	Category           search.TokenOrString     `json:"category,omitempty"`
	Date               search.DateOrString      `json:"date,omitempty"`
	Event              search.TokenOrString     `json:"event,omitempty"`
	Location           search.ReferenceOrString `json:"location,omitempty"`
	Recorder           search.ReferenceOrString `json:"recorder,omitempty"`
	Resultingcondition search.ReferenceOrString `json:"resultingcondition,omitempty"`
	Seriousness        search.TokenOrString     `json:"seriousness,omitempty"`
	Severity           search.TokenOrString     `json:"severity,omitempty"`
	Study              search.ReferenceOrString `json:"study,omitempty"`
	Subject            search.ReferenceOrString `json:"subject,omitempty"`
	Substance          search.ReferenceOrString `json:"substance,omitempty"`
}

// Map implements the search.Parameters interface for AdverseEventParams.
func (p AdverseEventParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Actuality != nil {
		m[search.ParameterKey{Name: "actuality"}] = p.Actuality.MatchesAll()
	}
	if p.Category != nil {
		m[search.ParameterKey{Name: "category"}] = p.Category.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Event != nil {
		m[search.ParameterKey{Name: "event"}] = p.Event.MatchesAll()
	}
	if p.Location != nil {
		m[search.ParameterKey{Name: "location"}] = p.Location.MatchesAll()
	}
	if p.Recorder != nil {
		m[search.ParameterKey{Name: "recorder"}] = p.Recorder.MatchesAll()
	}
	if p.Resultingcondition != nil {
		m[search.ParameterKey{Name: "resultingcondition"}] = p.Resultingcondition.MatchesAll()
	}
	if p.Seriousness != nil {
		m[search.ParameterKey{Name: "seriousness"}] = p.Seriousness.MatchesAll()
	}
	if p.Severity != nil {
		m[search.ParameterKey{Name: "severity"}] = p.Severity.MatchesAll()
	}
	if p.Study != nil {
		m[search.ParameterKey{Name: "study"}] = p.Study.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}
	if p.Substance != nil {
		m[search.ParameterKey{Name: "substance"}] = p.Substance.MatchesAll()
	}

	return m
}

// AllergyIntoleranceParams contains typed search parameters for AllergyIntolerance resources.
type AllergyIntoleranceParams struct {
	// AllergyIntolerance-specific search parameters
	Asserter           search.ReferenceOrString `json:"asserter,omitempty"`
	Category           search.TokenOrString     `json:"category,omitempty"`
	ClinicalStatus     search.TokenOrString     `json:"clinical-status,omitempty"`
	Code               search.TokenOrString     `json:"code,omitempty"`
	Criticality        search.TokenOrString     `json:"criticality,omitempty"`
	Date               search.DateOrString      `json:"date,omitempty"`
	Identifier         search.TokenOrString     `json:"identifier,omitempty"`
	LastDate           search.DateOrString      `json:"last-date,omitempty"`
	Manifestation      search.TokenOrString     `json:"manifestation,omitempty"`
	Onset              search.DateOrString      `json:"onset,omitempty"`
	Patient            search.ReferenceOrString `json:"patient,omitempty"`
	Recorder           search.ReferenceOrString `json:"recorder,omitempty"`
	Route              search.TokenOrString     `json:"route,omitempty"`
	Severity           search.TokenOrString     `json:"severity,omitempty"`
	Type               search.TokenOrString     `json:"type,omitempty"`
	VerificationStatus search.TokenOrString     `json:"verification-status,omitempty"`
}

// Map implements the search.Parameters interface for AllergyIntoleranceParams.
func (p AllergyIntoleranceParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Asserter != nil {
		m[search.ParameterKey{Name: "asserter"}] = p.Asserter.MatchesAll()
	}
	if p.Category != nil {
		m[search.ParameterKey{Name: "category"}] = p.Category.MatchesAll()
	}
	if p.ClinicalStatus != nil {
		m[search.ParameterKey{Name: "clinical-status"}] = p.ClinicalStatus.MatchesAll()
	}
	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.Criticality != nil {
		m[search.ParameterKey{Name: "criticality"}] = p.Criticality.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.LastDate != nil {
		m[search.ParameterKey{Name: "last-date"}] = p.LastDate.MatchesAll()
	}
	if p.Manifestation != nil {
		m[search.ParameterKey{Name: "manifestation"}] = p.Manifestation.MatchesAll()
	}
	if p.Onset != nil {
		m[search.ParameterKey{Name: "onset"}] = p.Onset.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Recorder != nil {
		m[search.ParameterKey{Name: "recorder"}] = p.Recorder.MatchesAll()
	}
	if p.Route != nil {
		m[search.ParameterKey{Name: "route"}] = p.Route.MatchesAll()
	}
	if p.Severity != nil {
		m[search.ParameterKey{Name: "severity"}] = p.Severity.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}
	if p.VerificationStatus != nil {
		m[search.ParameterKey{Name: "verification-status"}] = p.VerificationStatus.MatchesAll()
	}

	return m
}

// AppointmentParams contains typed search parameters for Appointment resources.
type AppointmentParams struct {
	// Appointment-specific search parameters
	Actor           search.ReferenceOrString `json:"actor,omitempty"`
	AppointmentType search.TokenOrString     `json:"appointment-type,omitempty"`
	BasedOn         search.ReferenceOrString `json:"based-on,omitempty"`
	Date            search.DateOrString      `json:"date,omitempty"`
	Identifier      search.TokenOrString     `json:"identifier,omitempty"`
	Location        search.ReferenceOrString `json:"location,omitempty"`
	PartStatus      search.TokenOrString     `json:"part-status,omitempty"`
	Patient         search.ReferenceOrString `json:"patient,omitempty"`
	Practitioner    search.ReferenceOrString `json:"practitioner,omitempty"`
	ReasonCode      search.TokenOrString     `json:"reason-code,omitempty"`
	ReasonReference search.ReferenceOrString `json:"reason-reference,omitempty"`
	ServiceCategory search.TokenOrString     `json:"service-category,omitempty"`
	ServiceType     search.TokenOrString     `json:"service-type,omitempty"`
	Slot            search.ReferenceOrString `json:"slot,omitempty"`
	Specialty       search.TokenOrString     `json:"specialty,omitempty"`
	Status          search.TokenOrString     `json:"status,omitempty"`
	SupportingInfo  search.ReferenceOrString `json:"supporting-info,omitempty"`
}

// Map implements the search.Parameters interface for AppointmentParams.
func (p AppointmentParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Actor != nil {
		m[search.ParameterKey{Name: "actor"}] = p.Actor.MatchesAll()
	}
	if p.AppointmentType != nil {
		m[search.ParameterKey{Name: "appointment-type"}] = p.AppointmentType.MatchesAll()
	}
	if p.BasedOn != nil {
		m[search.ParameterKey{Name: "based-on"}] = p.BasedOn.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Location != nil {
		m[search.ParameterKey{Name: "location"}] = p.Location.MatchesAll()
	}
	if p.PartStatus != nil {
		m[search.ParameterKey{Name: "part-status"}] = p.PartStatus.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Practitioner != nil {
		m[search.ParameterKey{Name: "practitioner"}] = p.Practitioner.MatchesAll()
	}
	if p.ReasonCode != nil {
		m[search.ParameterKey{Name: "reason-code"}] = p.ReasonCode.MatchesAll()
	}
	if p.ReasonReference != nil {
		m[search.ParameterKey{Name: "reason-reference"}] = p.ReasonReference.MatchesAll()
	}
	if p.ServiceCategory != nil {
		m[search.ParameterKey{Name: "service-category"}] = p.ServiceCategory.MatchesAll()
	}
	if p.ServiceType != nil {
		m[search.ParameterKey{Name: "service-type"}] = p.ServiceType.MatchesAll()
	}
	if p.Slot != nil {
		m[search.ParameterKey{Name: "slot"}] = p.Slot.MatchesAll()
	}
	if p.Specialty != nil {
		m[search.ParameterKey{Name: "specialty"}] = p.Specialty.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.SupportingInfo != nil {
		m[search.ParameterKey{Name: "supporting-info"}] = p.SupportingInfo.MatchesAll()
	}

	return m
}

// AppointmentResponseParams contains typed search parameters for AppointmentResponse resources.
type AppointmentResponseParams struct {
	// AppointmentResponse-specific search parameters
	Actor        search.ReferenceOrString `json:"actor,omitempty"`
	Appointment  search.ReferenceOrString `json:"appointment,omitempty"`
	Identifier   search.TokenOrString     `json:"identifier,omitempty"`
	Location     search.ReferenceOrString `json:"location,omitempty"`
	PartStatus   search.TokenOrString     `json:"part-status,omitempty"`
	Patient      search.ReferenceOrString `json:"patient,omitempty"`
	Practitioner search.ReferenceOrString `json:"practitioner,omitempty"`
}

// Map implements the search.Parameters interface for AppointmentResponseParams.
func (p AppointmentResponseParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Actor != nil {
		m[search.ParameterKey{Name: "actor"}] = p.Actor.MatchesAll()
	}
	if p.Appointment != nil {
		m[search.ParameterKey{Name: "appointment"}] = p.Appointment.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Location != nil {
		m[search.ParameterKey{Name: "location"}] = p.Location.MatchesAll()
	}
	if p.PartStatus != nil {
		m[search.ParameterKey{Name: "part-status"}] = p.PartStatus.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Practitioner != nil {
		m[search.ParameterKey{Name: "practitioner"}] = p.Practitioner.MatchesAll()
	}

	return m
}

// AuditEventParams contains typed search parameters for AuditEvent resources.
type AuditEventParams struct {
	// AuditEvent-specific search parameters
	Action     search.TokenOrString     `json:"action,omitempty"`
	Address    search.StringOrString    `json:"address,omitempty"`
	Agent      search.ReferenceOrString `json:"agent,omitempty"`
	AgentName  search.StringOrString    `json:"agent-name,omitempty"`
	AgentRole  search.TokenOrString     `json:"agent-role,omitempty"`
	Altid      search.TokenOrString     `json:"altid,omitempty"`
	Date       search.DateOrString      `json:"date,omitempty"`
	Entity     search.ReferenceOrString `json:"entity,omitempty"`
	EntityName search.StringOrString    `json:"entity-name,omitempty"`
	EntityRole search.TokenOrString     `json:"entity-role,omitempty"`
	EntityType search.TokenOrString     `json:"entity-type,omitempty"`
	Outcome    search.TokenOrString     `json:"outcome,omitempty"`
	Patient    search.ReferenceOrString `json:"patient,omitempty"`
	Policy     search.UriOrString       `json:"policy,omitempty"`
	Site       search.TokenOrString     `json:"site,omitempty"`
	Source     search.ReferenceOrString `json:"source,omitempty"`
	Subtype    search.TokenOrString     `json:"subtype,omitempty"`
	Type       search.TokenOrString     `json:"type,omitempty"`
}

// Map implements the search.Parameters interface for AuditEventParams.
func (p AuditEventParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Action != nil {
		m[search.ParameterKey{Name: "action"}] = p.Action.MatchesAll()
	}
	if p.Address != nil {
		m[search.ParameterKey{Name: "address"}] = p.Address.MatchesAll()
	}
	if p.Agent != nil {
		m[search.ParameterKey{Name: "agent"}] = p.Agent.MatchesAll()
	}
	if p.AgentName != nil {
		m[search.ParameterKey{Name: "agent-name"}] = p.AgentName.MatchesAll()
	}
	if p.AgentRole != nil {
		m[search.ParameterKey{Name: "agent-role"}] = p.AgentRole.MatchesAll()
	}
	if p.Altid != nil {
		m[search.ParameterKey{Name: "altid"}] = p.Altid.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Entity != nil {
		m[search.ParameterKey{Name: "entity"}] = p.Entity.MatchesAll()
	}
	if p.EntityName != nil {
		m[search.ParameterKey{Name: "entity-name"}] = p.EntityName.MatchesAll()
	}
	if p.EntityRole != nil {
		m[search.ParameterKey{Name: "entity-role"}] = p.EntityRole.MatchesAll()
	}
	if p.EntityType != nil {
		m[search.ParameterKey{Name: "entity-type"}] = p.EntityType.MatchesAll()
	}
	if p.Outcome != nil {
		m[search.ParameterKey{Name: "outcome"}] = p.Outcome.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Policy != nil {
		m[search.ParameterKey{Name: "policy"}] = p.Policy.MatchesAll()
	}
	if p.Site != nil {
		m[search.ParameterKey{Name: "site"}] = p.Site.MatchesAll()
	}
	if p.Source != nil {
		m[search.ParameterKey{Name: "source"}] = p.Source.MatchesAll()
	}
	if p.Subtype != nil {
		m[search.ParameterKey{Name: "subtype"}] = p.Subtype.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}

	return m
}

// BasicParams contains typed search parameters for Basic resources.
type BasicParams struct {
	// Basic-specific search parameters
	Author     search.ReferenceOrString `json:"author,omitempty"`
	Code       search.TokenOrString     `json:"code,omitempty"`
	Created    search.DateOrString      `json:"created,omitempty"`
	Identifier search.TokenOrString     `json:"identifier,omitempty"`
	Patient    search.ReferenceOrString `json:"patient,omitempty"`
	Subject    search.ReferenceOrString `json:"subject,omitempty"`
}

// Map implements the search.Parameters interface for BasicParams.
func (p BasicParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Author != nil {
		m[search.ParameterKey{Name: "author"}] = p.Author.MatchesAll()
	}
	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.Created != nil {
		m[search.ParameterKey{Name: "created"}] = p.Created.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}

	return m
}

// BinaryParams contains typed search parameters for Binary resources.
type BinaryParams struct{}

// Map implements the search.Parameters interface for BinaryParams.
func (p BinaryParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	return m
}

// BiologicallyDerivedProductParams contains typed search parameters for BiologicallyDerivedProduct resources.
type BiologicallyDerivedProductParams struct{}

// Map implements the search.Parameters interface for BiologicallyDerivedProductParams.
func (p BiologicallyDerivedProductParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	return m
}

// BodyStructureParams contains typed search parameters for BodyStructure resources.
type BodyStructureParams struct {
	// BodyStructure-specific search parameters
	Identifier search.TokenOrString     `json:"identifier,omitempty"`
	Location   search.TokenOrString     `json:"location,omitempty"`
	Morphology search.TokenOrString     `json:"morphology,omitempty"`
	Patient    search.ReferenceOrString `json:"patient,omitempty"`
}

// Map implements the search.Parameters interface for BodyStructureParams.
func (p BodyStructureParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Location != nil {
		m[search.ParameterKey{Name: "location"}] = p.Location.MatchesAll()
	}
	if p.Morphology != nil {
		m[search.ParameterKey{Name: "morphology"}] = p.Morphology.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}

	return m
}

// BundleParams contains typed search parameters for Bundle resources.
type BundleParams struct {
	// Bundle-specific search parameters
	Composition search.ReferenceOrString `json:"composition,omitempty"`
	Identifier  search.TokenOrString     `json:"identifier,omitempty"`
	Message     search.ReferenceOrString `json:"message,omitempty"`
	Timestamp   search.DateOrString      `json:"timestamp,omitempty"`
	Type        search.TokenOrString     `json:"type,omitempty"`
}

// Map implements the search.Parameters interface for BundleParams.
func (p BundleParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Composition != nil {
		m[search.ParameterKey{Name: "composition"}] = p.Composition.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Message != nil {
		m[search.ParameterKey{Name: "message"}] = p.Message.MatchesAll()
	}
	if p.Timestamp != nil {
		m[search.ParameterKey{Name: "timestamp"}] = p.Timestamp.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}

	return m
}

// CapabilityStatementParams contains typed search parameters for CapabilityStatement resources.
type CapabilityStatementParams struct {
	// CapabilityStatement-specific search parameters
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Date                search.DateOrString      `json:"date,omitempty"`
	Description         search.StringOrString    `json:"description,omitempty"`
	Fhirversion         search.TokenOrString     `json:"fhirversion,omitempty"`
	Format              search.TokenOrString     `json:"format,omitempty"`
	Guide               search.ReferenceOrString `json:"guide,omitempty"`
	Jurisdiction        search.TokenOrString     `json:"jurisdiction,omitempty"`
	Mode                search.TokenOrString     `json:"mode,omitempty"`
	Name                search.StringOrString    `json:"name,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Resource            search.TokenOrString     `json:"resource,omitempty"`
	ResourceProfile     search.ReferenceOrString `json:"resource-profile,omitempty"`
	SecurityService     search.TokenOrString     `json:"security-service,omitempty"`
	Software            search.StringOrString    `json:"software,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	SupportedProfile    search.ReferenceOrString `json:"supported-profile,omitempty"`
	Title               search.StringOrString    `json:"title,omitempty"`
	Url                 search.UriOrString       `json:"url,omitempty"`
	Version             search.TokenOrString     `json:"version,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
}

// Map implements the search.Parameters interface for CapabilityStatementParams.
func (p CapabilityStatementParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Fhirversion != nil {
		m[search.ParameterKey{Name: "fhirversion"}] = p.Fhirversion.MatchesAll()
	}
	if p.Format != nil {
		m[search.ParameterKey{Name: "format"}] = p.Format.MatchesAll()
	}
	if p.Guide != nil {
		m[search.ParameterKey{Name: "guide"}] = p.Guide.MatchesAll()
	}
	if p.Jurisdiction != nil {
		m[search.ParameterKey{Name: "jurisdiction"}] = p.Jurisdiction.MatchesAll()
	}
	if p.Mode != nil {
		m[search.ParameterKey{Name: "mode"}] = p.Mode.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Resource != nil {
		m[search.ParameterKey{Name: "resource"}] = p.Resource.MatchesAll()
	}
	if p.ResourceProfile != nil {
		m[search.ParameterKey{Name: "resource-profile"}] = p.ResourceProfile.MatchesAll()
	}
	if p.SecurityService != nil {
		m[search.ParameterKey{Name: "security-service"}] = p.SecurityService.MatchesAll()
	}
	if p.Software != nil {
		m[search.ParameterKey{Name: "software"}] = p.Software.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.SupportedProfile != nil {
		m[search.ParameterKey{Name: "supported-profile"}] = p.SupportedProfile.MatchesAll()
	}
	if p.Title != nil {
		m[search.ParameterKey{Name: "title"}] = p.Title.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}

	return m
}

// CarePlanParams contains typed search parameters for CarePlan resources.
type CarePlanParams struct {
	// CarePlan-specific search parameters
	Date                  search.DateOrString      `json:"date,omitempty"`
	Identifier            search.TokenOrString     `json:"identifier,omitempty"`
	Patient               search.ReferenceOrString `json:"patient,omitempty"`
	ActivityCode          search.TokenOrString     `json:"activity-code,omitempty"`
	ActivityDate          search.DateOrString      `json:"activity-date,omitempty"`
	ActivityReference     search.ReferenceOrString `json:"activity-reference,omitempty"`
	BasedOn               search.ReferenceOrString `json:"based-on,omitempty"`
	CareTeam              search.ReferenceOrString `json:"care-team,omitempty"`
	Category              search.TokenOrString     `json:"category,omitempty"`
	Condition             search.ReferenceOrString `json:"condition,omitempty"`
	Encounter             search.ReferenceOrString `json:"encounter,omitempty"`
	Goal                  search.ReferenceOrString `json:"goal,omitempty"`
	InstantiatesCanonical search.ReferenceOrString `json:"instantiates-canonical,omitempty"`
	InstantiatesUri       search.UriOrString       `json:"instantiates-uri,omitempty"`
	Intent                search.TokenOrString     `json:"intent,omitempty"`
	PartOf                search.ReferenceOrString `json:"part-of,omitempty"`
	Performer             search.ReferenceOrString `json:"performer,omitempty"`
	Replaces              search.ReferenceOrString `json:"replaces,omitempty"`
	Status                search.TokenOrString     `json:"status,omitempty"`
	Subject               search.ReferenceOrString `json:"subject,omitempty"`
}

// Map implements the search.Parameters interface for CarePlanParams.
func (p CarePlanParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.ActivityCode != nil {
		m[search.ParameterKey{Name: "activity-code"}] = p.ActivityCode.MatchesAll()
	}
	if p.ActivityDate != nil {
		m[search.ParameterKey{Name: "activity-date"}] = p.ActivityDate.MatchesAll()
	}
	if p.ActivityReference != nil {
		m[search.ParameterKey{Name: "activity-reference"}] = p.ActivityReference.MatchesAll()
	}
	if p.BasedOn != nil {
		m[search.ParameterKey{Name: "based-on"}] = p.BasedOn.MatchesAll()
	}
	if p.CareTeam != nil {
		m[search.ParameterKey{Name: "care-team"}] = p.CareTeam.MatchesAll()
	}
	if p.Category != nil {
		m[search.ParameterKey{Name: "category"}] = p.Category.MatchesAll()
	}
	if p.Condition != nil {
		m[search.ParameterKey{Name: "condition"}] = p.Condition.MatchesAll()
	}
	if p.Encounter != nil {
		m[search.ParameterKey{Name: "encounter"}] = p.Encounter.MatchesAll()
	}
	if p.Goal != nil {
		m[search.ParameterKey{Name: "goal"}] = p.Goal.MatchesAll()
	}
	if p.InstantiatesCanonical != nil {
		m[search.ParameterKey{Name: "instantiates-canonical"}] = p.InstantiatesCanonical.MatchesAll()
	}
	if p.InstantiatesUri != nil {
		m[search.ParameterKey{Name: "instantiates-uri"}] = p.InstantiatesUri.MatchesAll()
	}
	if p.Intent != nil {
		m[search.ParameterKey{Name: "intent"}] = p.Intent.MatchesAll()
	}
	if p.PartOf != nil {
		m[search.ParameterKey{Name: "part-of"}] = p.PartOf.MatchesAll()
	}
	if p.Performer != nil {
		m[search.ParameterKey{Name: "performer"}] = p.Performer.MatchesAll()
	}
	if p.Replaces != nil {
		m[search.ParameterKey{Name: "replaces"}] = p.Replaces.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}

	return m
}

// CareTeamParams contains typed search parameters for CareTeam resources.
type CareTeamParams struct {
	// CareTeam-specific search parameters
	Date        search.DateOrString      `json:"date,omitempty"`
	Identifier  search.TokenOrString     `json:"identifier,omitempty"`
	Patient     search.ReferenceOrString `json:"patient,omitempty"`
	Category    search.TokenOrString     `json:"category,omitempty"`
	Encounter   search.ReferenceOrString `json:"encounter,omitempty"`
	Participant search.ReferenceOrString `json:"participant,omitempty"`
	Status      search.TokenOrString     `json:"status,omitempty"`
	Subject     search.ReferenceOrString `json:"subject,omitempty"`
}

// Map implements the search.Parameters interface for CareTeamParams.
func (p CareTeamParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Category != nil {
		m[search.ParameterKey{Name: "category"}] = p.Category.MatchesAll()
	}
	if p.Encounter != nil {
		m[search.ParameterKey{Name: "encounter"}] = p.Encounter.MatchesAll()
	}
	if p.Participant != nil {
		m[search.ParameterKey{Name: "participant"}] = p.Participant.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}

	return m
}

// CatalogEntryParams contains typed search parameters for CatalogEntry resources.
type CatalogEntryParams struct{}

// Map implements the search.Parameters interface for CatalogEntryParams.
func (p CatalogEntryParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	return m
}

// ChargeItemParams contains typed search parameters for ChargeItem resources.
type ChargeItemParams struct {
	// ChargeItem-specific search parameters
	Account                search.ReferenceOrString `json:"account,omitempty"`
	Code                   search.TokenOrString     `json:"code,omitempty"`
	Context                search.ReferenceOrString `json:"context,omitempty"`
	EnteredDate            search.DateOrString      `json:"entered-date,omitempty"`
	Enterer                search.ReferenceOrString `json:"enterer,omitempty"`
	FactorOverride         search.NumberOrString    `json:"factor-override,omitempty"`
	Identifier             search.TokenOrString     `json:"identifier,omitempty"`
	Occurrence             search.DateOrString      `json:"occurrence,omitempty"`
	Patient                search.ReferenceOrString `json:"patient,omitempty"`
	PerformerActor         search.ReferenceOrString `json:"performer-actor,omitempty"`
	PerformerFunction      search.TokenOrString     `json:"performer-function,omitempty"`
	PerformingOrganization search.ReferenceOrString `json:"performing-organization,omitempty"`
	PriceOverride          search.QuantityOrString  `json:"price-override,omitempty"`
	Quantity               search.QuantityOrString  `json:"quantity,omitempty"`
	RequestingOrganization search.ReferenceOrString `json:"requesting-organization,omitempty"`
	Service                search.ReferenceOrString `json:"service,omitempty"`
	Subject                search.ReferenceOrString `json:"subject,omitempty"`
}

// Map implements the search.Parameters interface for ChargeItemParams.
func (p ChargeItemParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Account != nil {
		m[search.ParameterKey{Name: "account"}] = p.Account.MatchesAll()
	}
	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.EnteredDate != nil {
		m[search.ParameterKey{Name: "entered-date"}] = p.EnteredDate.MatchesAll()
	}
	if p.Enterer != nil {
		m[search.ParameterKey{Name: "enterer"}] = p.Enterer.MatchesAll()
	}
	if p.FactorOverride != nil {
		m[search.ParameterKey{Name: "factor-override"}] = p.FactorOverride.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Occurrence != nil {
		m[search.ParameterKey{Name: "occurrence"}] = p.Occurrence.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.PerformerActor != nil {
		m[search.ParameterKey{Name: "performer-actor"}] = p.PerformerActor.MatchesAll()
	}
	if p.PerformerFunction != nil {
		m[search.ParameterKey{Name: "performer-function"}] = p.PerformerFunction.MatchesAll()
	}
	if p.PerformingOrganization != nil {
		m[search.ParameterKey{Name: "performing-organization"}] = p.PerformingOrganization.MatchesAll()
	}
	if p.PriceOverride != nil {
		m[search.ParameterKey{Name: "price-override"}] = p.PriceOverride.MatchesAll()
	}
	if p.Quantity != nil {
		m[search.ParameterKey{Name: "quantity"}] = p.Quantity.MatchesAll()
	}
	if p.RequestingOrganization != nil {
		m[search.ParameterKey{Name: "requesting-organization"}] = p.RequestingOrganization.MatchesAll()
	}
	if p.Service != nil {
		m[search.ParameterKey{Name: "service"}] = p.Service.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}

	return m
}

// ChargeItemDefinitionParams contains typed search parameters for ChargeItemDefinition resources.
type ChargeItemDefinitionParams struct {
	// ChargeItemDefinition-specific search parameters
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Date                search.DateOrString      `json:"date,omitempty"`
	Description         search.StringOrString    `json:"description,omitempty"`
	Effective           search.DateOrString      `json:"effective,omitempty"`
	Identifier          search.TokenOrString     `json:"identifier,omitempty"`
	Jurisdiction        search.TokenOrString     `json:"jurisdiction,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	Title               search.StringOrString    `json:"title,omitempty"`
	Url                 search.UriOrString       `json:"url,omitempty"`
	Version             search.TokenOrString     `json:"version,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
}

// Map implements the search.Parameters interface for ChargeItemDefinitionParams.
func (p ChargeItemDefinitionParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Effective != nil {
		m[search.ParameterKey{Name: "effective"}] = p.Effective.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Jurisdiction != nil {
		m[search.ParameterKey{Name: "jurisdiction"}] = p.Jurisdiction.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Title != nil {
		m[search.ParameterKey{Name: "title"}] = p.Title.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}

	return m
}

// CitationParams contains typed search parameters for Citation resources.
type CitationParams struct {
	// Citation-specific search parameters
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Date                search.DateOrString      `json:"date,omitempty"`
	Description         search.StringOrString    `json:"description,omitempty"`
	Effective           search.DateOrString      `json:"effective,omitempty"`
	Identifier          search.TokenOrString     `json:"identifier,omitempty"`
	Jurisdiction        search.TokenOrString     `json:"jurisdiction,omitempty"`
	Name                search.StringOrString    `json:"name,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	Title               search.StringOrString    `json:"title,omitempty"`
	Url                 search.UriOrString       `json:"url,omitempty"`
	Version             search.TokenOrString     `json:"version,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
}

// Map implements the search.Parameters interface for CitationParams.
func (p CitationParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Effective != nil {
		m[search.ParameterKey{Name: "effective"}] = p.Effective.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Jurisdiction != nil {
		m[search.ParameterKey{Name: "jurisdiction"}] = p.Jurisdiction.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Title != nil {
		m[search.ParameterKey{Name: "title"}] = p.Title.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}

	return m
}

// ClaimParams contains typed search parameters for Claim resources.
type ClaimParams struct {
	// Claim-specific search parameters
	CareTeam     search.ReferenceOrString `json:"care-team,omitempty"`
	Created      search.DateOrString      `json:"created,omitempty"`
	DetailUdi    search.ReferenceOrString `json:"detail-udi,omitempty"`
	Encounter    search.ReferenceOrString `json:"encounter,omitempty"`
	Enterer      search.ReferenceOrString `json:"enterer,omitempty"`
	Facility     search.ReferenceOrString `json:"facility,omitempty"`
	Identifier   search.TokenOrString     `json:"identifier,omitempty"`
	Insurer      search.ReferenceOrString `json:"insurer,omitempty"`
	ItemUdi      search.ReferenceOrString `json:"item-udi,omitempty"`
	Patient      search.ReferenceOrString `json:"patient,omitempty"`
	Payee        search.ReferenceOrString `json:"payee,omitempty"`
	Priority     search.TokenOrString     `json:"priority,omitempty"`
	ProcedureUdi search.ReferenceOrString `json:"procedure-udi,omitempty"`
	Provider     search.ReferenceOrString `json:"provider,omitempty"`
	Status       search.TokenOrString     `json:"status,omitempty"`
	SubdetailUdi search.ReferenceOrString `json:"subdetail-udi,omitempty"`
	Use          search.TokenOrString     `json:"use,omitempty"`
}

// Map implements the search.Parameters interface for ClaimParams.
func (p ClaimParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.CareTeam != nil {
		m[search.ParameterKey{Name: "care-team"}] = p.CareTeam.MatchesAll()
	}
	if p.Created != nil {
		m[search.ParameterKey{Name: "created"}] = p.Created.MatchesAll()
	}
	if p.DetailUdi != nil {
		m[search.ParameterKey{Name: "detail-udi"}] = p.DetailUdi.MatchesAll()
	}
	if p.Encounter != nil {
		m[search.ParameterKey{Name: "encounter"}] = p.Encounter.MatchesAll()
	}
	if p.Enterer != nil {
		m[search.ParameterKey{Name: "enterer"}] = p.Enterer.MatchesAll()
	}
	if p.Facility != nil {
		m[search.ParameterKey{Name: "facility"}] = p.Facility.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Insurer != nil {
		m[search.ParameterKey{Name: "insurer"}] = p.Insurer.MatchesAll()
	}
	if p.ItemUdi != nil {
		m[search.ParameterKey{Name: "item-udi"}] = p.ItemUdi.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Payee != nil {
		m[search.ParameterKey{Name: "payee"}] = p.Payee.MatchesAll()
	}
	if p.Priority != nil {
		m[search.ParameterKey{Name: "priority"}] = p.Priority.MatchesAll()
	}
	if p.ProcedureUdi != nil {
		m[search.ParameterKey{Name: "procedure-udi"}] = p.ProcedureUdi.MatchesAll()
	}
	if p.Provider != nil {
		m[search.ParameterKey{Name: "provider"}] = p.Provider.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.SubdetailUdi != nil {
		m[search.ParameterKey{Name: "subdetail-udi"}] = p.SubdetailUdi.MatchesAll()
	}
	if p.Use != nil {
		m[search.ParameterKey{Name: "use"}] = p.Use.MatchesAll()
	}

	return m
}

// ClaimResponseParams contains typed search parameters for ClaimResponse resources.
type ClaimResponseParams struct {
	// ClaimResponse-specific search parameters
	Created     search.DateOrString      `json:"created,omitempty"`
	Disposition search.StringOrString    `json:"disposition,omitempty"`
	Identifier  search.TokenOrString     `json:"identifier,omitempty"`
	Insurer     search.ReferenceOrString `json:"insurer,omitempty"`
	Outcome     search.TokenOrString     `json:"outcome,omitempty"`
	Patient     search.ReferenceOrString `json:"patient,omitempty"`
	PaymentDate search.DateOrString      `json:"payment-date,omitempty"`
	Request     search.ReferenceOrString `json:"request,omitempty"`
	Requestor   search.ReferenceOrString `json:"requestor,omitempty"`
	Status      search.TokenOrString     `json:"status,omitempty"`
	Use         search.TokenOrString     `json:"use,omitempty"`
}

// Map implements the search.Parameters interface for ClaimResponseParams.
func (p ClaimResponseParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Created != nil {
		m[search.ParameterKey{Name: "created"}] = p.Created.MatchesAll()
	}
	if p.Disposition != nil {
		m[search.ParameterKey{Name: "disposition"}] = p.Disposition.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Insurer != nil {
		m[search.ParameterKey{Name: "insurer"}] = p.Insurer.MatchesAll()
	}
	if p.Outcome != nil {
		m[search.ParameterKey{Name: "outcome"}] = p.Outcome.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.PaymentDate != nil {
		m[search.ParameterKey{Name: "payment-date"}] = p.PaymentDate.MatchesAll()
	}
	if p.Request != nil {
		m[search.ParameterKey{Name: "request"}] = p.Request.MatchesAll()
	}
	if p.Requestor != nil {
		m[search.ParameterKey{Name: "requestor"}] = p.Requestor.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Use != nil {
		m[search.ParameterKey{Name: "use"}] = p.Use.MatchesAll()
	}

	return m
}

// ClinicalImpressionParams contains typed search parameters for ClinicalImpression resources.
type ClinicalImpressionParams struct {
	// ClinicalImpression-specific search parameters
	Date           search.DateOrString      `json:"date,omitempty"`
	Patient        search.ReferenceOrString `json:"patient,omitempty"`
	Assessor       search.ReferenceOrString `json:"assessor,omitempty"`
	Encounter      search.ReferenceOrString `json:"encounter,omitempty"`
	FindingCode    search.TokenOrString     `json:"finding-code,omitempty"`
	FindingRef     search.ReferenceOrString `json:"finding-ref,omitempty"`
	Identifier     search.TokenOrString     `json:"identifier,omitempty"`
	Investigation  search.ReferenceOrString `json:"investigation,omitempty"`
	Previous       search.ReferenceOrString `json:"previous,omitempty"`
	Problem        search.ReferenceOrString `json:"problem,omitempty"`
	Status         search.TokenOrString     `json:"status,omitempty"`
	Subject        search.ReferenceOrString `json:"subject,omitempty"`
	SupportingInfo search.ReferenceOrString `json:"supporting-info,omitempty"`
}

// Map implements the search.Parameters interface for ClinicalImpressionParams.
func (p ClinicalImpressionParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Assessor != nil {
		m[search.ParameterKey{Name: "assessor"}] = p.Assessor.MatchesAll()
	}
	if p.Encounter != nil {
		m[search.ParameterKey{Name: "encounter"}] = p.Encounter.MatchesAll()
	}
	if p.FindingCode != nil {
		m[search.ParameterKey{Name: "finding-code"}] = p.FindingCode.MatchesAll()
	}
	if p.FindingRef != nil {
		m[search.ParameterKey{Name: "finding-ref"}] = p.FindingRef.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Investigation != nil {
		m[search.ParameterKey{Name: "investigation"}] = p.Investigation.MatchesAll()
	}
	if p.Previous != nil {
		m[search.ParameterKey{Name: "previous"}] = p.Previous.MatchesAll()
	}
	if p.Problem != nil {
		m[search.ParameterKey{Name: "problem"}] = p.Problem.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}
	if p.SupportingInfo != nil {
		m[search.ParameterKey{Name: "supporting-info"}] = p.SupportingInfo.MatchesAll()
	}

	return m
}

// ClinicalUseDefinitionParams contains typed search parameters for ClinicalUseDefinition resources.
type ClinicalUseDefinitionParams struct {
	// ClinicalUseDefinition-specific search parameters
	Contraindication          search.TokenOrString     `json:"contraindication,omitempty"`
	ContraindicationReference search.ReferenceOrString `json:"contraindication-reference,omitempty"`
	Effect                    search.TokenOrString     `json:"effect,omitempty"`
	EffectReference           search.ReferenceOrString `json:"effect-reference,omitempty"`
	Identifier                search.TokenOrString     `json:"identifier,omitempty"`
	Indication                search.TokenOrString     `json:"indication,omitempty"`
	IndicationReference       search.ReferenceOrString `json:"indication-reference,omitempty"`
	Interaction               search.TokenOrString     `json:"interaction,omitempty"`
	Product                   search.ReferenceOrString `json:"product,omitempty"`
	Subject                   search.ReferenceOrString `json:"subject,omitempty"`
	Type                      search.TokenOrString     `json:"type,omitempty"`
}

// Map implements the search.Parameters interface for ClinicalUseDefinitionParams.
func (p ClinicalUseDefinitionParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Contraindication != nil {
		m[search.ParameterKey{Name: "contraindication"}] = p.Contraindication.MatchesAll()
	}
	if p.ContraindicationReference != nil {
		m[search.ParameterKey{Name: "contraindication-reference"}] = p.ContraindicationReference.MatchesAll()
	}
	if p.Effect != nil {
		m[search.ParameterKey{Name: "effect"}] = p.Effect.MatchesAll()
	}
	if p.EffectReference != nil {
		m[search.ParameterKey{Name: "effect-reference"}] = p.EffectReference.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Indication != nil {
		m[search.ParameterKey{Name: "indication"}] = p.Indication.MatchesAll()
	}
	if p.IndicationReference != nil {
		m[search.ParameterKey{Name: "indication-reference"}] = p.IndicationReference.MatchesAll()
	}
	if p.Interaction != nil {
		m[search.ParameterKey{Name: "interaction"}] = p.Interaction.MatchesAll()
	}
	if p.Product != nil {
		m[search.ParameterKey{Name: "product"}] = p.Product.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}

	return m
}

// CodeSystemParams contains typed search parameters for CodeSystem resources.
type CodeSystemParams struct {
	// CodeSystem-specific search parameters
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Date                search.DateOrString      `json:"date,omitempty"`
	Description         search.StringOrString    `json:"description,omitempty"`
	Jurisdiction        search.TokenOrString     `json:"jurisdiction,omitempty"`
	Name                search.StringOrString    `json:"name,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	Title               search.StringOrString    `json:"title,omitempty"`
	Url                 search.UriOrString       `json:"url,omitempty"`
	Version             search.TokenOrString     `json:"version,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
	Code                search.TokenOrString     `json:"code,omitempty"`
	ContentMode         search.TokenOrString     `json:"content-mode,omitempty"`
	Identifier          search.TokenOrString     `json:"identifier,omitempty"`
	Language            search.TokenOrString     `json:"language,omitempty"`
	Supplements         search.ReferenceOrString `json:"supplements,omitempty"`
	System              search.UriOrString       `json:"system,omitempty"`
}

// Map implements the search.Parameters interface for CodeSystemParams.
func (p CodeSystemParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Jurisdiction != nil {
		m[search.ParameterKey{Name: "jurisdiction"}] = p.Jurisdiction.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Title != nil {
		m[search.ParameterKey{Name: "title"}] = p.Title.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}
	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.ContentMode != nil {
		m[search.ParameterKey{Name: "content-mode"}] = p.ContentMode.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Language != nil {
		m[search.ParameterKey{Name: "language"}] = p.Language.MatchesAll()
	}
	if p.Supplements != nil {
		m[search.ParameterKey{Name: "supplements"}] = p.Supplements.MatchesAll()
	}
	if p.System != nil {
		m[search.ParameterKey{Name: "system"}] = p.System.MatchesAll()
	}

	return m
}

// CommunicationParams contains typed search parameters for Communication resources.
type CommunicationParams struct {
	// Communication-specific search parameters
	BasedOn               search.ReferenceOrString `json:"based-on,omitempty"`
	Category              search.TokenOrString     `json:"category,omitempty"`
	Encounter             search.ReferenceOrString `json:"encounter,omitempty"`
	Identifier            search.TokenOrString     `json:"identifier,omitempty"`
	InstantiatesCanonical search.ReferenceOrString `json:"instantiates-canonical,omitempty"`
	InstantiatesUri       search.UriOrString       `json:"instantiates-uri,omitempty"`
	Medium                search.TokenOrString     `json:"medium,omitempty"`
	PartOf                search.ReferenceOrString `json:"part-of,omitempty"`
	Patient               search.ReferenceOrString `json:"patient,omitempty"`
	Received              search.DateOrString      `json:"received,omitempty"`
	Recipient             search.ReferenceOrString `json:"recipient,omitempty"`
	Sender                search.ReferenceOrString `json:"sender,omitempty"`
	Sent                  search.DateOrString      `json:"sent,omitempty"`
	Status                search.TokenOrString     `json:"status,omitempty"`
	Subject               search.ReferenceOrString `json:"subject,omitempty"`
}

// Map implements the search.Parameters interface for CommunicationParams.
func (p CommunicationParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.BasedOn != nil {
		m[search.ParameterKey{Name: "based-on"}] = p.BasedOn.MatchesAll()
	}
	if p.Category != nil {
		m[search.ParameterKey{Name: "category"}] = p.Category.MatchesAll()
	}
	if p.Encounter != nil {
		m[search.ParameterKey{Name: "encounter"}] = p.Encounter.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.InstantiatesCanonical != nil {
		m[search.ParameterKey{Name: "instantiates-canonical"}] = p.InstantiatesCanonical.MatchesAll()
	}
	if p.InstantiatesUri != nil {
		m[search.ParameterKey{Name: "instantiates-uri"}] = p.InstantiatesUri.MatchesAll()
	}
	if p.Medium != nil {
		m[search.ParameterKey{Name: "medium"}] = p.Medium.MatchesAll()
	}
	if p.PartOf != nil {
		m[search.ParameterKey{Name: "part-of"}] = p.PartOf.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Received != nil {
		m[search.ParameterKey{Name: "received"}] = p.Received.MatchesAll()
	}
	if p.Recipient != nil {
		m[search.ParameterKey{Name: "recipient"}] = p.Recipient.MatchesAll()
	}
	if p.Sender != nil {
		m[search.ParameterKey{Name: "sender"}] = p.Sender.MatchesAll()
	}
	if p.Sent != nil {
		m[search.ParameterKey{Name: "sent"}] = p.Sent.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}

	return m
}

// CommunicationRequestParams contains typed search parameters for CommunicationRequest resources.
type CommunicationRequestParams struct {
	// CommunicationRequest-specific search parameters
	Authored        search.DateOrString      `json:"authored,omitempty"`
	BasedOn         search.ReferenceOrString `json:"based-on,omitempty"`
	Category        search.TokenOrString     `json:"category,omitempty"`
	Encounter       search.ReferenceOrString `json:"encounter,omitempty"`
	GroupIdentifier search.TokenOrString     `json:"group-identifier,omitempty"`
	Identifier      search.TokenOrString     `json:"identifier,omitempty"`
	Medium          search.TokenOrString     `json:"medium,omitempty"`
	Occurrence      search.DateOrString      `json:"occurrence,omitempty"`
	Patient         search.ReferenceOrString `json:"patient,omitempty"`
	Priority        search.TokenOrString     `json:"priority,omitempty"`
	Recipient       search.ReferenceOrString `json:"recipient,omitempty"`
	Replaces        search.ReferenceOrString `json:"replaces,omitempty"`
	Requester       search.ReferenceOrString `json:"requester,omitempty"`
	Sender          search.ReferenceOrString `json:"sender,omitempty"`
	Status          search.TokenOrString     `json:"status,omitempty"`
	Subject         search.ReferenceOrString `json:"subject,omitempty"`
}

// Map implements the search.Parameters interface for CommunicationRequestParams.
func (p CommunicationRequestParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Authored != nil {
		m[search.ParameterKey{Name: "authored"}] = p.Authored.MatchesAll()
	}
	if p.BasedOn != nil {
		m[search.ParameterKey{Name: "based-on"}] = p.BasedOn.MatchesAll()
	}
	if p.Category != nil {
		m[search.ParameterKey{Name: "category"}] = p.Category.MatchesAll()
	}
	if p.Encounter != nil {
		m[search.ParameterKey{Name: "encounter"}] = p.Encounter.MatchesAll()
	}
	if p.GroupIdentifier != nil {
		m[search.ParameterKey{Name: "group-identifier"}] = p.GroupIdentifier.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Medium != nil {
		m[search.ParameterKey{Name: "medium"}] = p.Medium.MatchesAll()
	}
	if p.Occurrence != nil {
		m[search.ParameterKey{Name: "occurrence"}] = p.Occurrence.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Priority != nil {
		m[search.ParameterKey{Name: "priority"}] = p.Priority.MatchesAll()
	}
	if p.Recipient != nil {
		m[search.ParameterKey{Name: "recipient"}] = p.Recipient.MatchesAll()
	}
	if p.Replaces != nil {
		m[search.ParameterKey{Name: "replaces"}] = p.Replaces.MatchesAll()
	}
	if p.Requester != nil {
		m[search.ParameterKey{Name: "requester"}] = p.Requester.MatchesAll()
	}
	if p.Sender != nil {
		m[search.ParameterKey{Name: "sender"}] = p.Sender.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}

	return m
}

// CompartmentDefinitionParams contains typed search parameters for CompartmentDefinition resources.
type CompartmentDefinitionParams struct {
	// CompartmentDefinition-specific search parameters
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Date                search.DateOrString      `json:"date,omitempty"`
	Description         search.StringOrString    `json:"description,omitempty"`
	Name                search.StringOrString    `json:"name,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	Url                 search.UriOrString       `json:"url,omitempty"`
	Version             search.TokenOrString     `json:"version,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
	Code                search.TokenOrString     `json:"code,omitempty"`
	Resource            search.TokenOrString     `json:"resource,omitempty"`
}

// Map implements the search.Parameters interface for CompartmentDefinitionParams.
func (p CompartmentDefinitionParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}
	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.Resource != nil {
		m[search.ParameterKey{Name: "resource"}] = p.Resource.MatchesAll()
	}

	return m
}

// CompositionParams contains typed search parameters for Composition resources.
type CompositionParams struct {
	// Composition-specific search parameters
	Date            search.DateOrString      `json:"date,omitempty"`
	Identifier      search.TokenOrString     `json:"identifier,omitempty"`
	Patient         search.ReferenceOrString `json:"patient,omitempty"`
	Type            search.TokenOrString     `json:"type,omitempty"`
	Attester        search.ReferenceOrString `json:"attester,omitempty"`
	Author          search.ReferenceOrString `json:"author,omitempty"`
	Category        search.TokenOrString     `json:"category,omitempty"`
	Confidentiality search.TokenOrString     `json:"confidentiality,omitempty"`
	Context         search.TokenOrString     `json:"context,omitempty"`
	Encounter       search.ReferenceOrString `json:"encounter,omitempty"`
	Entry           search.ReferenceOrString `json:"entry,omitempty"`
	Period          search.DateOrString      `json:"period,omitempty"`
	RelatedId       search.TokenOrString     `json:"related-id,omitempty"`
	RelatedRef      search.ReferenceOrString `json:"related-ref,omitempty"`
	Section         search.TokenOrString     `json:"section,omitempty"`
	Status          search.TokenOrString     `json:"status,omitempty"`
	Subject         search.ReferenceOrString `json:"subject,omitempty"`
	Title           search.StringOrString    `json:"title,omitempty"`
}

// Map implements the search.Parameters interface for CompositionParams.
func (p CompositionParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}
	if p.Attester != nil {
		m[search.ParameterKey{Name: "attester"}] = p.Attester.MatchesAll()
	}
	if p.Author != nil {
		m[search.ParameterKey{Name: "author"}] = p.Author.MatchesAll()
	}
	if p.Category != nil {
		m[search.ParameterKey{Name: "category"}] = p.Category.MatchesAll()
	}
	if p.Confidentiality != nil {
		m[search.ParameterKey{Name: "confidentiality"}] = p.Confidentiality.MatchesAll()
	}
	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.Encounter != nil {
		m[search.ParameterKey{Name: "encounter"}] = p.Encounter.MatchesAll()
	}
	if p.Entry != nil {
		m[search.ParameterKey{Name: "entry"}] = p.Entry.MatchesAll()
	}
	if p.Period != nil {
		m[search.ParameterKey{Name: "period"}] = p.Period.MatchesAll()
	}
	if p.RelatedId != nil {
		m[search.ParameterKey{Name: "related-id"}] = p.RelatedId.MatchesAll()
	}
	if p.RelatedRef != nil {
		m[search.ParameterKey{Name: "related-ref"}] = p.RelatedRef.MatchesAll()
	}
	if p.Section != nil {
		m[search.ParameterKey{Name: "section"}] = p.Section.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}
	if p.Title != nil {
		m[search.ParameterKey{Name: "title"}] = p.Title.MatchesAll()
	}

	return m
}

// ConceptMapParams contains typed search parameters for ConceptMap resources.
type ConceptMapParams struct {
	// ConceptMap-specific search parameters
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Date                search.DateOrString      `json:"date,omitempty"`
	Description         search.StringOrString    `json:"description,omitempty"`
	Jurisdiction        search.TokenOrString     `json:"jurisdiction,omitempty"`
	Name                search.StringOrString    `json:"name,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	Title               search.StringOrString    `json:"title,omitempty"`
	Url                 search.UriOrString       `json:"url,omitempty"`
	Version             search.TokenOrString     `json:"version,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
	Identifier          search.TokenOrString     `json:"identifier,omitempty"`
	Dependson           search.UriOrString       `json:"dependson,omitempty"`
	Other               search.ReferenceOrString `json:"other,omitempty"`
	Product             search.UriOrString       `json:"product,omitempty"`
	Source              search.ReferenceOrString `json:"source,omitempty"`
	SourceCode          search.TokenOrString     `json:"source-code,omitempty"`
	SourceSystem        search.UriOrString       `json:"source-system,omitempty"`
	SourceUri           search.ReferenceOrString `json:"source-uri,omitempty"`
	Target              search.ReferenceOrString `json:"target,omitempty"`
	TargetCode          search.TokenOrString     `json:"target-code,omitempty"`
	TargetSystem        search.UriOrString       `json:"target-system,omitempty"`
	TargetUri           search.ReferenceOrString `json:"target-uri,omitempty"`
}

// Map implements the search.Parameters interface for ConceptMapParams.
func (p ConceptMapParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Jurisdiction != nil {
		m[search.ParameterKey{Name: "jurisdiction"}] = p.Jurisdiction.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Title != nil {
		m[search.ParameterKey{Name: "title"}] = p.Title.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Dependson != nil {
		m[search.ParameterKey{Name: "dependson"}] = p.Dependson.MatchesAll()
	}
	if p.Other != nil {
		m[search.ParameterKey{Name: "other"}] = p.Other.MatchesAll()
	}
	if p.Product != nil {
		m[search.ParameterKey{Name: "product"}] = p.Product.MatchesAll()
	}
	if p.Source != nil {
		m[search.ParameterKey{Name: "source"}] = p.Source.MatchesAll()
	}
	if p.SourceCode != nil {
		m[search.ParameterKey{Name: "source-code"}] = p.SourceCode.MatchesAll()
	}
	if p.SourceSystem != nil {
		m[search.ParameterKey{Name: "source-system"}] = p.SourceSystem.MatchesAll()
	}
	if p.SourceUri != nil {
		m[search.ParameterKey{Name: "source-uri"}] = p.SourceUri.MatchesAll()
	}
	if p.Target != nil {
		m[search.ParameterKey{Name: "target"}] = p.Target.MatchesAll()
	}
	if p.TargetCode != nil {
		m[search.ParameterKey{Name: "target-code"}] = p.TargetCode.MatchesAll()
	}
	if p.TargetSystem != nil {
		m[search.ParameterKey{Name: "target-system"}] = p.TargetSystem.MatchesAll()
	}
	if p.TargetUri != nil {
		m[search.ParameterKey{Name: "target-uri"}] = p.TargetUri.MatchesAll()
	}

	return m
}

// ConditionParams contains typed search parameters for Condition resources.
type ConditionParams struct {
	// Condition-specific search parameters
	Code               search.TokenOrString     `json:"code,omitempty"`
	Identifier         search.TokenOrString     `json:"identifier,omitempty"`
	Patient            search.ReferenceOrString `json:"patient,omitempty"`
	AbatementAge       search.QuantityOrString  `json:"abatement-age,omitempty"`
	AbatementDate      search.DateOrString      `json:"abatement-date,omitempty"`
	AbatementString    search.StringOrString    `json:"abatement-string,omitempty"`
	Asserter           search.ReferenceOrString `json:"asserter,omitempty"`
	BodySite           search.TokenOrString     `json:"body-site,omitempty"`
	Category           search.TokenOrString     `json:"category,omitempty"`
	ClinicalStatus     search.TokenOrString     `json:"clinical-status,omitempty"`
	Encounter          search.ReferenceOrString `json:"encounter,omitempty"`
	Evidence           search.TokenOrString     `json:"evidence,omitempty"`
	EvidenceDetail     search.ReferenceOrString `json:"evidence-detail,omitempty"`
	OnsetAge           search.QuantityOrString  `json:"onset-age,omitempty"`
	OnsetDate          search.DateOrString      `json:"onset-date,omitempty"`
	OnsetInfo          search.StringOrString    `json:"onset-info,omitempty"`
	RecordedDate       search.DateOrString      `json:"recorded-date,omitempty"`
	Severity           search.TokenOrString     `json:"severity,omitempty"`
	Stage              search.TokenOrString     `json:"stage,omitempty"`
	Subject            search.ReferenceOrString `json:"subject,omitempty"`
	VerificationStatus search.TokenOrString     `json:"verification-status,omitempty"`
}

// Map implements the search.Parameters interface for ConditionParams.
func (p ConditionParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.AbatementAge != nil {
		m[search.ParameterKey{Name: "abatement-age"}] = p.AbatementAge.MatchesAll()
	}
	if p.AbatementDate != nil {
		m[search.ParameterKey{Name: "abatement-date"}] = p.AbatementDate.MatchesAll()
	}
	if p.AbatementString != nil {
		m[search.ParameterKey{Name: "abatement-string"}] = p.AbatementString.MatchesAll()
	}
	if p.Asserter != nil {
		m[search.ParameterKey{Name: "asserter"}] = p.Asserter.MatchesAll()
	}
	if p.BodySite != nil {
		m[search.ParameterKey{Name: "body-site"}] = p.BodySite.MatchesAll()
	}
	if p.Category != nil {
		m[search.ParameterKey{Name: "category"}] = p.Category.MatchesAll()
	}
	if p.ClinicalStatus != nil {
		m[search.ParameterKey{Name: "clinical-status"}] = p.ClinicalStatus.MatchesAll()
	}
	if p.Encounter != nil {
		m[search.ParameterKey{Name: "encounter"}] = p.Encounter.MatchesAll()
	}
	if p.Evidence != nil {
		m[search.ParameterKey{Name: "evidence"}] = p.Evidence.MatchesAll()
	}
	if p.EvidenceDetail != nil {
		m[search.ParameterKey{Name: "evidence-detail"}] = p.EvidenceDetail.MatchesAll()
	}
	if p.OnsetAge != nil {
		m[search.ParameterKey{Name: "onset-age"}] = p.OnsetAge.MatchesAll()
	}
	if p.OnsetDate != nil {
		m[search.ParameterKey{Name: "onset-date"}] = p.OnsetDate.MatchesAll()
	}
	if p.OnsetInfo != nil {
		m[search.ParameterKey{Name: "onset-info"}] = p.OnsetInfo.MatchesAll()
	}
	if p.RecordedDate != nil {
		m[search.ParameterKey{Name: "recorded-date"}] = p.RecordedDate.MatchesAll()
	}
	if p.Severity != nil {
		m[search.ParameterKey{Name: "severity"}] = p.Severity.MatchesAll()
	}
	if p.Stage != nil {
		m[search.ParameterKey{Name: "stage"}] = p.Stage.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}
	if p.VerificationStatus != nil {
		m[search.ParameterKey{Name: "verification-status"}] = p.VerificationStatus.MatchesAll()
	}

	return m
}

// ConsentParams contains typed search parameters for Consent resources.
type ConsentParams struct {
	// Consent-specific search parameters
	Date            search.DateOrString      `json:"date,omitempty"`
	Identifier      search.TokenOrString     `json:"identifier,omitempty"`
	Patient         search.ReferenceOrString `json:"patient,omitempty"`
	Action          search.TokenOrString     `json:"action,omitempty"`
	Actor           search.ReferenceOrString `json:"actor,omitempty"`
	Category        search.TokenOrString     `json:"category,omitempty"`
	Consentor       search.ReferenceOrString `json:"consentor,omitempty"`
	Data            search.ReferenceOrString `json:"data,omitempty"`
	Organization    search.ReferenceOrString `json:"organization,omitempty"`
	Period          search.DateOrString      `json:"period,omitempty"`
	Purpose         search.TokenOrString     `json:"purpose,omitempty"`
	Scope           search.TokenOrString     `json:"scope,omitempty"`
	SecurityLabel   search.TokenOrString     `json:"security-label,omitempty"`
	SourceReference search.ReferenceOrString `json:"source-reference,omitempty"`
	Status          search.TokenOrString     `json:"status,omitempty"`
}

// Map implements the search.Parameters interface for ConsentParams.
func (p ConsentParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Action != nil {
		m[search.ParameterKey{Name: "action"}] = p.Action.MatchesAll()
	}
	if p.Actor != nil {
		m[search.ParameterKey{Name: "actor"}] = p.Actor.MatchesAll()
	}
	if p.Category != nil {
		m[search.ParameterKey{Name: "category"}] = p.Category.MatchesAll()
	}
	if p.Consentor != nil {
		m[search.ParameterKey{Name: "consentor"}] = p.Consentor.MatchesAll()
	}
	if p.Data != nil {
		m[search.ParameterKey{Name: "data"}] = p.Data.MatchesAll()
	}
	if p.Organization != nil {
		m[search.ParameterKey{Name: "organization"}] = p.Organization.MatchesAll()
	}
	if p.Period != nil {
		m[search.ParameterKey{Name: "period"}] = p.Period.MatchesAll()
	}
	if p.Purpose != nil {
		m[search.ParameterKey{Name: "purpose"}] = p.Purpose.MatchesAll()
	}
	if p.Scope != nil {
		m[search.ParameterKey{Name: "scope"}] = p.Scope.MatchesAll()
	}
	if p.SecurityLabel != nil {
		m[search.ParameterKey{Name: "security-label"}] = p.SecurityLabel.MatchesAll()
	}
	if p.SourceReference != nil {
		m[search.ParameterKey{Name: "source-reference"}] = p.SourceReference.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}

	return m
}

// ContractParams contains typed search parameters for Contract resources.
type ContractParams struct {
	// Contract-specific search parameters
	Authority    search.ReferenceOrString `json:"authority,omitempty"`
	Domain       search.ReferenceOrString `json:"domain,omitempty"`
	Identifier   search.TokenOrString     `json:"identifier,omitempty"`
	Instantiates search.UriOrString       `json:"instantiates,omitempty"`
	Issued       search.DateOrString      `json:"issued,omitempty"`
	Patient      search.ReferenceOrString `json:"patient,omitempty"`
	Signer       search.ReferenceOrString `json:"signer,omitempty"`
	Status       search.TokenOrString     `json:"status,omitempty"`
	Subject      search.ReferenceOrString `json:"subject,omitempty"`
	Url          search.UriOrString       `json:"url,omitempty"`
}

// Map implements the search.Parameters interface for ContractParams.
func (p ContractParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Authority != nil {
		m[search.ParameterKey{Name: "authority"}] = p.Authority.MatchesAll()
	}
	if p.Domain != nil {
		m[search.ParameterKey{Name: "domain"}] = p.Domain.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Instantiates != nil {
		m[search.ParameterKey{Name: "instantiates"}] = p.Instantiates.MatchesAll()
	}
	if p.Issued != nil {
		m[search.ParameterKey{Name: "issued"}] = p.Issued.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Signer != nil {
		m[search.ParameterKey{Name: "signer"}] = p.Signer.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}

	return m
}

// CoverageParams contains typed search parameters for Coverage resources.
type CoverageParams struct {
	// Coverage-specific search parameters
	Beneficiary  search.ReferenceOrString `json:"beneficiary,omitempty"`
	ClassType    search.TokenOrString     `json:"class-type,omitempty"`
	ClassValue   search.StringOrString    `json:"class-value,omitempty"`
	Dependent    search.StringOrString    `json:"dependent,omitempty"`
	Identifier   search.TokenOrString     `json:"identifier,omitempty"`
	Patient      search.ReferenceOrString `json:"patient,omitempty"`
	Payor        search.ReferenceOrString `json:"payor,omitempty"`
	PolicyHolder search.ReferenceOrString `json:"policy-holder,omitempty"`
	Status       search.TokenOrString     `json:"status,omitempty"`
	Subscriber   search.ReferenceOrString `json:"subscriber,omitempty"`
	Type         search.TokenOrString     `json:"type,omitempty"`
}

// Map implements the search.Parameters interface for CoverageParams.
func (p CoverageParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Beneficiary != nil {
		m[search.ParameterKey{Name: "beneficiary"}] = p.Beneficiary.MatchesAll()
	}
	if p.ClassType != nil {
		m[search.ParameterKey{Name: "class-type"}] = p.ClassType.MatchesAll()
	}
	if p.ClassValue != nil {
		m[search.ParameterKey{Name: "class-value"}] = p.ClassValue.MatchesAll()
	}
	if p.Dependent != nil {
		m[search.ParameterKey{Name: "dependent"}] = p.Dependent.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Payor != nil {
		m[search.ParameterKey{Name: "payor"}] = p.Payor.MatchesAll()
	}
	if p.PolicyHolder != nil {
		m[search.ParameterKey{Name: "policy-holder"}] = p.PolicyHolder.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subscriber != nil {
		m[search.ParameterKey{Name: "subscriber"}] = p.Subscriber.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}

	return m
}

// CoverageEligibilityRequestParams contains typed search parameters for CoverageEligibilityRequest resources.
type CoverageEligibilityRequestParams struct {
	// CoverageEligibilityRequest-specific search parameters
	Created    search.DateOrString      `json:"created,omitempty"`
	Enterer    search.ReferenceOrString `json:"enterer,omitempty"`
	Facility   search.ReferenceOrString `json:"facility,omitempty"`
	Identifier search.TokenOrString     `json:"identifier,omitempty"`
	Patient    search.ReferenceOrString `json:"patient,omitempty"`
	Provider   search.ReferenceOrString `json:"provider,omitempty"`
	Status     search.TokenOrString     `json:"status,omitempty"`
}

// Map implements the search.Parameters interface for CoverageEligibilityRequestParams.
func (p CoverageEligibilityRequestParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Created != nil {
		m[search.ParameterKey{Name: "created"}] = p.Created.MatchesAll()
	}
	if p.Enterer != nil {
		m[search.ParameterKey{Name: "enterer"}] = p.Enterer.MatchesAll()
	}
	if p.Facility != nil {
		m[search.ParameterKey{Name: "facility"}] = p.Facility.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Provider != nil {
		m[search.ParameterKey{Name: "provider"}] = p.Provider.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}

	return m
}

// CoverageEligibilityResponseParams contains typed search parameters for CoverageEligibilityResponse resources.
type CoverageEligibilityResponseParams struct {
	// CoverageEligibilityResponse-specific search parameters
	Created     search.DateOrString      `json:"created,omitempty"`
	Disposition search.StringOrString    `json:"disposition,omitempty"`
	Identifier  search.TokenOrString     `json:"identifier,omitempty"`
	Insurer     search.ReferenceOrString `json:"insurer,omitempty"`
	Outcome     search.TokenOrString     `json:"outcome,omitempty"`
	Patient     search.ReferenceOrString `json:"patient,omitempty"`
	Request     search.ReferenceOrString `json:"request,omitempty"`
	Requestor   search.ReferenceOrString `json:"requestor,omitempty"`
	Status      search.TokenOrString     `json:"status,omitempty"`
}

// Map implements the search.Parameters interface for CoverageEligibilityResponseParams.
func (p CoverageEligibilityResponseParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Created != nil {
		m[search.ParameterKey{Name: "created"}] = p.Created.MatchesAll()
	}
	if p.Disposition != nil {
		m[search.ParameterKey{Name: "disposition"}] = p.Disposition.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Insurer != nil {
		m[search.ParameterKey{Name: "insurer"}] = p.Insurer.MatchesAll()
	}
	if p.Outcome != nil {
		m[search.ParameterKey{Name: "outcome"}] = p.Outcome.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Request != nil {
		m[search.ParameterKey{Name: "request"}] = p.Request.MatchesAll()
	}
	if p.Requestor != nil {
		m[search.ParameterKey{Name: "requestor"}] = p.Requestor.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}

	return m
}

// DetectedIssueParams contains typed search parameters for DetectedIssue resources.
type DetectedIssueParams struct {
	// DetectedIssue-specific search parameters
	Identifier search.TokenOrString     `json:"identifier,omitempty"`
	Patient    search.ReferenceOrString `json:"patient,omitempty"`
	Author     search.ReferenceOrString `json:"author,omitempty"`
	Code       search.TokenOrString     `json:"code,omitempty"`
	Identified search.DateOrString      `json:"identified,omitempty"`
	Implicated search.ReferenceOrString `json:"implicated,omitempty"`
}

// Map implements the search.Parameters interface for DetectedIssueParams.
func (p DetectedIssueParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Author != nil {
		m[search.ParameterKey{Name: "author"}] = p.Author.MatchesAll()
	}
	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.Identified != nil {
		m[search.ParameterKey{Name: "identified"}] = p.Identified.MatchesAll()
	}
	if p.Implicated != nil {
		m[search.ParameterKey{Name: "implicated"}] = p.Implicated.MatchesAll()
	}

	return m
}

// DeviceParams contains typed search parameters for Device resources.
type DeviceParams struct {
	// Device-specific search parameters
	DeviceName   search.StringOrString    `json:"device-name,omitempty"`
	Identifier   search.TokenOrString     `json:"identifier,omitempty"`
	Location     search.ReferenceOrString `json:"location,omitempty"`
	Manufacturer search.StringOrString    `json:"manufacturer,omitempty"`
	Model        search.StringOrString    `json:"model,omitempty"`
	Organization search.ReferenceOrString `json:"organization,omitempty"`
	Patient      search.ReferenceOrString `json:"patient,omitempty"`
	Status       search.TokenOrString     `json:"status,omitempty"`
	Type         search.TokenOrString     `json:"type,omitempty"`
	UdiCarrier   search.StringOrString    `json:"udi-carrier,omitempty"`
	UdiDi        search.StringOrString    `json:"udi-di,omitempty"`
	Url          search.UriOrString       `json:"url,omitempty"`
}

// Map implements the search.Parameters interface for DeviceParams.
func (p DeviceParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.DeviceName != nil {
		m[search.ParameterKey{Name: "device-name"}] = p.DeviceName.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Location != nil {
		m[search.ParameterKey{Name: "location"}] = p.Location.MatchesAll()
	}
	if p.Manufacturer != nil {
		m[search.ParameterKey{Name: "manufacturer"}] = p.Manufacturer.MatchesAll()
	}
	if p.Model != nil {
		m[search.ParameterKey{Name: "model"}] = p.Model.MatchesAll()
	}
	if p.Organization != nil {
		m[search.ParameterKey{Name: "organization"}] = p.Organization.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}
	if p.UdiCarrier != nil {
		m[search.ParameterKey{Name: "udi-carrier"}] = p.UdiCarrier.MatchesAll()
	}
	if p.UdiDi != nil {
		m[search.ParameterKey{Name: "udi-di"}] = p.UdiDi.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}

	return m
}

// DeviceDefinitionParams contains typed search parameters for DeviceDefinition resources.
type DeviceDefinitionParams struct {
	// DeviceDefinition-specific search parameters
	Identifier search.TokenOrString     `json:"identifier,omitempty"`
	Parent     search.ReferenceOrString `json:"parent,omitempty"`
	Type       search.TokenOrString     `json:"type,omitempty"`
}

// Map implements the search.Parameters interface for DeviceDefinitionParams.
func (p DeviceDefinitionParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Parent != nil {
		m[search.ParameterKey{Name: "parent"}] = p.Parent.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}

	return m
}

// DeviceMetricParams contains typed search parameters for DeviceMetric resources.
type DeviceMetricParams struct {
	// DeviceMetric-specific search parameters
	Category   search.TokenOrString     `json:"category,omitempty"`
	Identifier search.TokenOrString     `json:"identifier,omitempty"`
	Parent     search.ReferenceOrString `json:"parent,omitempty"`
	Source     search.ReferenceOrString `json:"source,omitempty"`
	Type       search.TokenOrString     `json:"type,omitempty"`
}

// Map implements the search.Parameters interface for DeviceMetricParams.
func (p DeviceMetricParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Category != nil {
		m[search.ParameterKey{Name: "category"}] = p.Category.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Parent != nil {
		m[search.ParameterKey{Name: "parent"}] = p.Parent.MatchesAll()
	}
	if p.Source != nil {
		m[search.ParameterKey{Name: "source"}] = p.Source.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}

	return m
}

// DeviceRequestParams contains typed search parameters for DeviceRequest resources.
type DeviceRequestParams struct {
	// DeviceRequest-specific search parameters
	Code                  search.TokenOrString     `json:"code,omitempty"`
	Identifier            search.TokenOrString     `json:"identifier,omitempty"`
	Patient               search.ReferenceOrString `json:"patient,omitempty"`
	Encounter             search.ReferenceOrString `json:"encounter,omitempty"`
	AuthoredOn            search.DateOrString      `json:"authored-on,omitempty"`
	BasedOn               search.ReferenceOrString `json:"based-on,omitempty"`
	Device                search.ReferenceOrString `json:"device,omitempty"`
	EventDate             search.DateOrString      `json:"event-date,omitempty"`
	GroupIdentifier       search.TokenOrString     `json:"group-identifier,omitempty"`
	InstantiatesCanonical search.ReferenceOrString `json:"instantiates-canonical,omitempty"`
	InstantiatesUri       search.UriOrString       `json:"instantiates-uri,omitempty"`
	Insurance             search.ReferenceOrString `json:"insurance,omitempty"`
	Intent                search.TokenOrString     `json:"intent,omitempty"`
	Performer             search.ReferenceOrString `json:"performer,omitempty"`
	PriorRequest          search.ReferenceOrString `json:"prior-request,omitempty"`
	Requester             search.ReferenceOrString `json:"requester,omitempty"`
	Status                search.TokenOrString     `json:"status,omitempty"`
	Subject               search.ReferenceOrString `json:"subject,omitempty"`
}

// Map implements the search.Parameters interface for DeviceRequestParams.
func (p DeviceRequestParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Encounter != nil {
		m[search.ParameterKey{Name: "encounter"}] = p.Encounter.MatchesAll()
	}
	if p.AuthoredOn != nil {
		m[search.ParameterKey{Name: "authored-on"}] = p.AuthoredOn.MatchesAll()
	}
	if p.BasedOn != nil {
		m[search.ParameterKey{Name: "based-on"}] = p.BasedOn.MatchesAll()
	}
	if p.Device != nil {
		m[search.ParameterKey{Name: "device"}] = p.Device.MatchesAll()
	}
	if p.EventDate != nil {
		m[search.ParameterKey{Name: "event-date"}] = p.EventDate.MatchesAll()
	}
	if p.GroupIdentifier != nil {
		m[search.ParameterKey{Name: "group-identifier"}] = p.GroupIdentifier.MatchesAll()
	}
	if p.InstantiatesCanonical != nil {
		m[search.ParameterKey{Name: "instantiates-canonical"}] = p.InstantiatesCanonical.MatchesAll()
	}
	if p.InstantiatesUri != nil {
		m[search.ParameterKey{Name: "instantiates-uri"}] = p.InstantiatesUri.MatchesAll()
	}
	if p.Insurance != nil {
		m[search.ParameterKey{Name: "insurance"}] = p.Insurance.MatchesAll()
	}
	if p.Intent != nil {
		m[search.ParameterKey{Name: "intent"}] = p.Intent.MatchesAll()
	}
	if p.Performer != nil {
		m[search.ParameterKey{Name: "performer"}] = p.Performer.MatchesAll()
	}
	if p.PriorRequest != nil {
		m[search.ParameterKey{Name: "prior-request"}] = p.PriorRequest.MatchesAll()
	}
	if p.Requester != nil {
		m[search.ParameterKey{Name: "requester"}] = p.Requester.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}

	return m
}

// DeviceUseStatementParams contains typed search parameters for DeviceUseStatement resources.
type DeviceUseStatementParams struct {
	// DeviceUseStatement-specific search parameters
	Patient    search.ReferenceOrString `json:"patient,omitempty"`
	Device     search.ReferenceOrString `json:"device,omitempty"`
	Identifier search.TokenOrString     `json:"identifier,omitempty"`
	Subject    search.ReferenceOrString `json:"subject,omitempty"`
}

// Map implements the search.Parameters interface for DeviceUseStatementParams.
func (p DeviceUseStatementParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Device != nil {
		m[search.ParameterKey{Name: "device"}] = p.Device.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}

	return m
}

// DiagnosticReportParams contains typed search parameters for DiagnosticReport resources.
type DiagnosticReportParams struct {
	// DiagnosticReport-specific search parameters
	Code               search.TokenOrString     `json:"code,omitempty"`
	Date               search.DateOrString      `json:"date,omitempty"`
	Identifier         search.TokenOrString     `json:"identifier,omitempty"`
	Patient            search.ReferenceOrString `json:"patient,omitempty"`
	Encounter          search.ReferenceOrString `json:"encounter,omitempty"`
	BasedOn            search.ReferenceOrString `json:"based-on,omitempty"`
	Category           search.TokenOrString     `json:"category,omitempty"`
	Conclusion         search.TokenOrString     `json:"conclusion,omitempty"`
	Issued             search.DateOrString      `json:"issued,omitempty"`
	Media              search.ReferenceOrString `json:"media,omitempty"`
	Performer          search.ReferenceOrString `json:"performer,omitempty"`
	Result             search.ReferenceOrString `json:"result,omitempty"`
	ResultsInterpreter search.ReferenceOrString `json:"results-interpreter,omitempty"`
	Specimen           search.ReferenceOrString `json:"specimen,omitempty"`
	Status             search.TokenOrString     `json:"status,omitempty"`
	Subject            search.ReferenceOrString `json:"subject,omitempty"`
}

// Map implements the search.Parameters interface for DiagnosticReportParams.
func (p DiagnosticReportParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Encounter != nil {
		m[search.ParameterKey{Name: "encounter"}] = p.Encounter.MatchesAll()
	}
	if p.BasedOn != nil {
		m[search.ParameterKey{Name: "based-on"}] = p.BasedOn.MatchesAll()
	}
	if p.Category != nil {
		m[search.ParameterKey{Name: "category"}] = p.Category.MatchesAll()
	}
	if p.Conclusion != nil {
		m[search.ParameterKey{Name: "conclusion"}] = p.Conclusion.MatchesAll()
	}
	if p.Issued != nil {
		m[search.ParameterKey{Name: "issued"}] = p.Issued.MatchesAll()
	}
	if p.Media != nil {
		m[search.ParameterKey{Name: "media"}] = p.Media.MatchesAll()
	}
	if p.Performer != nil {
		m[search.ParameterKey{Name: "performer"}] = p.Performer.MatchesAll()
	}
	if p.Result != nil {
		m[search.ParameterKey{Name: "result"}] = p.Result.MatchesAll()
	}
	if p.ResultsInterpreter != nil {
		m[search.ParameterKey{Name: "results-interpreter"}] = p.ResultsInterpreter.MatchesAll()
	}
	if p.Specimen != nil {
		m[search.ParameterKey{Name: "specimen"}] = p.Specimen.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}

	return m
}

// DocumentManifestParams contains typed search parameters for DocumentManifest resources.
type DocumentManifestParams struct {
	// DocumentManifest-specific search parameters
	Identifier  search.TokenOrString     `json:"identifier,omitempty"`
	Patient     search.ReferenceOrString `json:"patient,omitempty"`
	Type        search.TokenOrString     `json:"type,omitempty"`
	Author      search.ReferenceOrString `json:"author,omitempty"`
	Created     search.DateOrString      `json:"created,omitempty"`
	Description search.StringOrString    `json:"description,omitempty"`
	Item        search.ReferenceOrString `json:"item,omitempty"`
	Recipient   search.ReferenceOrString `json:"recipient,omitempty"`
	RelatedId   search.TokenOrString     `json:"related-id,omitempty"`
	RelatedRef  search.ReferenceOrString `json:"related-ref,omitempty"`
	Source      search.UriOrString       `json:"source,omitempty"`
	Status      search.TokenOrString     `json:"status,omitempty"`
	Subject     search.ReferenceOrString `json:"subject,omitempty"`
}

// Map implements the search.Parameters interface for DocumentManifestParams.
func (p DocumentManifestParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}
	if p.Author != nil {
		m[search.ParameterKey{Name: "author"}] = p.Author.MatchesAll()
	}
	if p.Created != nil {
		m[search.ParameterKey{Name: "created"}] = p.Created.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Item != nil {
		m[search.ParameterKey{Name: "item"}] = p.Item.MatchesAll()
	}
	if p.Recipient != nil {
		m[search.ParameterKey{Name: "recipient"}] = p.Recipient.MatchesAll()
	}
	if p.RelatedId != nil {
		m[search.ParameterKey{Name: "related-id"}] = p.RelatedId.MatchesAll()
	}
	if p.RelatedRef != nil {
		m[search.ParameterKey{Name: "related-ref"}] = p.RelatedRef.MatchesAll()
	}
	if p.Source != nil {
		m[search.ParameterKey{Name: "source"}] = p.Source.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}

	return m
}

// DocumentReferenceParams contains typed search parameters for DocumentReference resources.
type DocumentReferenceParams struct {
	// DocumentReference-specific search parameters
	Identifier    search.TokenOrString     `json:"identifier,omitempty"`
	Patient       search.ReferenceOrString `json:"patient,omitempty"`
	Type          search.TokenOrString     `json:"type,omitempty"`
	Encounter     search.ReferenceOrString `json:"encounter,omitempty"`
	Authenticator search.ReferenceOrString `json:"authenticator,omitempty"`
	Author        search.ReferenceOrString `json:"author,omitempty"`
	Category      search.TokenOrString     `json:"category,omitempty"`
	Contenttype   search.TokenOrString     `json:"contenttype,omitempty"`
	Custodian     search.ReferenceOrString `json:"custodian,omitempty"`
	Date          search.DateOrString      `json:"date,omitempty"`
	Description   search.StringOrString    `json:"description,omitempty"`
	Event         search.TokenOrString     `json:"event,omitempty"`
	Facility      search.TokenOrString     `json:"facility,omitempty"`
	Format        search.TokenOrString     `json:"format,omitempty"`
	Language      search.TokenOrString     `json:"language,omitempty"`
	Location      search.UriOrString       `json:"location,omitempty"`
	Period        search.DateOrString      `json:"period,omitempty"`
	Related       search.ReferenceOrString `json:"related,omitempty"`
	Relatesto     search.ReferenceOrString `json:"relatesto,omitempty"`
	Relation      search.TokenOrString     `json:"relation,omitempty"`
	SecurityLabel search.TokenOrString     `json:"security-label,omitempty"`
	Setting       search.TokenOrString     `json:"setting,omitempty"`
	Status        search.TokenOrString     `json:"status,omitempty"`
	Subject       search.ReferenceOrString `json:"subject,omitempty"`
	Relationship  search.CompositeOrString `json:"relationship,omitempty"`
}

// Map implements the search.Parameters interface for DocumentReferenceParams.
func (p DocumentReferenceParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}
	if p.Encounter != nil {
		m[search.ParameterKey{Name: "encounter"}] = p.Encounter.MatchesAll()
	}
	if p.Authenticator != nil {
		m[search.ParameterKey{Name: "authenticator"}] = p.Authenticator.MatchesAll()
	}
	if p.Author != nil {
		m[search.ParameterKey{Name: "author"}] = p.Author.MatchesAll()
	}
	if p.Category != nil {
		m[search.ParameterKey{Name: "category"}] = p.Category.MatchesAll()
	}
	if p.Contenttype != nil {
		m[search.ParameterKey{Name: "contenttype"}] = p.Contenttype.MatchesAll()
	}
	if p.Custodian != nil {
		m[search.ParameterKey{Name: "custodian"}] = p.Custodian.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Event != nil {
		m[search.ParameterKey{Name: "event"}] = p.Event.MatchesAll()
	}
	if p.Facility != nil {
		m[search.ParameterKey{Name: "facility"}] = p.Facility.MatchesAll()
	}
	if p.Format != nil {
		m[search.ParameterKey{Name: "format"}] = p.Format.MatchesAll()
	}
	if p.Language != nil {
		m[search.ParameterKey{Name: "language"}] = p.Language.MatchesAll()
	}
	if p.Location != nil {
		m[search.ParameterKey{Name: "location"}] = p.Location.MatchesAll()
	}
	if p.Period != nil {
		m[search.ParameterKey{Name: "period"}] = p.Period.MatchesAll()
	}
	if p.Related != nil {
		m[search.ParameterKey{Name: "related"}] = p.Related.MatchesAll()
	}
	if p.Relatesto != nil {
		m[search.ParameterKey{Name: "relatesto"}] = p.Relatesto.MatchesAll()
	}
	if p.Relation != nil {
		m[search.ParameterKey{Name: "relation"}] = p.Relation.MatchesAll()
	}
	if p.SecurityLabel != nil {
		m[search.ParameterKey{Name: "security-label"}] = p.SecurityLabel.MatchesAll()
	}
	if p.Setting != nil {
		m[search.ParameterKey{Name: "setting"}] = p.Setting.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}
	if p.Relationship != nil {
		m[search.ParameterKey{Name: "relationship"}] = p.Relationship.MatchesAll()
	}

	return m
}

// EncounterParams contains typed search parameters for Encounter resources.
type EncounterParams struct {
	// Encounter-specific search parameters
	Date               search.DateOrString      `json:"date,omitempty"`
	Identifier         search.TokenOrString     `json:"identifier,omitempty"`
	Patient            search.ReferenceOrString `json:"patient,omitempty"`
	Type               search.TokenOrString     `json:"type,omitempty"`
	Account            search.ReferenceOrString `json:"account,omitempty"`
	Appointment        search.ReferenceOrString `json:"appointment,omitempty"`
	BasedOn            search.ReferenceOrString `json:"based-on,omitempty"`
	Class              search.TokenOrString     `json:"class,omitempty"`
	Diagnosis          search.ReferenceOrString `json:"diagnosis,omitempty"`
	EpisodeOfCare      search.ReferenceOrString `json:"episode-of-care,omitempty"`
	Length             search.QuantityOrString  `json:"length,omitempty"`
	Location           search.ReferenceOrString `json:"location,omitempty"`
	LocationPeriod     search.DateOrString      `json:"location-period,omitempty"`
	PartOf             search.ReferenceOrString `json:"part-of,omitempty"`
	Participant        search.ReferenceOrString `json:"participant,omitempty"`
	ParticipantType    search.TokenOrString     `json:"participant-type,omitempty"`
	Practitioner       search.ReferenceOrString `json:"practitioner,omitempty"`
	ReasonCode         search.TokenOrString     `json:"reason-code,omitempty"`
	ReasonReference    search.ReferenceOrString `json:"reason-reference,omitempty"`
	ServiceProvider    search.ReferenceOrString `json:"service-provider,omitempty"`
	SpecialArrangement search.TokenOrString     `json:"special-arrangement,omitempty"`
	Status             search.TokenOrString     `json:"status,omitempty"`
	Subject            search.ReferenceOrString `json:"subject,omitempty"`
}

// Map implements the search.Parameters interface for EncounterParams.
func (p EncounterParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}
	if p.Account != nil {
		m[search.ParameterKey{Name: "account"}] = p.Account.MatchesAll()
	}
	if p.Appointment != nil {
		m[search.ParameterKey{Name: "appointment"}] = p.Appointment.MatchesAll()
	}
	if p.BasedOn != nil {
		m[search.ParameterKey{Name: "based-on"}] = p.BasedOn.MatchesAll()
	}
	if p.Class != nil {
		m[search.ParameterKey{Name: "class"}] = p.Class.MatchesAll()
	}
	if p.Diagnosis != nil {
		m[search.ParameterKey{Name: "diagnosis"}] = p.Diagnosis.MatchesAll()
	}
	if p.EpisodeOfCare != nil {
		m[search.ParameterKey{Name: "episode-of-care"}] = p.EpisodeOfCare.MatchesAll()
	}
	if p.Length != nil {
		m[search.ParameterKey{Name: "length"}] = p.Length.MatchesAll()
	}
	if p.Location != nil {
		m[search.ParameterKey{Name: "location"}] = p.Location.MatchesAll()
	}
	if p.LocationPeriod != nil {
		m[search.ParameterKey{Name: "location-period"}] = p.LocationPeriod.MatchesAll()
	}
	if p.PartOf != nil {
		m[search.ParameterKey{Name: "part-of"}] = p.PartOf.MatchesAll()
	}
	if p.Participant != nil {
		m[search.ParameterKey{Name: "participant"}] = p.Participant.MatchesAll()
	}
	if p.ParticipantType != nil {
		m[search.ParameterKey{Name: "participant-type"}] = p.ParticipantType.MatchesAll()
	}
	if p.Practitioner != nil {
		m[search.ParameterKey{Name: "practitioner"}] = p.Practitioner.MatchesAll()
	}
	if p.ReasonCode != nil {
		m[search.ParameterKey{Name: "reason-code"}] = p.ReasonCode.MatchesAll()
	}
	if p.ReasonReference != nil {
		m[search.ParameterKey{Name: "reason-reference"}] = p.ReasonReference.MatchesAll()
	}
	if p.ServiceProvider != nil {
		m[search.ParameterKey{Name: "service-provider"}] = p.ServiceProvider.MatchesAll()
	}
	if p.SpecialArrangement != nil {
		m[search.ParameterKey{Name: "special-arrangement"}] = p.SpecialArrangement.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}

	return m
}

// EndpointParams contains typed search parameters for Endpoint resources.
type EndpointParams struct {
	// Endpoint-specific search parameters
	ConnectionType search.TokenOrString     `json:"connection-type,omitempty"`
	Identifier     search.TokenOrString     `json:"identifier,omitempty"`
	Name           search.StringOrString    `json:"name,omitempty"`
	Organization   search.ReferenceOrString `json:"organization,omitempty"`
	PayloadType    search.TokenOrString     `json:"payload-type,omitempty"`
	Status         search.TokenOrString     `json:"status,omitempty"`
}

// Map implements the search.Parameters interface for EndpointParams.
func (p EndpointParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.ConnectionType != nil {
		m[search.ParameterKey{Name: "connection-type"}] = p.ConnectionType.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Organization != nil {
		m[search.ParameterKey{Name: "organization"}] = p.Organization.MatchesAll()
	}
	if p.PayloadType != nil {
		m[search.ParameterKey{Name: "payload-type"}] = p.PayloadType.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}

	return m
}

// EnrollmentRequestParams contains typed search parameters for EnrollmentRequest resources.
type EnrollmentRequestParams struct {
	// EnrollmentRequest-specific search parameters
	Identifier search.TokenOrString     `json:"identifier,omitempty"`
	Patient    search.ReferenceOrString `json:"patient,omitempty"`
	Status     search.TokenOrString     `json:"status,omitempty"`
	Subject    search.ReferenceOrString `json:"subject,omitempty"`
}

// Map implements the search.Parameters interface for EnrollmentRequestParams.
func (p EnrollmentRequestParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}

	return m
}

// EnrollmentResponseParams contains typed search parameters for EnrollmentResponse resources.
type EnrollmentResponseParams struct {
	// EnrollmentResponse-specific search parameters
	Identifier search.TokenOrString     `json:"identifier,omitempty"`
	Request    search.ReferenceOrString `json:"request,omitempty"`
	Status     search.TokenOrString     `json:"status,omitempty"`
}

// Map implements the search.Parameters interface for EnrollmentResponseParams.
func (p EnrollmentResponseParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Request != nil {
		m[search.ParameterKey{Name: "request"}] = p.Request.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}

	return m
}

// EpisodeOfCareParams contains typed search parameters for EpisodeOfCare resources.
type EpisodeOfCareParams struct {
	// EpisodeOfCare-specific search parameters
	Date             search.DateOrString      `json:"date,omitempty"`
	Identifier       search.TokenOrString     `json:"identifier,omitempty"`
	Patient          search.ReferenceOrString `json:"patient,omitempty"`
	Type             search.TokenOrString     `json:"type,omitempty"`
	CareManager      search.ReferenceOrString `json:"care-manager,omitempty"`
	Condition        search.ReferenceOrString `json:"condition,omitempty"`
	IncomingReferral search.ReferenceOrString `json:"incoming-referral,omitempty"`
	Organization     search.ReferenceOrString `json:"organization,omitempty"`
	Status           search.TokenOrString     `json:"status,omitempty"`
}

// Map implements the search.Parameters interface for EpisodeOfCareParams.
func (p EpisodeOfCareParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}
	if p.CareManager != nil {
		m[search.ParameterKey{Name: "care-manager"}] = p.CareManager.MatchesAll()
	}
	if p.Condition != nil {
		m[search.ParameterKey{Name: "condition"}] = p.Condition.MatchesAll()
	}
	if p.IncomingReferral != nil {
		m[search.ParameterKey{Name: "incoming-referral"}] = p.IncomingReferral.MatchesAll()
	}
	if p.Organization != nil {
		m[search.ParameterKey{Name: "organization"}] = p.Organization.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}

	return m
}

// EventDefinitionParams contains typed search parameters for EventDefinition resources.
type EventDefinitionParams struct {
	// EventDefinition-specific search parameters
	ComposedOf          search.ReferenceOrString `json:"composed-of,omitempty"`
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Date                search.DateOrString      `json:"date,omitempty"`
	DependsOn           search.ReferenceOrString `json:"depends-on,omitempty"`
	DerivedFrom         search.ReferenceOrString `json:"derived-from,omitempty"`
	Description         search.StringOrString    `json:"description,omitempty"`
	Effective           search.DateOrString      `json:"effective,omitempty"`
	Identifier          search.TokenOrString     `json:"identifier,omitempty"`
	Jurisdiction        search.TokenOrString     `json:"jurisdiction,omitempty"`
	Name                search.StringOrString    `json:"name,omitempty"`
	Predecessor         search.ReferenceOrString `json:"predecessor,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	Successor           search.ReferenceOrString `json:"successor,omitempty"`
	Title               search.StringOrString    `json:"title,omitempty"`
	Topic               search.TokenOrString     `json:"topic,omitempty"`
	Url                 search.UriOrString       `json:"url,omitempty"`
	Version             search.TokenOrString     `json:"version,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
}

// Map implements the search.Parameters interface for EventDefinitionParams.
func (p EventDefinitionParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.ComposedOf != nil {
		m[search.ParameterKey{Name: "composed-of"}] = p.ComposedOf.MatchesAll()
	}
	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.DependsOn != nil {
		m[search.ParameterKey{Name: "depends-on"}] = p.DependsOn.MatchesAll()
	}
	if p.DerivedFrom != nil {
		m[search.ParameterKey{Name: "derived-from"}] = p.DerivedFrom.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Effective != nil {
		m[search.ParameterKey{Name: "effective"}] = p.Effective.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Jurisdiction != nil {
		m[search.ParameterKey{Name: "jurisdiction"}] = p.Jurisdiction.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Predecessor != nil {
		m[search.ParameterKey{Name: "predecessor"}] = p.Predecessor.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Successor != nil {
		m[search.ParameterKey{Name: "successor"}] = p.Successor.MatchesAll()
	}
	if p.Title != nil {
		m[search.ParameterKey{Name: "title"}] = p.Title.MatchesAll()
	}
	if p.Topic != nil {
		m[search.ParameterKey{Name: "topic"}] = p.Topic.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}

	return m
}

// EvidenceParams contains typed search parameters for Evidence resources.
type EvidenceParams struct {
	// Evidence-specific search parameters
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Date                search.DateOrString      `json:"date,omitempty"`
	Description         search.StringOrString    `json:"description,omitempty"`
	Identifier          search.TokenOrString     `json:"identifier,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	Title               search.StringOrString    `json:"title,omitempty"`
	Url                 search.UriOrString       `json:"url,omitempty"`
	Version             search.TokenOrString     `json:"version,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
}

// Map implements the search.Parameters interface for EvidenceParams.
func (p EvidenceParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Title != nil {
		m[search.ParameterKey{Name: "title"}] = p.Title.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}

	return m
}

// EvidenceReportParams contains typed search parameters for EvidenceReport resources.
type EvidenceReportParams struct {
	// EvidenceReport-specific search parameters
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Identifier          search.TokenOrString     `json:"identifier,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	Url                 search.UriOrString       `json:"url,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
}

// Map implements the search.Parameters interface for EvidenceReportParams.
func (p EvidenceReportParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}

	return m
}

// EvidenceVariableParams contains typed search parameters for EvidenceVariable resources.
type EvidenceVariableParams struct {
	// EvidenceVariable-specific search parameters
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Date                search.DateOrString      `json:"date,omitempty"`
	Description         search.StringOrString    `json:"description,omitempty"`
	Identifier          search.TokenOrString     `json:"identifier,omitempty"`
	Name                search.StringOrString    `json:"name,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	Title               search.StringOrString    `json:"title,omitempty"`
	Url                 search.UriOrString       `json:"url,omitempty"`
	Version             search.TokenOrString     `json:"version,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
}

// Map implements the search.Parameters interface for EvidenceVariableParams.
func (p EvidenceVariableParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Title != nil {
		m[search.ParameterKey{Name: "title"}] = p.Title.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}

	return m
}

// ExampleScenarioParams contains typed search parameters for ExampleScenario resources.
type ExampleScenarioParams struct {
	// ExampleScenario-specific search parameters
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Date                search.DateOrString      `json:"date,omitempty"`
	Identifier          search.TokenOrString     `json:"identifier,omitempty"`
	Jurisdiction        search.TokenOrString     `json:"jurisdiction,omitempty"`
	Name                search.StringOrString    `json:"name,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	Url                 search.UriOrString       `json:"url,omitempty"`
	Version             search.TokenOrString     `json:"version,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
}

// Map implements the search.Parameters interface for ExampleScenarioParams.
func (p ExampleScenarioParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Jurisdiction != nil {
		m[search.ParameterKey{Name: "jurisdiction"}] = p.Jurisdiction.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}

	return m
}

// ExplanationOfBenefitParams contains typed search parameters for ExplanationOfBenefit resources.
type ExplanationOfBenefitParams struct {
	// ExplanationOfBenefit-specific search parameters
	CareTeam     search.ReferenceOrString `json:"care-team,omitempty"`
	Claim        search.ReferenceOrString `json:"claim,omitempty"`
	Coverage     search.ReferenceOrString `json:"coverage,omitempty"`
	Created      search.DateOrString      `json:"created,omitempty"`
	DetailUdi    search.ReferenceOrString `json:"detail-udi,omitempty"`
	Disposition  search.StringOrString    `json:"disposition,omitempty"`
	Encounter    search.ReferenceOrString `json:"encounter,omitempty"`
	Enterer      search.ReferenceOrString `json:"enterer,omitempty"`
	Facility     search.ReferenceOrString `json:"facility,omitempty"`
	Identifier   search.TokenOrString     `json:"identifier,omitempty"`
	ItemUdi      search.ReferenceOrString `json:"item-udi,omitempty"`
	Patient      search.ReferenceOrString `json:"patient,omitempty"`
	Payee        search.ReferenceOrString `json:"payee,omitempty"`
	ProcedureUdi search.ReferenceOrString `json:"procedure-udi,omitempty"`
	Provider     search.ReferenceOrString `json:"provider,omitempty"`
	Status       search.TokenOrString     `json:"status,omitempty"`
	SubdetailUdi search.ReferenceOrString `json:"subdetail-udi,omitempty"`
}

// Map implements the search.Parameters interface for ExplanationOfBenefitParams.
func (p ExplanationOfBenefitParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.CareTeam != nil {
		m[search.ParameterKey{Name: "care-team"}] = p.CareTeam.MatchesAll()
	}
	if p.Claim != nil {
		m[search.ParameterKey{Name: "claim"}] = p.Claim.MatchesAll()
	}
	if p.Coverage != nil {
		m[search.ParameterKey{Name: "coverage"}] = p.Coverage.MatchesAll()
	}
	if p.Created != nil {
		m[search.ParameterKey{Name: "created"}] = p.Created.MatchesAll()
	}
	if p.DetailUdi != nil {
		m[search.ParameterKey{Name: "detail-udi"}] = p.DetailUdi.MatchesAll()
	}
	if p.Disposition != nil {
		m[search.ParameterKey{Name: "disposition"}] = p.Disposition.MatchesAll()
	}
	if p.Encounter != nil {
		m[search.ParameterKey{Name: "encounter"}] = p.Encounter.MatchesAll()
	}
	if p.Enterer != nil {
		m[search.ParameterKey{Name: "enterer"}] = p.Enterer.MatchesAll()
	}
	if p.Facility != nil {
		m[search.ParameterKey{Name: "facility"}] = p.Facility.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.ItemUdi != nil {
		m[search.ParameterKey{Name: "item-udi"}] = p.ItemUdi.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Payee != nil {
		m[search.ParameterKey{Name: "payee"}] = p.Payee.MatchesAll()
	}
	if p.ProcedureUdi != nil {
		m[search.ParameterKey{Name: "procedure-udi"}] = p.ProcedureUdi.MatchesAll()
	}
	if p.Provider != nil {
		m[search.ParameterKey{Name: "provider"}] = p.Provider.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.SubdetailUdi != nil {
		m[search.ParameterKey{Name: "subdetail-udi"}] = p.SubdetailUdi.MatchesAll()
	}

	return m
}

// FamilyMemberHistoryParams contains typed search parameters for FamilyMemberHistory resources.
type FamilyMemberHistoryParams struct {
	// FamilyMemberHistory-specific search parameters
	Code                  search.TokenOrString     `json:"code,omitempty"`
	Date                  search.DateOrString      `json:"date,omitempty"`
	Identifier            search.TokenOrString     `json:"identifier,omitempty"`
	Patient               search.ReferenceOrString `json:"patient,omitempty"`
	InstantiatesCanonical search.ReferenceOrString `json:"instantiates-canonical,omitempty"`
	InstantiatesUri       search.UriOrString       `json:"instantiates-uri,omitempty"`
	Relationship          search.TokenOrString     `json:"relationship,omitempty"`
	Sex                   search.TokenOrString     `json:"sex,omitempty"`
	Status                search.TokenOrString     `json:"status,omitempty"`
}

// Map implements the search.Parameters interface for FamilyMemberHistoryParams.
func (p FamilyMemberHistoryParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.InstantiatesCanonical != nil {
		m[search.ParameterKey{Name: "instantiates-canonical"}] = p.InstantiatesCanonical.MatchesAll()
	}
	if p.InstantiatesUri != nil {
		m[search.ParameterKey{Name: "instantiates-uri"}] = p.InstantiatesUri.MatchesAll()
	}
	if p.Relationship != nil {
		m[search.ParameterKey{Name: "relationship"}] = p.Relationship.MatchesAll()
	}
	if p.Sex != nil {
		m[search.ParameterKey{Name: "sex"}] = p.Sex.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}

	return m
}

// FlagParams contains typed search parameters for Flag resources.
type FlagParams struct {
	// Flag-specific search parameters
	Date       search.DateOrString      `json:"date,omitempty"`
	Patient    search.ReferenceOrString `json:"patient,omitempty"`
	Encounter  search.ReferenceOrString `json:"encounter,omitempty"`
	Author     search.ReferenceOrString `json:"author,omitempty"`
	Identifier search.TokenOrString     `json:"identifier,omitempty"`
	Subject    search.ReferenceOrString `json:"subject,omitempty"`
}

// Map implements the search.Parameters interface for FlagParams.
func (p FlagParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Encounter != nil {
		m[search.ParameterKey{Name: "encounter"}] = p.Encounter.MatchesAll()
	}
	if p.Author != nil {
		m[search.ParameterKey{Name: "author"}] = p.Author.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}

	return m
}

// GoalParams contains typed search parameters for Goal resources.
type GoalParams struct {
	// Goal-specific search parameters
	Identifier        search.TokenOrString     `json:"identifier,omitempty"`
	Patient           search.ReferenceOrString `json:"patient,omitempty"`
	AchievementStatus search.TokenOrString     `json:"achievement-status,omitempty"`
	Category          search.TokenOrString     `json:"category,omitempty"`
	LifecycleStatus   search.TokenOrString     `json:"lifecycle-status,omitempty"`
	StartDate         search.DateOrString      `json:"start-date,omitempty"`
	Subject           search.ReferenceOrString `json:"subject,omitempty"`
	TargetDate        search.DateOrString      `json:"target-date,omitempty"`
}

// Map implements the search.Parameters interface for GoalParams.
func (p GoalParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.AchievementStatus != nil {
		m[search.ParameterKey{Name: "achievement-status"}] = p.AchievementStatus.MatchesAll()
	}
	if p.Category != nil {
		m[search.ParameterKey{Name: "category"}] = p.Category.MatchesAll()
	}
	if p.LifecycleStatus != nil {
		m[search.ParameterKey{Name: "lifecycle-status"}] = p.LifecycleStatus.MatchesAll()
	}
	if p.StartDate != nil {
		m[search.ParameterKey{Name: "start-date"}] = p.StartDate.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}
	if p.TargetDate != nil {
		m[search.ParameterKey{Name: "target-date"}] = p.TargetDate.MatchesAll()
	}

	return m
}

// GraphDefinitionParams contains typed search parameters for GraphDefinition resources.
type GraphDefinitionParams struct {
	// GraphDefinition-specific search parameters
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Date                search.DateOrString      `json:"date,omitempty"`
	Description         search.StringOrString    `json:"description,omitempty"`
	Jurisdiction        search.TokenOrString     `json:"jurisdiction,omitempty"`
	Name                search.StringOrString    `json:"name,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	Url                 search.UriOrString       `json:"url,omitempty"`
	Version             search.TokenOrString     `json:"version,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
	Start               search.TokenOrString     `json:"start,omitempty"`
}

// Map implements the search.Parameters interface for GraphDefinitionParams.
func (p GraphDefinitionParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Jurisdiction != nil {
		m[search.ParameterKey{Name: "jurisdiction"}] = p.Jurisdiction.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}
	if p.Start != nil {
		m[search.ParameterKey{Name: "start"}] = p.Start.MatchesAll()
	}

	return m
}

// GroupParams contains typed search parameters for Group resources.
type GroupParams struct {
	// Group-specific search parameters
	Actual              search.TokenOrString     `json:"actual,omitempty"`
	Characteristic      search.TokenOrString     `json:"characteristic,omitempty"`
	Code                search.TokenOrString     `json:"code,omitempty"`
	Exclude             search.TokenOrString     `json:"exclude,omitempty"`
	Identifier          search.TokenOrString     `json:"identifier,omitempty"`
	ManagingEntity      search.ReferenceOrString `json:"managing-entity,omitempty"`
	Member              search.ReferenceOrString `json:"member,omitempty"`
	Type                search.TokenOrString     `json:"type,omitempty"`
	Value               search.TokenOrString     `json:"value,omitempty"`
	CharacteristicValue search.CompositeOrString `json:"characteristic-value,omitempty"`
}

// Map implements the search.Parameters interface for GroupParams.
func (p GroupParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Actual != nil {
		m[search.ParameterKey{Name: "actual"}] = p.Actual.MatchesAll()
	}
	if p.Characteristic != nil {
		m[search.ParameterKey{Name: "characteristic"}] = p.Characteristic.MatchesAll()
	}
	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.Exclude != nil {
		m[search.ParameterKey{Name: "exclude"}] = p.Exclude.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.ManagingEntity != nil {
		m[search.ParameterKey{Name: "managing-entity"}] = p.ManagingEntity.MatchesAll()
	}
	if p.Member != nil {
		m[search.ParameterKey{Name: "member"}] = p.Member.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}
	if p.Value != nil {
		m[search.ParameterKey{Name: "value"}] = p.Value.MatchesAll()
	}
	if p.CharacteristicValue != nil {
		m[search.ParameterKey{Name: "characteristic-value"}] = p.CharacteristicValue.MatchesAll()
	}

	return m
}

// GuidanceResponseParams contains typed search parameters for GuidanceResponse resources.
type GuidanceResponseParams struct {
	// GuidanceResponse-specific search parameters
	Identifier search.TokenOrString     `json:"identifier,omitempty"`
	Patient    search.ReferenceOrString `json:"patient,omitempty"`
	Request    search.TokenOrString     `json:"request,omitempty"`
	Subject    search.ReferenceOrString `json:"subject,omitempty"`
}

// Map implements the search.Parameters interface for GuidanceResponseParams.
func (p GuidanceResponseParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Request != nil {
		m[search.ParameterKey{Name: "request"}] = p.Request.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}

	return m
}

// HealthcareServiceParams contains typed search parameters for HealthcareService resources.
type HealthcareServiceParams struct {
	// HealthcareService-specific search parameters
	Active          search.TokenOrString     `json:"active,omitempty"`
	Characteristic  search.TokenOrString     `json:"characteristic,omitempty"`
	CoverageArea    search.ReferenceOrString `json:"coverage-area,omitempty"`
	Endpoint        search.ReferenceOrString `json:"endpoint,omitempty"`
	Identifier      search.TokenOrString     `json:"identifier,omitempty"`
	Location        search.ReferenceOrString `json:"location,omitempty"`
	Name            search.StringOrString    `json:"name,omitempty"`
	Organization    search.ReferenceOrString `json:"organization,omitempty"`
	Program         search.TokenOrString     `json:"program,omitempty"`
	ServiceCategory search.TokenOrString     `json:"service-category,omitempty"`
	ServiceType     search.TokenOrString     `json:"service-type,omitempty"`
	Specialty       search.TokenOrString     `json:"specialty,omitempty"`
}

// Map implements the search.Parameters interface for HealthcareServiceParams.
func (p HealthcareServiceParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Active != nil {
		m[search.ParameterKey{Name: "active"}] = p.Active.MatchesAll()
	}
	if p.Characteristic != nil {
		m[search.ParameterKey{Name: "characteristic"}] = p.Characteristic.MatchesAll()
	}
	if p.CoverageArea != nil {
		m[search.ParameterKey{Name: "coverage-area"}] = p.CoverageArea.MatchesAll()
	}
	if p.Endpoint != nil {
		m[search.ParameterKey{Name: "endpoint"}] = p.Endpoint.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Location != nil {
		m[search.ParameterKey{Name: "location"}] = p.Location.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Organization != nil {
		m[search.ParameterKey{Name: "organization"}] = p.Organization.MatchesAll()
	}
	if p.Program != nil {
		m[search.ParameterKey{Name: "program"}] = p.Program.MatchesAll()
	}
	if p.ServiceCategory != nil {
		m[search.ParameterKey{Name: "service-category"}] = p.ServiceCategory.MatchesAll()
	}
	if p.ServiceType != nil {
		m[search.ParameterKey{Name: "service-type"}] = p.ServiceType.MatchesAll()
	}
	if p.Specialty != nil {
		m[search.ParameterKey{Name: "specialty"}] = p.Specialty.MatchesAll()
	}

	return m
}

// ImagingStudyParams contains typed search parameters for ImagingStudy resources.
type ImagingStudyParams struct {
	// ImagingStudy-specific search parameters
	Identifier  search.TokenOrString     `json:"identifier,omitempty"`
	Patient     search.ReferenceOrString `json:"patient,omitempty"`
	Basedon     search.ReferenceOrString `json:"basedon,omitempty"`
	Bodysite    search.TokenOrString     `json:"bodysite,omitempty"`
	DicomClass  search.TokenOrString     `json:"dicom-class,omitempty"`
	Encounter   search.ReferenceOrString `json:"encounter,omitempty"`
	Endpoint    search.ReferenceOrString `json:"endpoint,omitempty"`
	Instance    search.TokenOrString     `json:"instance,omitempty"`
	Interpreter search.ReferenceOrString `json:"interpreter,omitempty"`
	Modality    search.TokenOrString     `json:"modality,omitempty"`
	Performer   search.ReferenceOrString `json:"performer,omitempty"`
	Reason      search.TokenOrString     `json:"reason,omitempty"`
	Referrer    search.ReferenceOrString `json:"referrer,omitempty"`
	Series      search.TokenOrString     `json:"series,omitempty"`
	Started     search.DateOrString      `json:"started,omitempty"`
	Status      search.TokenOrString     `json:"status,omitempty"`
	Subject     search.ReferenceOrString `json:"subject,omitempty"`
}

// Map implements the search.Parameters interface for ImagingStudyParams.
func (p ImagingStudyParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Basedon != nil {
		m[search.ParameterKey{Name: "basedon"}] = p.Basedon.MatchesAll()
	}
	if p.Bodysite != nil {
		m[search.ParameterKey{Name: "bodysite"}] = p.Bodysite.MatchesAll()
	}
	if p.DicomClass != nil {
		m[search.ParameterKey{Name: "dicom-class"}] = p.DicomClass.MatchesAll()
	}
	if p.Encounter != nil {
		m[search.ParameterKey{Name: "encounter"}] = p.Encounter.MatchesAll()
	}
	if p.Endpoint != nil {
		m[search.ParameterKey{Name: "endpoint"}] = p.Endpoint.MatchesAll()
	}
	if p.Instance != nil {
		m[search.ParameterKey{Name: "instance"}] = p.Instance.MatchesAll()
	}
	if p.Interpreter != nil {
		m[search.ParameterKey{Name: "interpreter"}] = p.Interpreter.MatchesAll()
	}
	if p.Modality != nil {
		m[search.ParameterKey{Name: "modality"}] = p.Modality.MatchesAll()
	}
	if p.Performer != nil {
		m[search.ParameterKey{Name: "performer"}] = p.Performer.MatchesAll()
	}
	if p.Reason != nil {
		m[search.ParameterKey{Name: "reason"}] = p.Reason.MatchesAll()
	}
	if p.Referrer != nil {
		m[search.ParameterKey{Name: "referrer"}] = p.Referrer.MatchesAll()
	}
	if p.Series != nil {
		m[search.ParameterKey{Name: "series"}] = p.Series.MatchesAll()
	}
	if p.Started != nil {
		m[search.ParameterKey{Name: "started"}] = p.Started.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}

	return m
}

// ImmunizationParams contains typed search parameters for Immunization resources.
type ImmunizationParams struct {
	// Immunization-specific search parameters
	Date            search.DateOrString      `json:"date,omitempty"`
	Identifier      search.TokenOrString     `json:"identifier,omitempty"`
	Patient         search.ReferenceOrString `json:"patient,omitempty"`
	Location        search.ReferenceOrString `json:"location,omitempty"`
	LotNumber       search.StringOrString    `json:"lot-number,omitempty"`
	Manufacturer    search.ReferenceOrString `json:"manufacturer,omitempty"`
	Performer       search.ReferenceOrString `json:"performer,omitempty"`
	Reaction        search.ReferenceOrString `json:"reaction,omitempty"`
	ReactionDate    search.DateOrString      `json:"reaction-date,omitempty"`
	ReasonCode      search.TokenOrString     `json:"reason-code,omitempty"`
	ReasonReference search.ReferenceOrString `json:"reason-reference,omitempty"`
	Series          search.StringOrString    `json:"series,omitempty"`
	Status          search.TokenOrString     `json:"status,omitempty"`
	StatusReason    search.TokenOrString     `json:"status-reason,omitempty"`
	TargetDisease   search.TokenOrString     `json:"target-disease,omitempty"`
	VaccineCode     search.TokenOrString     `json:"vaccine-code,omitempty"`
}

// Map implements the search.Parameters interface for ImmunizationParams.
func (p ImmunizationParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Location != nil {
		m[search.ParameterKey{Name: "location"}] = p.Location.MatchesAll()
	}
	if p.LotNumber != nil {
		m[search.ParameterKey{Name: "lot-number"}] = p.LotNumber.MatchesAll()
	}
	if p.Manufacturer != nil {
		m[search.ParameterKey{Name: "manufacturer"}] = p.Manufacturer.MatchesAll()
	}
	if p.Performer != nil {
		m[search.ParameterKey{Name: "performer"}] = p.Performer.MatchesAll()
	}
	if p.Reaction != nil {
		m[search.ParameterKey{Name: "reaction"}] = p.Reaction.MatchesAll()
	}
	if p.ReactionDate != nil {
		m[search.ParameterKey{Name: "reaction-date"}] = p.ReactionDate.MatchesAll()
	}
	if p.ReasonCode != nil {
		m[search.ParameterKey{Name: "reason-code"}] = p.ReasonCode.MatchesAll()
	}
	if p.ReasonReference != nil {
		m[search.ParameterKey{Name: "reason-reference"}] = p.ReasonReference.MatchesAll()
	}
	if p.Series != nil {
		m[search.ParameterKey{Name: "series"}] = p.Series.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.StatusReason != nil {
		m[search.ParameterKey{Name: "status-reason"}] = p.StatusReason.MatchesAll()
	}
	if p.TargetDisease != nil {
		m[search.ParameterKey{Name: "target-disease"}] = p.TargetDisease.MatchesAll()
	}
	if p.VaccineCode != nil {
		m[search.ParameterKey{Name: "vaccine-code"}] = p.VaccineCode.MatchesAll()
	}

	return m
}

// ImmunizationEvaluationParams contains typed search parameters for ImmunizationEvaluation resources.
type ImmunizationEvaluationParams struct {
	// ImmunizationEvaluation-specific search parameters
	Date              search.DateOrString      `json:"date,omitempty"`
	DoseStatus        search.TokenOrString     `json:"dose-status,omitempty"`
	Identifier        search.TokenOrString     `json:"identifier,omitempty"`
	ImmunizationEvent search.ReferenceOrString `json:"immunization-event,omitempty"`
	Patient           search.ReferenceOrString `json:"patient,omitempty"`
	Status            search.TokenOrString     `json:"status,omitempty"`
	TargetDisease     search.TokenOrString     `json:"target-disease,omitempty"`
}

// Map implements the search.Parameters interface for ImmunizationEvaluationParams.
func (p ImmunizationEvaluationParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.DoseStatus != nil {
		m[search.ParameterKey{Name: "dose-status"}] = p.DoseStatus.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.ImmunizationEvent != nil {
		m[search.ParameterKey{Name: "immunization-event"}] = p.ImmunizationEvent.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.TargetDisease != nil {
		m[search.ParameterKey{Name: "target-disease"}] = p.TargetDisease.MatchesAll()
	}

	return m
}

// ImmunizationRecommendationParams contains typed search parameters for ImmunizationRecommendation resources.
type ImmunizationRecommendationParams struct {
	// ImmunizationRecommendation-specific search parameters
	Date          search.DateOrString      `json:"date,omitempty"`
	Identifier    search.TokenOrString     `json:"identifier,omitempty"`
	Information   search.ReferenceOrString `json:"information,omitempty"`
	Patient       search.ReferenceOrString `json:"patient,omitempty"`
	Status        search.TokenOrString     `json:"status,omitempty"`
	Support       search.ReferenceOrString `json:"support,omitempty"`
	TargetDisease search.TokenOrString     `json:"target-disease,omitempty"`
	VaccineType   search.TokenOrString     `json:"vaccine-type,omitempty"`
}

// Map implements the search.Parameters interface for ImmunizationRecommendationParams.
func (p ImmunizationRecommendationParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Information != nil {
		m[search.ParameterKey{Name: "information"}] = p.Information.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Support != nil {
		m[search.ParameterKey{Name: "support"}] = p.Support.MatchesAll()
	}
	if p.TargetDisease != nil {
		m[search.ParameterKey{Name: "target-disease"}] = p.TargetDisease.MatchesAll()
	}
	if p.VaccineType != nil {
		m[search.ParameterKey{Name: "vaccine-type"}] = p.VaccineType.MatchesAll()
	}

	return m
}

// ImplementationGuideParams contains typed search parameters for ImplementationGuide resources.
type ImplementationGuideParams struct {
	// ImplementationGuide-specific search parameters
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Date                search.DateOrString      `json:"date,omitempty"`
	Description         search.StringOrString    `json:"description,omitempty"`
	Jurisdiction        search.TokenOrString     `json:"jurisdiction,omitempty"`
	Name                search.StringOrString    `json:"name,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	Title               search.StringOrString    `json:"title,omitempty"`
	Url                 search.UriOrString       `json:"url,omitempty"`
	Version             search.TokenOrString     `json:"version,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
	DependsOn           search.ReferenceOrString `json:"depends-on,omitempty"`
	Experimental        search.TokenOrString     `json:"experimental,omitempty"`
	Global              search.ReferenceOrString `json:"global,omitempty"`
	Resource            search.ReferenceOrString `json:"resource,omitempty"`
}

// Map implements the search.Parameters interface for ImplementationGuideParams.
func (p ImplementationGuideParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Jurisdiction != nil {
		m[search.ParameterKey{Name: "jurisdiction"}] = p.Jurisdiction.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Title != nil {
		m[search.ParameterKey{Name: "title"}] = p.Title.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}
	if p.DependsOn != nil {
		m[search.ParameterKey{Name: "depends-on"}] = p.DependsOn.MatchesAll()
	}
	if p.Experimental != nil {
		m[search.ParameterKey{Name: "experimental"}] = p.Experimental.MatchesAll()
	}
	if p.Global != nil {
		m[search.ParameterKey{Name: "global"}] = p.Global.MatchesAll()
	}
	if p.Resource != nil {
		m[search.ParameterKey{Name: "resource"}] = p.Resource.MatchesAll()
	}

	return m
}

// IngredientParams contains typed search parameters for Ingredient resources.
type IngredientParams struct {
	// Ingredient-specific search parameters
	For                 search.ReferenceOrString `json:"for,omitempty"`
	Function            search.TokenOrString     `json:"function,omitempty"`
	Identifier          search.TokenOrString     `json:"identifier,omitempty"`
	Manufacturer        search.ReferenceOrString `json:"manufacturer,omitempty"`
	Role                search.TokenOrString     `json:"role,omitempty"`
	Substance           search.ReferenceOrString `json:"substance,omitempty"`
	SubstanceCode       search.TokenOrString     `json:"substance-code,omitempty"`
	SubstanceDefinition search.ReferenceOrString `json:"substance-definition,omitempty"`
}

// Map implements the search.Parameters interface for IngredientParams.
func (p IngredientParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.For != nil {
		m[search.ParameterKey{Name: "for"}] = p.For.MatchesAll()
	}
	if p.Function != nil {
		m[search.ParameterKey{Name: "function"}] = p.Function.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Manufacturer != nil {
		m[search.ParameterKey{Name: "manufacturer"}] = p.Manufacturer.MatchesAll()
	}
	if p.Role != nil {
		m[search.ParameterKey{Name: "role"}] = p.Role.MatchesAll()
	}
	if p.Substance != nil {
		m[search.ParameterKey{Name: "substance"}] = p.Substance.MatchesAll()
	}
	if p.SubstanceCode != nil {
		m[search.ParameterKey{Name: "substance-code"}] = p.SubstanceCode.MatchesAll()
	}
	if p.SubstanceDefinition != nil {
		m[search.ParameterKey{Name: "substance-definition"}] = p.SubstanceDefinition.MatchesAll()
	}

	return m
}

// InsurancePlanParams contains typed search parameters for InsurancePlan resources.
type InsurancePlanParams struct {
	// InsurancePlan-specific search parameters
	Address           search.StringOrString    `json:"address,omitempty"`
	AddressCity       search.StringOrString    `json:"address-city,omitempty"`
	AddressCountry    search.StringOrString    `json:"address-country,omitempty"`
	AddressPostalcode search.StringOrString    `json:"address-postalcode,omitempty"`
	AddressState      search.StringOrString    `json:"address-state,omitempty"`
	AddressUse        search.TokenOrString     `json:"address-use,omitempty"`
	AdministeredBy    search.ReferenceOrString `json:"administered-by,omitempty"`
	Endpoint          search.ReferenceOrString `json:"endpoint,omitempty"`
	Identifier        search.TokenOrString     `json:"identifier,omitempty"`
	Name              search.StringOrString    `json:"name,omitempty"`
	OwnedBy           search.ReferenceOrString `json:"owned-by,omitempty"`
	Phonetic          search.StringOrString    `json:"phonetic,omitempty"`
	Status            search.TokenOrString     `json:"status,omitempty"`
	Type              search.TokenOrString     `json:"type,omitempty"`
}

// Map implements the search.Parameters interface for InsurancePlanParams.
func (p InsurancePlanParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Address != nil {
		m[search.ParameterKey{Name: "address"}] = p.Address.MatchesAll()
	}
	if p.AddressCity != nil {
		m[search.ParameterKey{Name: "address-city"}] = p.AddressCity.MatchesAll()
	}
	if p.AddressCountry != nil {
		m[search.ParameterKey{Name: "address-country"}] = p.AddressCountry.MatchesAll()
	}
	if p.AddressPostalcode != nil {
		m[search.ParameterKey{Name: "address-postalcode"}] = p.AddressPostalcode.MatchesAll()
	}
	if p.AddressState != nil {
		m[search.ParameterKey{Name: "address-state"}] = p.AddressState.MatchesAll()
	}
	if p.AddressUse != nil {
		m[search.ParameterKey{Name: "address-use"}] = p.AddressUse.MatchesAll()
	}
	if p.AdministeredBy != nil {
		m[search.ParameterKey{Name: "administered-by"}] = p.AdministeredBy.MatchesAll()
	}
	if p.Endpoint != nil {
		m[search.ParameterKey{Name: "endpoint"}] = p.Endpoint.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.OwnedBy != nil {
		m[search.ParameterKey{Name: "owned-by"}] = p.OwnedBy.MatchesAll()
	}
	if p.Phonetic != nil {
		m[search.ParameterKey{Name: "phonetic"}] = p.Phonetic.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}

	return m
}

// InvoiceParams contains typed search parameters for Invoice resources.
type InvoiceParams struct {
	// Invoice-specific search parameters
	Account         search.ReferenceOrString `json:"account,omitempty"`
	Date            search.DateOrString      `json:"date,omitempty"`
	Identifier      search.TokenOrString     `json:"identifier,omitempty"`
	Issuer          search.ReferenceOrString `json:"issuer,omitempty"`
	Participant     search.ReferenceOrString `json:"participant,omitempty"`
	ParticipantRole search.TokenOrString     `json:"participant-role,omitempty"`
	Patient         search.ReferenceOrString `json:"patient,omitempty"`
	Recipient       search.ReferenceOrString `json:"recipient,omitempty"`
	Status          search.TokenOrString     `json:"status,omitempty"`
	Subject         search.ReferenceOrString `json:"subject,omitempty"`
	Totalgross      search.QuantityOrString  `json:"totalgross,omitempty"`
	Totalnet        search.QuantityOrString  `json:"totalnet,omitempty"`
	Type            search.TokenOrString     `json:"type,omitempty"`
}

// Map implements the search.Parameters interface for InvoiceParams.
func (p InvoiceParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Account != nil {
		m[search.ParameterKey{Name: "account"}] = p.Account.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Issuer != nil {
		m[search.ParameterKey{Name: "issuer"}] = p.Issuer.MatchesAll()
	}
	if p.Participant != nil {
		m[search.ParameterKey{Name: "participant"}] = p.Participant.MatchesAll()
	}
	if p.ParticipantRole != nil {
		m[search.ParameterKey{Name: "participant-role"}] = p.ParticipantRole.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Recipient != nil {
		m[search.ParameterKey{Name: "recipient"}] = p.Recipient.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}
	if p.Totalgross != nil {
		m[search.ParameterKey{Name: "totalgross"}] = p.Totalgross.MatchesAll()
	}
	if p.Totalnet != nil {
		m[search.ParameterKey{Name: "totalnet"}] = p.Totalnet.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}

	return m
}

// LibraryParams contains typed search parameters for Library resources.
type LibraryParams struct {
	// Library-specific search parameters
	ComposedOf          search.ReferenceOrString `json:"composed-of,omitempty"`
	ContentType         search.TokenOrString     `json:"content-type,omitempty"`
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Date                search.DateOrString      `json:"date,omitempty"`
	DependsOn           search.ReferenceOrString `json:"depends-on,omitempty"`
	DerivedFrom         search.ReferenceOrString `json:"derived-from,omitempty"`
	Description         search.StringOrString    `json:"description,omitempty"`
	Effective           search.DateOrString      `json:"effective,omitempty"`
	Identifier          search.TokenOrString     `json:"identifier,omitempty"`
	Jurisdiction        search.TokenOrString     `json:"jurisdiction,omitempty"`
	Name                search.StringOrString    `json:"name,omitempty"`
	Predecessor         search.ReferenceOrString `json:"predecessor,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	Successor           search.ReferenceOrString `json:"successor,omitempty"`
	Title               search.StringOrString    `json:"title,omitempty"`
	Topic               search.TokenOrString     `json:"topic,omitempty"`
	Type                search.TokenOrString     `json:"type,omitempty"`
	Url                 search.UriOrString       `json:"url,omitempty"`
	Version             search.TokenOrString     `json:"version,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
}

// Map implements the search.Parameters interface for LibraryParams.
func (p LibraryParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.ComposedOf != nil {
		m[search.ParameterKey{Name: "composed-of"}] = p.ComposedOf.MatchesAll()
	}
	if p.ContentType != nil {
		m[search.ParameterKey{Name: "content-type"}] = p.ContentType.MatchesAll()
	}
	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.DependsOn != nil {
		m[search.ParameterKey{Name: "depends-on"}] = p.DependsOn.MatchesAll()
	}
	if p.DerivedFrom != nil {
		m[search.ParameterKey{Name: "derived-from"}] = p.DerivedFrom.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Effective != nil {
		m[search.ParameterKey{Name: "effective"}] = p.Effective.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Jurisdiction != nil {
		m[search.ParameterKey{Name: "jurisdiction"}] = p.Jurisdiction.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Predecessor != nil {
		m[search.ParameterKey{Name: "predecessor"}] = p.Predecessor.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Successor != nil {
		m[search.ParameterKey{Name: "successor"}] = p.Successor.MatchesAll()
	}
	if p.Title != nil {
		m[search.ParameterKey{Name: "title"}] = p.Title.MatchesAll()
	}
	if p.Topic != nil {
		m[search.ParameterKey{Name: "topic"}] = p.Topic.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}

	return m
}

// LinkageParams contains typed search parameters for Linkage resources.
type LinkageParams struct {
	// Linkage-specific search parameters
	Author search.ReferenceOrString `json:"author,omitempty"`
	Item   search.ReferenceOrString `json:"item,omitempty"`
	Source search.ReferenceOrString `json:"source,omitempty"`
}

// Map implements the search.Parameters interface for LinkageParams.
func (p LinkageParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Author != nil {
		m[search.ParameterKey{Name: "author"}] = p.Author.MatchesAll()
	}
	if p.Item != nil {
		m[search.ParameterKey{Name: "item"}] = p.Item.MatchesAll()
	}
	if p.Source != nil {
		m[search.ParameterKey{Name: "source"}] = p.Source.MatchesAll()
	}

	return m
}

// ListParams contains typed search parameters for List resources.
type ListParams struct {
	// List-specific search parameters
	Code        search.TokenOrString     `json:"code,omitempty"`
	Date        search.DateOrString      `json:"date,omitempty"`
	Identifier  search.TokenOrString     `json:"identifier,omitempty"`
	Patient     search.ReferenceOrString `json:"patient,omitempty"`
	Encounter   search.ReferenceOrString `json:"encounter,omitempty"`
	EmptyReason search.TokenOrString     `json:"empty-reason,omitempty"`
	Item        search.ReferenceOrString `json:"item,omitempty"`
	Notes       search.StringOrString    `json:"notes,omitempty"`
	Source      search.ReferenceOrString `json:"source,omitempty"`
	Status      search.TokenOrString     `json:"status,omitempty"`
	Subject     search.ReferenceOrString `json:"subject,omitempty"`
	Title       search.StringOrString    `json:"title,omitempty"`
}

// Map implements the search.Parameters interface for ListParams.
func (p ListParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Encounter != nil {
		m[search.ParameterKey{Name: "encounter"}] = p.Encounter.MatchesAll()
	}
	if p.EmptyReason != nil {
		m[search.ParameterKey{Name: "empty-reason"}] = p.EmptyReason.MatchesAll()
	}
	if p.Item != nil {
		m[search.ParameterKey{Name: "item"}] = p.Item.MatchesAll()
	}
	if p.Notes != nil {
		m[search.ParameterKey{Name: "notes"}] = p.Notes.MatchesAll()
	}
	if p.Source != nil {
		m[search.ParameterKey{Name: "source"}] = p.Source.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}
	if p.Title != nil {
		m[search.ParameterKey{Name: "title"}] = p.Title.MatchesAll()
	}

	return m
}

// LocationParams contains typed search parameters for Location resources.
type LocationParams struct {
	// Location-specific search parameters
	Address           search.StringOrString    `json:"address,omitempty"`
	AddressCity       search.StringOrString    `json:"address-city,omitempty"`
	AddressCountry    search.StringOrString    `json:"address-country,omitempty"`
	AddressPostalcode search.StringOrString    `json:"address-postalcode,omitempty"`
	AddressState      search.StringOrString    `json:"address-state,omitempty"`
	AddressUse        search.TokenOrString     `json:"address-use,omitempty"`
	Endpoint          search.ReferenceOrString `json:"endpoint,omitempty"`
	Identifier        search.TokenOrString     `json:"identifier,omitempty"`
	Name              search.StringOrString    `json:"name,omitempty"`
	Near              search.SpecialOrString   `json:"near,omitempty"`
	OperationalStatus search.TokenOrString     `json:"operational-status,omitempty"`
	Organization      search.ReferenceOrString `json:"organization,omitempty"`
	Partof            search.ReferenceOrString `json:"partof,omitempty"`
	Status            search.TokenOrString     `json:"status,omitempty"`
	Type              search.TokenOrString     `json:"type,omitempty"`
}

// Map implements the search.Parameters interface for LocationParams.
func (p LocationParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Address != nil {
		m[search.ParameterKey{Name: "address"}] = p.Address.MatchesAll()
	}
	if p.AddressCity != nil {
		m[search.ParameterKey{Name: "address-city"}] = p.AddressCity.MatchesAll()
	}
	if p.AddressCountry != nil {
		m[search.ParameterKey{Name: "address-country"}] = p.AddressCountry.MatchesAll()
	}
	if p.AddressPostalcode != nil {
		m[search.ParameterKey{Name: "address-postalcode"}] = p.AddressPostalcode.MatchesAll()
	}
	if p.AddressState != nil {
		m[search.ParameterKey{Name: "address-state"}] = p.AddressState.MatchesAll()
	}
	if p.AddressUse != nil {
		m[search.ParameterKey{Name: "address-use"}] = p.AddressUse.MatchesAll()
	}
	if p.Endpoint != nil {
		m[search.ParameterKey{Name: "endpoint"}] = p.Endpoint.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Near != nil {
		m[search.ParameterKey{Name: "near"}] = p.Near.MatchesAll()
	}
	if p.OperationalStatus != nil {
		m[search.ParameterKey{Name: "operational-status"}] = p.OperationalStatus.MatchesAll()
	}
	if p.Organization != nil {
		m[search.ParameterKey{Name: "organization"}] = p.Organization.MatchesAll()
	}
	if p.Partof != nil {
		m[search.ParameterKey{Name: "partof"}] = p.Partof.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}

	return m
}

// ManufacturedItemDefinitionParams contains typed search parameters for ManufacturedItemDefinition resources.
type ManufacturedItemDefinitionParams struct {
	// ManufacturedItemDefinition-specific search parameters
	DoseForm   search.TokenOrString `json:"dose-form,omitempty"`
	Identifier search.TokenOrString `json:"identifier,omitempty"`
	Ingredient search.TokenOrString `json:"ingredient,omitempty"`
}

// Map implements the search.Parameters interface for ManufacturedItemDefinitionParams.
func (p ManufacturedItemDefinitionParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.DoseForm != nil {
		m[search.ParameterKey{Name: "dose-form"}] = p.DoseForm.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Ingredient != nil {
		m[search.ParameterKey{Name: "ingredient"}] = p.Ingredient.MatchesAll()
	}

	return m
}

// MeasureParams contains typed search parameters for Measure resources.
type MeasureParams struct {
	// Measure-specific search parameters
	ComposedOf          search.ReferenceOrString `json:"composed-of,omitempty"`
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Date                search.DateOrString      `json:"date,omitempty"`
	DependsOn           search.ReferenceOrString `json:"depends-on,omitempty"`
	DerivedFrom         search.ReferenceOrString `json:"derived-from,omitempty"`
	Description         search.StringOrString    `json:"description,omitempty"`
	Effective           search.DateOrString      `json:"effective,omitempty"`
	Identifier          search.TokenOrString     `json:"identifier,omitempty"`
	Jurisdiction        search.TokenOrString     `json:"jurisdiction,omitempty"`
	Name                search.StringOrString    `json:"name,omitempty"`
	Predecessor         search.ReferenceOrString `json:"predecessor,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	Successor           search.ReferenceOrString `json:"successor,omitempty"`
	Title               search.StringOrString    `json:"title,omitempty"`
	Topic               search.TokenOrString     `json:"topic,omitempty"`
	Url                 search.UriOrString       `json:"url,omitempty"`
	Version             search.TokenOrString     `json:"version,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
}

// Map implements the search.Parameters interface for MeasureParams.
func (p MeasureParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.ComposedOf != nil {
		m[search.ParameterKey{Name: "composed-of"}] = p.ComposedOf.MatchesAll()
	}
	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.DependsOn != nil {
		m[search.ParameterKey{Name: "depends-on"}] = p.DependsOn.MatchesAll()
	}
	if p.DerivedFrom != nil {
		m[search.ParameterKey{Name: "derived-from"}] = p.DerivedFrom.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Effective != nil {
		m[search.ParameterKey{Name: "effective"}] = p.Effective.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Jurisdiction != nil {
		m[search.ParameterKey{Name: "jurisdiction"}] = p.Jurisdiction.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Predecessor != nil {
		m[search.ParameterKey{Name: "predecessor"}] = p.Predecessor.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Successor != nil {
		m[search.ParameterKey{Name: "successor"}] = p.Successor.MatchesAll()
	}
	if p.Title != nil {
		m[search.ParameterKey{Name: "title"}] = p.Title.MatchesAll()
	}
	if p.Topic != nil {
		m[search.ParameterKey{Name: "topic"}] = p.Topic.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}

	return m
}

// MeasureReportParams contains typed search parameters for MeasureReport resources.
type MeasureReportParams struct {
	// MeasureReport-specific search parameters
	Date              search.DateOrString      `json:"date,omitempty"`
	EvaluatedResource search.ReferenceOrString `json:"evaluated-resource,omitempty"`
	Identifier        search.TokenOrString     `json:"identifier,omitempty"`
	Measure           search.ReferenceOrString `json:"measure,omitempty"`
	Patient           search.ReferenceOrString `json:"patient,omitempty"`
	Period            search.DateOrString      `json:"period,omitempty"`
	Reporter          search.ReferenceOrString `json:"reporter,omitempty"`
	Status            search.TokenOrString     `json:"status,omitempty"`
	Subject           search.ReferenceOrString `json:"subject,omitempty"`
}

// Map implements the search.Parameters interface for MeasureReportParams.
func (p MeasureReportParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.EvaluatedResource != nil {
		m[search.ParameterKey{Name: "evaluated-resource"}] = p.EvaluatedResource.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Measure != nil {
		m[search.ParameterKey{Name: "measure"}] = p.Measure.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Period != nil {
		m[search.ParameterKey{Name: "period"}] = p.Period.MatchesAll()
	}
	if p.Reporter != nil {
		m[search.ParameterKey{Name: "reporter"}] = p.Reporter.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}

	return m
}

// MediaParams contains typed search parameters for Media resources.
type MediaParams struct {
	// Media-specific search parameters
	BasedOn    search.ReferenceOrString `json:"based-on,omitempty"`
	Created    search.DateOrString      `json:"created,omitempty"`
	Device     search.ReferenceOrString `json:"device,omitempty"`
	Encounter  search.ReferenceOrString `json:"encounter,omitempty"`
	Identifier search.TokenOrString     `json:"identifier,omitempty"`
	Modality   search.TokenOrString     `json:"modality,omitempty"`
	Operator   search.ReferenceOrString `json:"operator,omitempty"`
	Patient    search.ReferenceOrString `json:"patient,omitempty"`
	Site       search.TokenOrString     `json:"site,omitempty"`
	Status     search.TokenOrString     `json:"status,omitempty"`
	Subject    search.ReferenceOrString `json:"subject,omitempty"`
	Type       search.TokenOrString     `json:"type,omitempty"`
	View       search.TokenOrString     `json:"view,omitempty"`
}

// Map implements the search.Parameters interface for MediaParams.
func (p MediaParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.BasedOn != nil {
		m[search.ParameterKey{Name: "based-on"}] = p.BasedOn.MatchesAll()
	}
	if p.Created != nil {
		m[search.ParameterKey{Name: "created"}] = p.Created.MatchesAll()
	}
	if p.Device != nil {
		m[search.ParameterKey{Name: "device"}] = p.Device.MatchesAll()
	}
	if p.Encounter != nil {
		m[search.ParameterKey{Name: "encounter"}] = p.Encounter.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Modality != nil {
		m[search.ParameterKey{Name: "modality"}] = p.Modality.MatchesAll()
	}
	if p.Operator != nil {
		m[search.ParameterKey{Name: "operator"}] = p.Operator.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Site != nil {
		m[search.ParameterKey{Name: "site"}] = p.Site.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}
	if p.View != nil {
		m[search.ParameterKey{Name: "view"}] = p.View.MatchesAll()
	}

	return m
}

// MedicationParams contains typed search parameters for Medication resources.
type MedicationParams struct {
	// Medication-specific search parameters
	Code           search.TokenOrString     `json:"code,omitempty"`
	ExpirationDate search.DateOrString      `json:"expiration-date,omitempty"`
	Form           search.TokenOrString     `json:"form,omitempty"`
	Identifier     search.TokenOrString     `json:"identifier,omitempty"`
	Ingredient     search.ReferenceOrString `json:"ingredient,omitempty"`
	IngredientCode search.TokenOrString     `json:"ingredient-code,omitempty"`
	LotNumber      search.TokenOrString     `json:"lot-number,omitempty"`
	Manufacturer   search.ReferenceOrString `json:"manufacturer,omitempty"`
	Status         search.TokenOrString     `json:"status,omitempty"`
}

// Map implements the search.Parameters interface for MedicationParams.
func (p MedicationParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.ExpirationDate != nil {
		m[search.ParameterKey{Name: "expiration-date"}] = p.ExpirationDate.MatchesAll()
	}
	if p.Form != nil {
		m[search.ParameterKey{Name: "form"}] = p.Form.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Ingredient != nil {
		m[search.ParameterKey{Name: "ingredient"}] = p.Ingredient.MatchesAll()
	}
	if p.IngredientCode != nil {
		m[search.ParameterKey{Name: "ingredient-code"}] = p.IngredientCode.MatchesAll()
	}
	if p.LotNumber != nil {
		m[search.ParameterKey{Name: "lot-number"}] = p.LotNumber.MatchesAll()
	}
	if p.Manufacturer != nil {
		m[search.ParameterKey{Name: "manufacturer"}] = p.Manufacturer.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}

	return m
}

// MedicationAdministrationParams contains typed search parameters for MedicationAdministration resources.
type MedicationAdministrationParams struct {
	// MedicationAdministration-specific search parameters
	Code           search.TokenOrString     `json:"code,omitempty"`
	Identifier     search.TokenOrString     `json:"identifier,omitempty"`
	Patient        search.ReferenceOrString `json:"patient,omitempty"`
	Context        search.ReferenceOrString `json:"context,omitempty"`
	Device         search.ReferenceOrString `json:"device,omitempty"`
	EffectiveTime  search.DateOrString      `json:"effective-time,omitempty"`
	Medication     search.ReferenceOrString `json:"medication,omitempty"`
	Performer      search.ReferenceOrString `json:"performer,omitempty"`
	ReasonGiven    search.TokenOrString     `json:"reason-given,omitempty"`
	ReasonNotGiven search.TokenOrString     `json:"reason-not-given,omitempty"`
	Request        search.ReferenceOrString `json:"request,omitempty"`
	Status         search.TokenOrString     `json:"status,omitempty"`
	Subject        search.ReferenceOrString `json:"subject,omitempty"`
}

// Map implements the search.Parameters interface for MedicationAdministrationParams.
func (p MedicationAdministrationParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.Device != nil {
		m[search.ParameterKey{Name: "device"}] = p.Device.MatchesAll()
	}
	if p.EffectiveTime != nil {
		m[search.ParameterKey{Name: "effective-time"}] = p.EffectiveTime.MatchesAll()
	}
	if p.Medication != nil {
		m[search.ParameterKey{Name: "medication"}] = p.Medication.MatchesAll()
	}
	if p.Performer != nil {
		m[search.ParameterKey{Name: "performer"}] = p.Performer.MatchesAll()
	}
	if p.ReasonGiven != nil {
		m[search.ParameterKey{Name: "reason-given"}] = p.ReasonGiven.MatchesAll()
	}
	if p.ReasonNotGiven != nil {
		m[search.ParameterKey{Name: "reason-not-given"}] = p.ReasonNotGiven.MatchesAll()
	}
	if p.Request != nil {
		m[search.ParameterKey{Name: "request"}] = p.Request.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}

	return m
}

// MedicationDispenseParams contains typed search parameters for MedicationDispense resources.
type MedicationDispenseParams struct {
	// MedicationDispense-specific search parameters
	Code             search.TokenOrString     `json:"code,omitempty"`
	Identifier       search.TokenOrString     `json:"identifier,omitempty"`
	Patient          search.ReferenceOrString `json:"patient,omitempty"`
	Medication       search.ReferenceOrString `json:"medication,omitempty"`
	Status           search.TokenOrString     `json:"status,omitempty"`
	Context          search.ReferenceOrString `json:"context,omitempty"`
	Destination      search.ReferenceOrString `json:"destination,omitempty"`
	Performer        search.ReferenceOrString `json:"performer,omitempty"`
	Prescription     search.ReferenceOrString `json:"prescription,omitempty"`
	Receiver         search.ReferenceOrString `json:"receiver,omitempty"`
	Responsibleparty search.ReferenceOrString `json:"responsibleparty,omitempty"`
	Subject          search.ReferenceOrString `json:"subject,omitempty"`
	Type             search.TokenOrString     `json:"type,omitempty"`
	Whenhandedover   search.DateOrString      `json:"whenhandedover,omitempty"`
	Whenprepared     search.DateOrString      `json:"whenprepared,omitempty"`
}

// Map implements the search.Parameters interface for MedicationDispenseParams.
func (p MedicationDispenseParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Medication != nil {
		m[search.ParameterKey{Name: "medication"}] = p.Medication.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.Destination != nil {
		m[search.ParameterKey{Name: "destination"}] = p.Destination.MatchesAll()
	}
	if p.Performer != nil {
		m[search.ParameterKey{Name: "performer"}] = p.Performer.MatchesAll()
	}
	if p.Prescription != nil {
		m[search.ParameterKey{Name: "prescription"}] = p.Prescription.MatchesAll()
	}
	if p.Receiver != nil {
		m[search.ParameterKey{Name: "receiver"}] = p.Receiver.MatchesAll()
	}
	if p.Responsibleparty != nil {
		m[search.ParameterKey{Name: "responsibleparty"}] = p.Responsibleparty.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}
	if p.Whenhandedover != nil {
		m[search.ParameterKey{Name: "whenhandedover"}] = p.Whenhandedover.MatchesAll()
	}
	if p.Whenprepared != nil {
		m[search.ParameterKey{Name: "whenprepared"}] = p.Whenprepared.MatchesAll()
	}

	return m
}

// MedicationKnowledgeParams contains typed search parameters for MedicationKnowledge resources.
type MedicationKnowledgeParams struct {
	// MedicationKnowledge-specific search parameters
	Classification        search.TokenOrString     `json:"classification,omitempty"`
	ClassificationType    search.TokenOrString     `json:"classification-type,omitempty"`
	Code                  search.TokenOrString     `json:"code,omitempty"`
	Doseform              search.TokenOrString     `json:"doseform,omitempty"`
	Ingredient            search.ReferenceOrString `json:"ingredient,omitempty"`
	IngredientCode        search.TokenOrString     `json:"ingredient-code,omitempty"`
	Manufacturer          search.ReferenceOrString `json:"manufacturer,omitempty"`
	MonitoringProgramName search.TokenOrString     `json:"monitoring-program-name,omitempty"`
	MonitoringProgramType search.TokenOrString     `json:"monitoring-program-type,omitempty"`
	Monograph             search.ReferenceOrString `json:"monograph,omitempty"`
	MonographType         search.TokenOrString     `json:"monograph-type,omitempty"`
	SourceCost            search.TokenOrString     `json:"source-cost,omitempty"`
	Status                search.TokenOrString     `json:"status,omitempty"`
}

// Map implements the search.Parameters interface for MedicationKnowledgeParams.
func (p MedicationKnowledgeParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Classification != nil {
		m[search.ParameterKey{Name: "classification"}] = p.Classification.MatchesAll()
	}
	if p.ClassificationType != nil {
		m[search.ParameterKey{Name: "classification-type"}] = p.ClassificationType.MatchesAll()
	}
	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.Doseform != nil {
		m[search.ParameterKey{Name: "doseform"}] = p.Doseform.MatchesAll()
	}
	if p.Ingredient != nil {
		m[search.ParameterKey{Name: "ingredient"}] = p.Ingredient.MatchesAll()
	}
	if p.IngredientCode != nil {
		m[search.ParameterKey{Name: "ingredient-code"}] = p.IngredientCode.MatchesAll()
	}
	if p.Manufacturer != nil {
		m[search.ParameterKey{Name: "manufacturer"}] = p.Manufacturer.MatchesAll()
	}
	if p.MonitoringProgramName != nil {
		m[search.ParameterKey{Name: "monitoring-program-name"}] = p.MonitoringProgramName.MatchesAll()
	}
	if p.MonitoringProgramType != nil {
		m[search.ParameterKey{Name: "monitoring-program-type"}] = p.MonitoringProgramType.MatchesAll()
	}
	if p.Monograph != nil {
		m[search.ParameterKey{Name: "monograph"}] = p.Monograph.MatchesAll()
	}
	if p.MonographType != nil {
		m[search.ParameterKey{Name: "monograph-type"}] = p.MonographType.MatchesAll()
	}
	if p.SourceCost != nil {
		m[search.ParameterKey{Name: "source-cost"}] = p.SourceCost.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}

	return m
}

// MedicationRequestParams contains typed search parameters for MedicationRequest resources.
type MedicationRequestParams struct {
	// MedicationRequest-specific search parameters
	Code                  search.TokenOrString     `json:"code,omitempty"`
	Identifier            search.TokenOrString     `json:"identifier,omitempty"`
	Patient               search.ReferenceOrString `json:"patient,omitempty"`
	Medication            search.ReferenceOrString `json:"medication,omitempty"`
	Status                search.TokenOrString     `json:"status,omitempty"`
	Authoredon            search.DateOrString      `json:"authoredon,omitempty"`
	Category              search.TokenOrString     `json:"category,omitempty"`
	Date                  search.DateOrString      `json:"date,omitempty"`
	Encounter             search.ReferenceOrString `json:"encounter,omitempty"`
	IntendedDispenser     search.ReferenceOrString `json:"intended-dispenser,omitempty"`
	IntendedPerformer     search.ReferenceOrString `json:"intended-performer,omitempty"`
	IntendedPerformertype search.TokenOrString     `json:"intended-performertype,omitempty"`
	Intent                search.TokenOrString     `json:"intent,omitempty"`
	Priority              search.TokenOrString     `json:"priority,omitempty"`
	Requester             search.ReferenceOrString `json:"requester,omitempty"`
	Subject               search.ReferenceOrString `json:"subject,omitempty"`
}

// Map implements the search.Parameters interface for MedicationRequestParams.
func (p MedicationRequestParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Medication != nil {
		m[search.ParameterKey{Name: "medication"}] = p.Medication.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Authoredon != nil {
		m[search.ParameterKey{Name: "authoredon"}] = p.Authoredon.MatchesAll()
	}
	if p.Category != nil {
		m[search.ParameterKey{Name: "category"}] = p.Category.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Encounter != nil {
		m[search.ParameterKey{Name: "encounter"}] = p.Encounter.MatchesAll()
	}
	if p.IntendedDispenser != nil {
		m[search.ParameterKey{Name: "intended-dispenser"}] = p.IntendedDispenser.MatchesAll()
	}
	if p.IntendedPerformer != nil {
		m[search.ParameterKey{Name: "intended-performer"}] = p.IntendedPerformer.MatchesAll()
	}
	if p.IntendedPerformertype != nil {
		m[search.ParameterKey{Name: "intended-performertype"}] = p.IntendedPerformertype.MatchesAll()
	}
	if p.Intent != nil {
		m[search.ParameterKey{Name: "intent"}] = p.Intent.MatchesAll()
	}
	if p.Priority != nil {
		m[search.ParameterKey{Name: "priority"}] = p.Priority.MatchesAll()
	}
	if p.Requester != nil {
		m[search.ParameterKey{Name: "requester"}] = p.Requester.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}

	return m
}

// MedicationStatementParams contains typed search parameters for MedicationStatement resources.
type MedicationStatementParams struct {
	// MedicationStatement-specific search parameters
	Code       search.TokenOrString     `json:"code,omitempty"`
	Identifier search.TokenOrString     `json:"identifier,omitempty"`
	Patient    search.ReferenceOrString `json:"patient,omitempty"`
	Medication search.ReferenceOrString `json:"medication,omitempty"`
	Status     search.TokenOrString     `json:"status,omitempty"`
	Category   search.TokenOrString     `json:"category,omitempty"`
	Context    search.ReferenceOrString `json:"context,omitempty"`
	Effective  search.DateOrString      `json:"effective,omitempty"`
	PartOf     search.ReferenceOrString `json:"part-of,omitempty"`
	Source     search.ReferenceOrString `json:"source,omitempty"`
	Subject    search.ReferenceOrString `json:"subject,omitempty"`
}

// Map implements the search.Parameters interface for MedicationStatementParams.
func (p MedicationStatementParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Medication != nil {
		m[search.ParameterKey{Name: "medication"}] = p.Medication.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Category != nil {
		m[search.ParameterKey{Name: "category"}] = p.Category.MatchesAll()
	}
	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.Effective != nil {
		m[search.ParameterKey{Name: "effective"}] = p.Effective.MatchesAll()
	}
	if p.PartOf != nil {
		m[search.ParameterKey{Name: "part-of"}] = p.PartOf.MatchesAll()
	}
	if p.Source != nil {
		m[search.ParameterKey{Name: "source"}] = p.Source.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}

	return m
}

// MedicinalProductDefinitionParams contains typed search parameters for MedicinalProductDefinition resources.
type MedicinalProductDefinitionParams struct {
	// MedicinalProductDefinition-specific search parameters
	Characteristic        search.TokenOrString     `json:"characteristic,omitempty"`
	CharacteristicType    search.TokenOrString     `json:"characteristic-type,omitempty"`
	Contact               search.ReferenceOrString `json:"contact,omitempty"`
	Domain                search.TokenOrString     `json:"domain,omitempty"`
	Identifier            search.TokenOrString     `json:"identifier,omitempty"`
	Ingredient            search.TokenOrString     `json:"ingredient,omitempty"`
	MasterFile            search.ReferenceOrString `json:"master-file,omitempty"`
	Name                  search.StringOrString    `json:"name,omitempty"`
	NameLanguage          search.TokenOrString     `json:"name-language,omitempty"`
	ProductClassification search.TokenOrString     `json:"product-classification,omitempty"`
	Status                search.TokenOrString     `json:"status,omitempty"`
	Type                  search.TokenOrString     `json:"type,omitempty"`
}

// Map implements the search.Parameters interface for MedicinalProductDefinitionParams.
func (p MedicinalProductDefinitionParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Characteristic != nil {
		m[search.ParameterKey{Name: "characteristic"}] = p.Characteristic.MatchesAll()
	}
	if p.CharacteristicType != nil {
		m[search.ParameterKey{Name: "characteristic-type"}] = p.CharacteristicType.MatchesAll()
	}
	if p.Contact != nil {
		m[search.ParameterKey{Name: "contact"}] = p.Contact.MatchesAll()
	}
	if p.Domain != nil {
		m[search.ParameterKey{Name: "domain"}] = p.Domain.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Ingredient != nil {
		m[search.ParameterKey{Name: "ingredient"}] = p.Ingredient.MatchesAll()
	}
	if p.MasterFile != nil {
		m[search.ParameterKey{Name: "master-file"}] = p.MasterFile.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.NameLanguage != nil {
		m[search.ParameterKey{Name: "name-language"}] = p.NameLanguage.MatchesAll()
	}
	if p.ProductClassification != nil {
		m[search.ParameterKey{Name: "product-classification"}] = p.ProductClassification.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}

	return m
}

// MessageDefinitionParams contains typed search parameters for MessageDefinition resources.
type MessageDefinitionParams struct {
	// MessageDefinition-specific search parameters
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Date                search.DateOrString      `json:"date,omitempty"`
	Description         search.StringOrString    `json:"description,omitempty"`
	Jurisdiction        search.TokenOrString     `json:"jurisdiction,omitempty"`
	Name                search.StringOrString    `json:"name,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	Title               search.StringOrString    `json:"title,omitempty"`
	Url                 search.UriOrString       `json:"url,omitempty"`
	Version             search.TokenOrString     `json:"version,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
	Identifier          search.TokenOrString     `json:"identifier,omitempty"`
	Category            search.TokenOrString     `json:"category,omitempty"`
	Event               search.TokenOrString     `json:"event,omitempty"`
	Focus               search.TokenOrString     `json:"focus,omitempty"`
	Parent              search.ReferenceOrString `json:"parent,omitempty"`
}

// Map implements the search.Parameters interface for MessageDefinitionParams.
func (p MessageDefinitionParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Jurisdiction != nil {
		m[search.ParameterKey{Name: "jurisdiction"}] = p.Jurisdiction.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Title != nil {
		m[search.ParameterKey{Name: "title"}] = p.Title.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Category != nil {
		m[search.ParameterKey{Name: "category"}] = p.Category.MatchesAll()
	}
	if p.Event != nil {
		m[search.ParameterKey{Name: "event"}] = p.Event.MatchesAll()
	}
	if p.Focus != nil {
		m[search.ParameterKey{Name: "focus"}] = p.Focus.MatchesAll()
	}
	if p.Parent != nil {
		m[search.ParameterKey{Name: "parent"}] = p.Parent.MatchesAll()
	}

	return m
}

// MessageHeaderParams contains typed search parameters for MessageHeader resources.
type MessageHeaderParams struct {
	// MessageHeader-specific search parameters
	Author         search.ReferenceOrString `json:"author,omitempty"`
	Code           search.TokenOrString     `json:"code,omitempty"`
	Destination    search.StringOrString    `json:"destination,omitempty"`
	DestinationUri search.UriOrString       `json:"destination-uri,omitempty"`
	Enterer        search.ReferenceOrString `json:"enterer,omitempty"`
	Event          search.TokenOrString     `json:"event,omitempty"`
	Focus          search.ReferenceOrString `json:"focus,omitempty"`
	Receiver       search.ReferenceOrString `json:"receiver,omitempty"`
	ResponseId     search.TokenOrString     `json:"response-id,omitempty"`
	Responsible    search.ReferenceOrString `json:"responsible,omitempty"`
	Sender         search.ReferenceOrString `json:"sender,omitempty"`
	Source         search.StringOrString    `json:"source,omitempty"`
	SourceUri      search.UriOrString       `json:"source-uri,omitempty"`
	Target         search.ReferenceOrString `json:"target,omitempty"`
}

// Map implements the search.Parameters interface for MessageHeaderParams.
func (p MessageHeaderParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Author != nil {
		m[search.ParameterKey{Name: "author"}] = p.Author.MatchesAll()
	}
	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.Destination != nil {
		m[search.ParameterKey{Name: "destination"}] = p.Destination.MatchesAll()
	}
	if p.DestinationUri != nil {
		m[search.ParameterKey{Name: "destination-uri"}] = p.DestinationUri.MatchesAll()
	}
	if p.Enterer != nil {
		m[search.ParameterKey{Name: "enterer"}] = p.Enterer.MatchesAll()
	}
	if p.Event != nil {
		m[search.ParameterKey{Name: "event"}] = p.Event.MatchesAll()
	}
	if p.Focus != nil {
		m[search.ParameterKey{Name: "focus"}] = p.Focus.MatchesAll()
	}
	if p.Receiver != nil {
		m[search.ParameterKey{Name: "receiver"}] = p.Receiver.MatchesAll()
	}
	if p.ResponseId != nil {
		m[search.ParameterKey{Name: "response-id"}] = p.ResponseId.MatchesAll()
	}
	if p.Responsible != nil {
		m[search.ParameterKey{Name: "responsible"}] = p.Responsible.MatchesAll()
	}
	if p.Sender != nil {
		m[search.ParameterKey{Name: "sender"}] = p.Sender.MatchesAll()
	}
	if p.Source != nil {
		m[search.ParameterKey{Name: "source"}] = p.Source.MatchesAll()
	}
	if p.SourceUri != nil {
		m[search.ParameterKey{Name: "source-uri"}] = p.SourceUri.MatchesAll()
	}
	if p.Target != nil {
		m[search.ParameterKey{Name: "target"}] = p.Target.MatchesAll()
	}

	return m
}

// MolecularSequenceParams contains typed search parameters for MolecularSequence resources.
type MolecularSequenceParams struct {
	// MolecularSequence-specific search parameters
	Chromosome                      search.TokenOrString     `json:"chromosome,omitempty"`
	Identifier                      search.TokenOrString     `json:"identifier,omitempty"`
	Patient                         search.ReferenceOrString `json:"patient,omitempty"`
	Referenceseqid                  search.TokenOrString     `json:"referenceseqid,omitempty"`
	Type                            search.TokenOrString     `json:"type,omitempty"`
	VariantEnd                      search.NumberOrString    `json:"variant-end,omitempty"`
	VariantStart                    search.NumberOrString    `json:"variant-start,omitempty"`
	WindowEnd                       search.NumberOrString    `json:"window-end,omitempty"`
	WindowStart                     search.NumberOrString    `json:"window-start,omitempty"`
	ChromosomeVariantCoordinate     search.CompositeOrString `json:"chromosome-variant-coordinate,omitempty"`
	ChromosomeWindowCoordinate      search.CompositeOrString `json:"chromosome-window-coordinate,omitempty"`
	ReferenceseqidVariantCoordinate search.CompositeOrString `json:"referenceseqid-variant-coordinate,omitempty"`
	ReferenceseqidWindowCoordinate  search.CompositeOrString `json:"referenceseqid-window-coordinate,omitempty"`
}

// Map implements the search.Parameters interface for MolecularSequenceParams.
func (p MolecularSequenceParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Chromosome != nil {
		m[search.ParameterKey{Name: "chromosome"}] = p.Chromosome.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Referenceseqid != nil {
		m[search.ParameterKey{Name: "referenceseqid"}] = p.Referenceseqid.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}
	if p.VariantEnd != nil {
		m[search.ParameterKey{Name: "variant-end"}] = p.VariantEnd.MatchesAll()
	}
	if p.VariantStart != nil {
		m[search.ParameterKey{Name: "variant-start"}] = p.VariantStart.MatchesAll()
	}
	if p.WindowEnd != nil {
		m[search.ParameterKey{Name: "window-end"}] = p.WindowEnd.MatchesAll()
	}
	if p.WindowStart != nil {
		m[search.ParameterKey{Name: "window-start"}] = p.WindowStart.MatchesAll()
	}
	if p.ChromosomeVariantCoordinate != nil {
		m[search.ParameterKey{Name: "chromosome-variant-coordinate"}] = p.ChromosomeVariantCoordinate.MatchesAll()
	}
	if p.ChromosomeWindowCoordinate != nil {
		m[search.ParameterKey{Name: "chromosome-window-coordinate"}] = p.ChromosomeWindowCoordinate.MatchesAll()
	}
	if p.ReferenceseqidVariantCoordinate != nil {
		m[search.ParameterKey{Name: "referenceseqid-variant-coordinate"}] = p.ReferenceseqidVariantCoordinate.MatchesAll()
	}
	if p.ReferenceseqidWindowCoordinate != nil {
		m[search.ParameterKey{Name: "referenceseqid-window-coordinate"}] = p.ReferenceseqidWindowCoordinate.MatchesAll()
	}

	return m
}

// NamingSystemParams contains typed search parameters for NamingSystem resources.
type NamingSystemParams struct {
	// NamingSystem-specific search parameters
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Date                search.DateOrString      `json:"date,omitempty"`
	Description         search.StringOrString    `json:"description,omitempty"`
	Jurisdiction        search.TokenOrString     `json:"jurisdiction,omitempty"`
	Name                search.StringOrString    `json:"name,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
	Contact             search.StringOrString    `json:"contact,omitempty"`
	IdType              search.TokenOrString     `json:"id-type,omitempty"`
	Kind                search.TokenOrString     `json:"kind,omitempty"`
	Period              search.DateOrString      `json:"period,omitempty"`
	Responsible         search.StringOrString    `json:"responsible,omitempty"`
	Telecom             search.TokenOrString     `json:"telecom,omitempty"`
	Type                search.TokenOrString     `json:"type,omitempty"`
	Value               search.StringOrString    `json:"value,omitempty"`
}

// Map implements the search.Parameters interface for NamingSystemParams.
func (p NamingSystemParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Jurisdiction != nil {
		m[search.ParameterKey{Name: "jurisdiction"}] = p.Jurisdiction.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}
	if p.Contact != nil {
		m[search.ParameterKey{Name: "contact"}] = p.Contact.MatchesAll()
	}
	if p.IdType != nil {
		m[search.ParameterKey{Name: "id-type"}] = p.IdType.MatchesAll()
	}
	if p.Kind != nil {
		m[search.ParameterKey{Name: "kind"}] = p.Kind.MatchesAll()
	}
	if p.Period != nil {
		m[search.ParameterKey{Name: "period"}] = p.Period.MatchesAll()
	}
	if p.Responsible != nil {
		m[search.ParameterKey{Name: "responsible"}] = p.Responsible.MatchesAll()
	}
	if p.Telecom != nil {
		m[search.ParameterKey{Name: "telecom"}] = p.Telecom.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}
	if p.Value != nil {
		m[search.ParameterKey{Name: "value"}] = p.Value.MatchesAll()
	}

	return m
}

// NutritionOrderParams contains typed search parameters for NutritionOrder resources.
type NutritionOrderParams struct {
	// NutritionOrder-specific search parameters
	Identifier            search.TokenOrString     `json:"identifier,omitempty"`
	Patient               search.ReferenceOrString `json:"patient,omitempty"`
	Encounter             search.ReferenceOrString `json:"encounter,omitempty"`
	Additive              search.TokenOrString     `json:"additive,omitempty"`
	Datetime              search.DateOrString      `json:"datetime,omitempty"`
	Formula               search.TokenOrString     `json:"formula,omitempty"`
	InstantiatesCanonical search.ReferenceOrString `json:"instantiates-canonical,omitempty"`
	InstantiatesUri       search.UriOrString       `json:"instantiates-uri,omitempty"`
	Oraldiet              search.TokenOrString     `json:"oraldiet,omitempty"`
	Provider              search.ReferenceOrString `json:"provider,omitempty"`
	Status                search.TokenOrString     `json:"status,omitempty"`
	Supplement            search.TokenOrString     `json:"supplement,omitempty"`
}

// Map implements the search.Parameters interface for NutritionOrderParams.
func (p NutritionOrderParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Encounter != nil {
		m[search.ParameterKey{Name: "encounter"}] = p.Encounter.MatchesAll()
	}
	if p.Additive != nil {
		m[search.ParameterKey{Name: "additive"}] = p.Additive.MatchesAll()
	}
	if p.Datetime != nil {
		m[search.ParameterKey{Name: "datetime"}] = p.Datetime.MatchesAll()
	}
	if p.Formula != nil {
		m[search.ParameterKey{Name: "formula"}] = p.Formula.MatchesAll()
	}
	if p.InstantiatesCanonical != nil {
		m[search.ParameterKey{Name: "instantiates-canonical"}] = p.InstantiatesCanonical.MatchesAll()
	}
	if p.InstantiatesUri != nil {
		m[search.ParameterKey{Name: "instantiates-uri"}] = p.InstantiatesUri.MatchesAll()
	}
	if p.Oraldiet != nil {
		m[search.ParameterKey{Name: "oraldiet"}] = p.Oraldiet.MatchesAll()
	}
	if p.Provider != nil {
		m[search.ParameterKey{Name: "provider"}] = p.Provider.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Supplement != nil {
		m[search.ParameterKey{Name: "supplement"}] = p.Supplement.MatchesAll()
	}

	return m
}

// NutritionProductParams contains typed search parameters for NutritionProduct resources.
type NutritionProductParams struct {
	// NutritionProduct-specific search parameters
	Identifier search.TokenOrString `json:"identifier,omitempty"`
	Status     search.TokenOrString `json:"status,omitempty"`
}

// Map implements the search.Parameters interface for NutritionProductParams.
func (p NutritionProductParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}

	return m
}

// ObservationParams contains typed search parameters for Observation resources.
type ObservationParams struct {
	// Observation-specific search parameters
	Code                       search.TokenOrString     `json:"code,omitempty"`
	Date                       search.DateOrString      `json:"date,omitempty"`
	Identifier                 search.TokenOrString     `json:"identifier,omitempty"`
	Patient                    search.ReferenceOrString `json:"patient,omitempty"`
	Encounter                  search.ReferenceOrString `json:"encounter,omitempty"`
	BasedOn                    search.ReferenceOrString `json:"based-on,omitempty"`
	Category                   search.TokenOrString     `json:"category,omitempty"`
	ComboCode                  search.TokenOrString     `json:"combo-code,omitempty"`
	ComboDataAbsentReason      search.TokenOrString     `json:"combo-data-absent-reason,omitempty"`
	ComboValueConcept          search.TokenOrString     `json:"combo-value-concept,omitempty"`
	ComboValueQuantity         search.QuantityOrString  `json:"combo-value-quantity,omitempty"`
	ComponentCode              search.TokenOrString     `json:"component-code,omitempty"`
	ComponentDataAbsentReason  search.TokenOrString     `json:"component-data-absent-reason,omitempty"`
	ComponentValueConcept      search.TokenOrString     `json:"component-value-concept,omitempty"`
	ComponentValueQuantity     search.QuantityOrString  `json:"component-value-quantity,omitempty"`
	DataAbsentReason           search.TokenOrString     `json:"data-absent-reason,omitempty"`
	DerivedFrom                search.ReferenceOrString `json:"derived-from,omitempty"`
	Device                     search.ReferenceOrString `json:"device,omitempty"`
	Focus                      search.ReferenceOrString `json:"focus,omitempty"`
	HasMember                  search.ReferenceOrString `json:"has-member,omitempty"`
	Method                     search.TokenOrString     `json:"method,omitempty"`
	PartOf                     search.ReferenceOrString `json:"part-of,omitempty"`
	Performer                  search.ReferenceOrString `json:"performer,omitempty"`
	Specimen                   search.ReferenceOrString `json:"specimen,omitempty"`
	Status                     search.TokenOrString     `json:"status,omitempty"`
	Subject                    search.ReferenceOrString `json:"subject,omitempty"`
	ValueConcept               search.TokenOrString     `json:"value-concept,omitempty"`
	ValueDate                  search.DateOrString      `json:"value-date,omitempty"`
	ValueQuantity              search.QuantityOrString  `json:"value-quantity,omitempty"`
	ValueString                search.StringOrString    `json:"value-string,omitempty"`
	CodeValueConcept           search.CompositeOrString `json:"code-value-concept,omitempty"`
	CodeValueDate              search.CompositeOrString `json:"code-value-date,omitempty"`
	CodeValueQuantity          search.CompositeOrString `json:"code-value-quantity,omitempty"`
	CodeValueString            search.CompositeOrString `json:"code-value-string,omitempty"`
	ComboCodeValueConcept      search.CompositeOrString `json:"combo-code-value-concept,omitempty"`
	ComboCodeValueQuantity     search.CompositeOrString `json:"combo-code-value-quantity,omitempty"`
	ComponentCodeValueConcept  search.CompositeOrString `json:"component-code-value-concept,omitempty"`
	ComponentCodeValueQuantity search.CompositeOrString `json:"component-code-value-quantity,omitempty"`
}

// Map implements the search.Parameters interface for ObservationParams.
func (p ObservationParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Encounter != nil {
		m[search.ParameterKey{Name: "encounter"}] = p.Encounter.MatchesAll()
	}
	if p.BasedOn != nil {
		m[search.ParameterKey{Name: "based-on"}] = p.BasedOn.MatchesAll()
	}
	if p.Category != nil {
		m[search.ParameterKey{Name: "category"}] = p.Category.MatchesAll()
	}
	if p.ComboCode != nil {
		m[search.ParameterKey{Name: "combo-code"}] = p.ComboCode.MatchesAll()
	}
	if p.ComboDataAbsentReason != nil {
		m[search.ParameterKey{Name: "combo-data-absent-reason"}] = p.ComboDataAbsentReason.MatchesAll()
	}
	if p.ComboValueConcept != nil {
		m[search.ParameterKey{Name: "combo-value-concept"}] = p.ComboValueConcept.MatchesAll()
	}
	if p.ComboValueQuantity != nil {
		m[search.ParameterKey{Name: "combo-value-quantity"}] = p.ComboValueQuantity.MatchesAll()
	}
	if p.ComponentCode != nil {
		m[search.ParameterKey{Name: "component-code"}] = p.ComponentCode.MatchesAll()
	}
	if p.ComponentDataAbsentReason != nil {
		m[search.ParameterKey{Name: "component-data-absent-reason"}] = p.ComponentDataAbsentReason.MatchesAll()
	}
	if p.ComponentValueConcept != nil {
		m[search.ParameterKey{Name: "component-value-concept"}] = p.ComponentValueConcept.MatchesAll()
	}
	if p.ComponentValueQuantity != nil {
		m[search.ParameterKey{Name: "component-value-quantity"}] = p.ComponentValueQuantity.MatchesAll()
	}
	if p.DataAbsentReason != nil {
		m[search.ParameterKey{Name: "data-absent-reason"}] = p.DataAbsentReason.MatchesAll()
	}
	if p.DerivedFrom != nil {
		m[search.ParameterKey{Name: "derived-from"}] = p.DerivedFrom.MatchesAll()
	}
	if p.Device != nil {
		m[search.ParameterKey{Name: "device"}] = p.Device.MatchesAll()
	}
	if p.Focus != nil {
		m[search.ParameterKey{Name: "focus"}] = p.Focus.MatchesAll()
	}
	if p.HasMember != nil {
		m[search.ParameterKey{Name: "has-member"}] = p.HasMember.MatchesAll()
	}
	if p.Method != nil {
		m[search.ParameterKey{Name: "method"}] = p.Method.MatchesAll()
	}
	if p.PartOf != nil {
		m[search.ParameterKey{Name: "part-of"}] = p.PartOf.MatchesAll()
	}
	if p.Performer != nil {
		m[search.ParameterKey{Name: "performer"}] = p.Performer.MatchesAll()
	}
	if p.Specimen != nil {
		m[search.ParameterKey{Name: "specimen"}] = p.Specimen.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}
	if p.ValueConcept != nil {
		m[search.ParameterKey{Name: "value-concept"}] = p.ValueConcept.MatchesAll()
	}
	if p.ValueDate != nil {
		m[search.ParameterKey{Name: "value-date"}] = p.ValueDate.MatchesAll()
	}
	if p.ValueQuantity != nil {
		m[search.ParameterKey{Name: "value-quantity"}] = p.ValueQuantity.MatchesAll()
	}
	if p.ValueString != nil {
		m[search.ParameterKey{Name: "value-string"}] = p.ValueString.MatchesAll()
	}
	if p.CodeValueConcept != nil {
		m[search.ParameterKey{Name: "code-value-concept"}] = p.CodeValueConcept.MatchesAll()
	}
	if p.CodeValueDate != nil {
		m[search.ParameterKey{Name: "code-value-date"}] = p.CodeValueDate.MatchesAll()
	}
	if p.CodeValueQuantity != nil {
		m[search.ParameterKey{Name: "code-value-quantity"}] = p.CodeValueQuantity.MatchesAll()
	}
	if p.CodeValueString != nil {
		m[search.ParameterKey{Name: "code-value-string"}] = p.CodeValueString.MatchesAll()
	}
	if p.ComboCodeValueConcept != nil {
		m[search.ParameterKey{Name: "combo-code-value-concept"}] = p.ComboCodeValueConcept.MatchesAll()
	}
	if p.ComboCodeValueQuantity != nil {
		m[search.ParameterKey{Name: "combo-code-value-quantity"}] = p.ComboCodeValueQuantity.MatchesAll()
	}
	if p.ComponentCodeValueConcept != nil {
		m[search.ParameterKey{Name: "component-code-value-concept"}] = p.ComponentCodeValueConcept.MatchesAll()
	}
	if p.ComponentCodeValueQuantity != nil {
		m[search.ParameterKey{Name: "component-code-value-quantity"}] = p.ComponentCodeValueQuantity.MatchesAll()
	}

	return m
}

// ObservationDefinitionParams contains typed search parameters for ObservationDefinition resources.
type ObservationDefinitionParams struct{}

// Map implements the search.Parameters interface for ObservationDefinitionParams.
func (p ObservationDefinitionParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	return m
}

// OperationDefinitionParams contains typed search parameters for OperationDefinition resources.
type OperationDefinitionParams struct {
	// OperationDefinition-specific search parameters
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Date                search.DateOrString      `json:"date,omitempty"`
	Description         search.StringOrString    `json:"description,omitempty"`
	Jurisdiction        search.TokenOrString     `json:"jurisdiction,omitempty"`
	Name                search.StringOrString    `json:"name,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	Title               search.StringOrString    `json:"title,omitempty"`
	Url                 search.UriOrString       `json:"url,omitempty"`
	Version             search.TokenOrString     `json:"version,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
	Base                search.ReferenceOrString `json:"base,omitempty"`
	Code                search.TokenOrString     `json:"code,omitempty"`
	InputProfile        search.ReferenceOrString `json:"input-profile,omitempty"`
	Instance            search.TokenOrString     `json:"instance,omitempty"`
	Kind                search.TokenOrString     `json:"kind,omitempty"`
	OutputProfile       search.ReferenceOrString `json:"output-profile,omitempty"`
	System              search.TokenOrString     `json:"system,omitempty"`
	Type                search.TokenOrString     `json:"type,omitempty"`
}

// Map implements the search.Parameters interface for OperationDefinitionParams.
func (p OperationDefinitionParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Jurisdiction != nil {
		m[search.ParameterKey{Name: "jurisdiction"}] = p.Jurisdiction.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Title != nil {
		m[search.ParameterKey{Name: "title"}] = p.Title.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}
	if p.Base != nil {
		m[search.ParameterKey{Name: "base"}] = p.Base.MatchesAll()
	}
	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.InputProfile != nil {
		m[search.ParameterKey{Name: "input-profile"}] = p.InputProfile.MatchesAll()
	}
	if p.Instance != nil {
		m[search.ParameterKey{Name: "instance"}] = p.Instance.MatchesAll()
	}
	if p.Kind != nil {
		m[search.ParameterKey{Name: "kind"}] = p.Kind.MatchesAll()
	}
	if p.OutputProfile != nil {
		m[search.ParameterKey{Name: "output-profile"}] = p.OutputProfile.MatchesAll()
	}
	if p.System != nil {
		m[search.ParameterKey{Name: "system"}] = p.System.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}

	return m
}

// OperationOutcomeParams contains typed search parameters for OperationOutcome resources.
type OperationOutcomeParams struct{}

// Map implements the search.Parameters interface for OperationOutcomeParams.
func (p OperationOutcomeParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	return m
}

// OrganizationParams contains typed search parameters for Organization resources.
type OrganizationParams struct {
	// Organization-specific search parameters
	Active            search.TokenOrString     `json:"active,omitempty"`
	Address           search.StringOrString    `json:"address,omitempty"`
	AddressCity       search.StringOrString    `json:"address-city,omitempty"`
	AddressCountry    search.StringOrString    `json:"address-country,omitempty"`
	AddressPostalcode search.StringOrString    `json:"address-postalcode,omitempty"`
	AddressState      search.StringOrString    `json:"address-state,omitempty"`
	AddressUse        search.TokenOrString     `json:"address-use,omitempty"`
	Endpoint          search.ReferenceOrString `json:"endpoint,omitempty"`
	Identifier        search.TokenOrString     `json:"identifier,omitempty"`
	Name              search.StringOrString    `json:"name,omitempty"`
	Partof            search.ReferenceOrString `json:"partof,omitempty"`
	Phonetic          search.StringOrString    `json:"phonetic,omitempty"`
	Type              search.TokenOrString     `json:"type,omitempty"`
}

// Map implements the search.Parameters interface for OrganizationParams.
func (p OrganizationParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Active != nil {
		m[search.ParameterKey{Name: "active"}] = p.Active.MatchesAll()
	}
	if p.Address != nil {
		m[search.ParameterKey{Name: "address"}] = p.Address.MatchesAll()
	}
	if p.AddressCity != nil {
		m[search.ParameterKey{Name: "address-city"}] = p.AddressCity.MatchesAll()
	}
	if p.AddressCountry != nil {
		m[search.ParameterKey{Name: "address-country"}] = p.AddressCountry.MatchesAll()
	}
	if p.AddressPostalcode != nil {
		m[search.ParameterKey{Name: "address-postalcode"}] = p.AddressPostalcode.MatchesAll()
	}
	if p.AddressState != nil {
		m[search.ParameterKey{Name: "address-state"}] = p.AddressState.MatchesAll()
	}
	if p.AddressUse != nil {
		m[search.ParameterKey{Name: "address-use"}] = p.AddressUse.MatchesAll()
	}
	if p.Endpoint != nil {
		m[search.ParameterKey{Name: "endpoint"}] = p.Endpoint.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Partof != nil {
		m[search.ParameterKey{Name: "partof"}] = p.Partof.MatchesAll()
	}
	if p.Phonetic != nil {
		m[search.ParameterKey{Name: "phonetic"}] = p.Phonetic.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}

	return m
}

// OrganizationAffiliationParams contains typed search parameters for OrganizationAffiliation resources.
type OrganizationAffiliationParams struct {
	// OrganizationAffiliation-specific search parameters
	Active                    search.TokenOrString     `json:"active,omitempty"`
	Date                      search.DateOrString      `json:"date,omitempty"`
	Email                     search.TokenOrString     `json:"email,omitempty"`
	Endpoint                  search.ReferenceOrString `json:"endpoint,omitempty"`
	Identifier                search.TokenOrString     `json:"identifier,omitempty"`
	Location                  search.ReferenceOrString `json:"location,omitempty"`
	Network                   search.ReferenceOrString `json:"network,omitempty"`
	ParticipatingOrganization search.ReferenceOrString `json:"participating-organization,omitempty"`
	Phone                     search.TokenOrString     `json:"phone,omitempty"`
	PrimaryOrganization       search.ReferenceOrString `json:"primary-organization,omitempty"`
	Role                      search.TokenOrString     `json:"role,omitempty"`
	Service                   search.ReferenceOrString `json:"service,omitempty"`
	Specialty                 search.TokenOrString     `json:"specialty,omitempty"`
	Telecom                   search.TokenOrString     `json:"telecom,omitempty"`
}

// Map implements the search.Parameters interface for OrganizationAffiliationParams.
func (p OrganizationAffiliationParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Active != nil {
		m[search.ParameterKey{Name: "active"}] = p.Active.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Email != nil {
		m[search.ParameterKey{Name: "email"}] = p.Email.MatchesAll()
	}
	if p.Endpoint != nil {
		m[search.ParameterKey{Name: "endpoint"}] = p.Endpoint.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Location != nil {
		m[search.ParameterKey{Name: "location"}] = p.Location.MatchesAll()
	}
	if p.Network != nil {
		m[search.ParameterKey{Name: "network"}] = p.Network.MatchesAll()
	}
	if p.ParticipatingOrganization != nil {
		m[search.ParameterKey{Name: "participating-organization"}] = p.ParticipatingOrganization.MatchesAll()
	}
	if p.Phone != nil {
		m[search.ParameterKey{Name: "phone"}] = p.Phone.MatchesAll()
	}
	if p.PrimaryOrganization != nil {
		m[search.ParameterKey{Name: "primary-organization"}] = p.PrimaryOrganization.MatchesAll()
	}
	if p.Role != nil {
		m[search.ParameterKey{Name: "role"}] = p.Role.MatchesAll()
	}
	if p.Service != nil {
		m[search.ParameterKey{Name: "service"}] = p.Service.MatchesAll()
	}
	if p.Specialty != nil {
		m[search.ParameterKey{Name: "specialty"}] = p.Specialty.MatchesAll()
	}
	if p.Telecom != nil {
		m[search.ParameterKey{Name: "telecom"}] = p.Telecom.MatchesAll()
	}

	return m
}

// PackagedProductDefinitionParams contains typed search parameters for PackagedProductDefinition resources.
type PackagedProductDefinitionParams struct {
	// PackagedProductDefinition-specific search parameters
	Biological       search.ReferenceOrString `json:"biological,omitempty"`
	ContainedItem    search.ReferenceOrString `json:"contained-item,omitempty"`
	Device           search.ReferenceOrString `json:"device,omitempty"`
	Identifier       search.TokenOrString     `json:"identifier,omitempty"`
	ManufacturedItem search.ReferenceOrString `json:"manufactured-item,omitempty"`
	Medication       search.ReferenceOrString `json:"medication,omitempty"`
	Name             search.TokenOrString     `json:"name,omitempty"`
	Nutrition        search.ReferenceOrString `json:"nutrition,omitempty"`
	Package          search.ReferenceOrString `json:"package,omitempty"`
	PackageFor       search.ReferenceOrString `json:"package-for,omitempty"`
	Status           search.TokenOrString     `json:"status,omitempty"`
}

// Map implements the search.Parameters interface for PackagedProductDefinitionParams.
func (p PackagedProductDefinitionParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Biological != nil {
		m[search.ParameterKey{Name: "biological"}] = p.Biological.MatchesAll()
	}
	if p.ContainedItem != nil {
		m[search.ParameterKey{Name: "contained-item"}] = p.ContainedItem.MatchesAll()
	}
	if p.Device != nil {
		m[search.ParameterKey{Name: "device"}] = p.Device.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.ManufacturedItem != nil {
		m[search.ParameterKey{Name: "manufactured-item"}] = p.ManufacturedItem.MatchesAll()
	}
	if p.Medication != nil {
		m[search.ParameterKey{Name: "medication"}] = p.Medication.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Nutrition != nil {
		m[search.ParameterKey{Name: "nutrition"}] = p.Nutrition.MatchesAll()
	}
	if p.Package != nil {
		m[search.ParameterKey{Name: "package"}] = p.Package.MatchesAll()
	}
	if p.PackageFor != nil {
		m[search.ParameterKey{Name: "package-for"}] = p.PackageFor.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}

	return m
}

// ParametersParams contains typed search parameters for Parameters resources.
type ParametersParams struct{}

// Map implements the search.Parameters interface for ParametersParams.
func (p ParametersParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	return m
}

// PatientParams contains typed search parameters for Patient resources.
type PatientParams struct {
	// Patient-specific search parameters
	Active              search.TokenOrString     `json:"active,omitempty"`
	Address             search.StringOrString    `json:"address,omitempty"`
	AddressCity         search.StringOrString    `json:"address-city,omitempty"`
	AddressCountry      search.StringOrString    `json:"address-country,omitempty"`
	AddressPostalcode   search.StringOrString    `json:"address-postalcode,omitempty"`
	AddressState        search.StringOrString    `json:"address-state,omitempty"`
	AddressUse          search.TokenOrString     `json:"address-use,omitempty"`
	Birthdate           search.DateOrString      `json:"birthdate,omitempty"`
	DeathDate           search.DateOrString      `json:"death-date,omitempty"`
	Deceased            search.TokenOrString     `json:"deceased,omitempty"`
	Email               search.TokenOrString     `json:"email,omitempty"`
	Family              search.StringOrString    `json:"family,omitempty"`
	Gender              search.TokenOrString     `json:"gender,omitempty"`
	GeneralPractitioner search.ReferenceOrString `json:"general-practitioner,omitempty"`
	Given               search.StringOrString    `json:"given,omitempty"`
	Identifier          search.TokenOrString     `json:"identifier,omitempty"`
	Language            search.TokenOrString     `json:"language,omitempty"`
	Link                search.ReferenceOrString `json:"link,omitempty"`
	Name                search.StringOrString    `json:"name,omitempty"`
	Organization        search.ReferenceOrString `json:"organization,omitempty"`
	Phone               search.TokenOrString     `json:"phone,omitempty"`
	Phonetic            search.StringOrString    `json:"phonetic,omitempty"`
	Telecom             search.TokenOrString     `json:"telecom,omitempty"`
}

// Map implements the search.Parameters interface for PatientParams.
func (p PatientParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Active != nil {
		m[search.ParameterKey{Name: "active"}] = p.Active.MatchesAll()
	}
	if p.Address != nil {
		m[search.ParameterKey{Name: "address"}] = p.Address.MatchesAll()
	}
	if p.AddressCity != nil {
		m[search.ParameterKey{Name: "address-city"}] = p.AddressCity.MatchesAll()
	}
	if p.AddressCountry != nil {
		m[search.ParameterKey{Name: "address-country"}] = p.AddressCountry.MatchesAll()
	}
	if p.AddressPostalcode != nil {
		m[search.ParameterKey{Name: "address-postalcode"}] = p.AddressPostalcode.MatchesAll()
	}
	if p.AddressState != nil {
		m[search.ParameterKey{Name: "address-state"}] = p.AddressState.MatchesAll()
	}
	if p.AddressUse != nil {
		m[search.ParameterKey{Name: "address-use"}] = p.AddressUse.MatchesAll()
	}
	if p.Birthdate != nil {
		m[search.ParameterKey{Name: "birthdate"}] = p.Birthdate.MatchesAll()
	}
	if p.DeathDate != nil {
		m[search.ParameterKey{Name: "death-date"}] = p.DeathDate.MatchesAll()
	}
	if p.Deceased != nil {
		m[search.ParameterKey{Name: "deceased"}] = p.Deceased.MatchesAll()
	}
	if p.Email != nil {
		m[search.ParameterKey{Name: "email"}] = p.Email.MatchesAll()
	}
	if p.Family != nil {
		m[search.ParameterKey{Name: "family"}] = p.Family.MatchesAll()
	}
	if p.Gender != nil {
		m[search.ParameterKey{Name: "gender"}] = p.Gender.MatchesAll()
	}
	if p.GeneralPractitioner != nil {
		m[search.ParameterKey{Name: "general-practitioner"}] = p.GeneralPractitioner.MatchesAll()
	}
	if p.Given != nil {
		m[search.ParameterKey{Name: "given"}] = p.Given.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Language != nil {
		m[search.ParameterKey{Name: "language"}] = p.Language.MatchesAll()
	}
	if p.Link != nil {
		m[search.ParameterKey{Name: "link"}] = p.Link.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Organization != nil {
		m[search.ParameterKey{Name: "organization"}] = p.Organization.MatchesAll()
	}
	if p.Phone != nil {
		m[search.ParameterKey{Name: "phone"}] = p.Phone.MatchesAll()
	}
	if p.Phonetic != nil {
		m[search.ParameterKey{Name: "phonetic"}] = p.Phonetic.MatchesAll()
	}
	if p.Telecom != nil {
		m[search.ParameterKey{Name: "telecom"}] = p.Telecom.MatchesAll()
	}

	return m
}

// PaymentNoticeParams contains typed search parameters for PaymentNotice resources.
type PaymentNoticeParams struct {
	// PaymentNotice-specific search parameters
	Created       search.DateOrString      `json:"created,omitempty"`
	Identifier    search.TokenOrString     `json:"identifier,omitempty"`
	PaymentStatus search.TokenOrString     `json:"payment-status,omitempty"`
	Provider      search.ReferenceOrString `json:"provider,omitempty"`
	Request       search.ReferenceOrString `json:"request,omitempty"`
	Response      search.ReferenceOrString `json:"response,omitempty"`
	Status        search.TokenOrString     `json:"status,omitempty"`
}

// Map implements the search.Parameters interface for PaymentNoticeParams.
func (p PaymentNoticeParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Created != nil {
		m[search.ParameterKey{Name: "created"}] = p.Created.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.PaymentStatus != nil {
		m[search.ParameterKey{Name: "payment-status"}] = p.PaymentStatus.MatchesAll()
	}
	if p.Provider != nil {
		m[search.ParameterKey{Name: "provider"}] = p.Provider.MatchesAll()
	}
	if p.Request != nil {
		m[search.ParameterKey{Name: "request"}] = p.Request.MatchesAll()
	}
	if p.Response != nil {
		m[search.ParameterKey{Name: "response"}] = p.Response.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}

	return m
}

// PaymentReconciliationParams contains typed search parameters for PaymentReconciliation resources.
type PaymentReconciliationParams struct {
	// PaymentReconciliation-specific search parameters
	Created       search.DateOrString      `json:"created,omitempty"`
	Disposition   search.StringOrString    `json:"disposition,omitempty"`
	Identifier    search.TokenOrString     `json:"identifier,omitempty"`
	Outcome       search.TokenOrString     `json:"outcome,omitempty"`
	PaymentIssuer search.ReferenceOrString `json:"payment-issuer,omitempty"`
	Request       search.ReferenceOrString `json:"request,omitempty"`
	Requestor     search.ReferenceOrString `json:"requestor,omitempty"`
	Status        search.TokenOrString     `json:"status,omitempty"`
}

// Map implements the search.Parameters interface for PaymentReconciliationParams.
func (p PaymentReconciliationParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Created != nil {
		m[search.ParameterKey{Name: "created"}] = p.Created.MatchesAll()
	}
	if p.Disposition != nil {
		m[search.ParameterKey{Name: "disposition"}] = p.Disposition.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Outcome != nil {
		m[search.ParameterKey{Name: "outcome"}] = p.Outcome.MatchesAll()
	}
	if p.PaymentIssuer != nil {
		m[search.ParameterKey{Name: "payment-issuer"}] = p.PaymentIssuer.MatchesAll()
	}
	if p.Request != nil {
		m[search.ParameterKey{Name: "request"}] = p.Request.MatchesAll()
	}
	if p.Requestor != nil {
		m[search.ParameterKey{Name: "requestor"}] = p.Requestor.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}

	return m
}

// PersonParams contains typed search parameters for Person resources.
type PersonParams struct {
	// Person-specific search parameters
	Address           search.StringOrString    `json:"address,omitempty"`
	AddressCity       search.StringOrString    `json:"address-city,omitempty"`
	AddressCountry    search.StringOrString    `json:"address-country,omitempty"`
	AddressPostalcode search.StringOrString    `json:"address-postalcode,omitempty"`
	AddressState      search.StringOrString    `json:"address-state,omitempty"`
	AddressUse        search.TokenOrString     `json:"address-use,omitempty"`
	Birthdate         search.DateOrString      `json:"birthdate,omitempty"`
	Email             search.TokenOrString     `json:"email,omitempty"`
	Gender            search.TokenOrString     `json:"gender,omitempty"`
	Phone             search.TokenOrString     `json:"phone,omitempty"`
	Phonetic          search.StringOrString    `json:"phonetic,omitempty"`
	Telecom           search.TokenOrString     `json:"telecom,omitempty"`
	Identifier        search.TokenOrString     `json:"identifier,omitempty"`
	Link              search.ReferenceOrString `json:"link,omitempty"`
	Name              search.StringOrString    `json:"name,omitempty"`
	Organization      search.ReferenceOrString `json:"organization,omitempty"`
	Patient           search.ReferenceOrString `json:"patient,omitempty"`
	Practitioner      search.ReferenceOrString `json:"practitioner,omitempty"`
	Relatedperson     search.ReferenceOrString `json:"relatedperson,omitempty"`
}

// Map implements the search.Parameters interface for PersonParams.
func (p PersonParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Address != nil {
		m[search.ParameterKey{Name: "address"}] = p.Address.MatchesAll()
	}
	if p.AddressCity != nil {
		m[search.ParameterKey{Name: "address-city"}] = p.AddressCity.MatchesAll()
	}
	if p.AddressCountry != nil {
		m[search.ParameterKey{Name: "address-country"}] = p.AddressCountry.MatchesAll()
	}
	if p.AddressPostalcode != nil {
		m[search.ParameterKey{Name: "address-postalcode"}] = p.AddressPostalcode.MatchesAll()
	}
	if p.AddressState != nil {
		m[search.ParameterKey{Name: "address-state"}] = p.AddressState.MatchesAll()
	}
	if p.AddressUse != nil {
		m[search.ParameterKey{Name: "address-use"}] = p.AddressUse.MatchesAll()
	}
	if p.Birthdate != nil {
		m[search.ParameterKey{Name: "birthdate"}] = p.Birthdate.MatchesAll()
	}
	if p.Email != nil {
		m[search.ParameterKey{Name: "email"}] = p.Email.MatchesAll()
	}
	if p.Gender != nil {
		m[search.ParameterKey{Name: "gender"}] = p.Gender.MatchesAll()
	}
	if p.Phone != nil {
		m[search.ParameterKey{Name: "phone"}] = p.Phone.MatchesAll()
	}
	if p.Phonetic != nil {
		m[search.ParameterKey{Name: "phonetic"}] = p.Phonetic.MatchesAll()
	}
	if p.Telecom != nil {
		m[search.ParameterKey{Name: "telecom"}] = p.Telecom.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Link != nil {
		m[search.ParameterKey{Name: "link"}] = p.Link.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Organization != nil {
		m[search.ParameterKey{Name: "organization"}] = p.Organization.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Practitioner != nil {
		m[search.ParameterKey{Name: "practitioner"}] = p.Practitioner.MatchesAll()
	}
	if p.Relatedperson != nil {
		m[search.ParameterKey{Name: "relatedperson"}] = p.Relatedperson.MatchesAll()
	}

	return m
}

// PlanDefinitionParams contains typed search parameters for PlanDefinition resources.
type PlanDefinitionParams struct {
	// PlanDefinition-specific search parameters
	ComposedOf          search.ReferenceOrString `json:"composed-of,omitempty"`
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Date                search.DateOrString      `json:"date,omitempty"`
	Definition          search.ReferenceOrString `json:"definition,omitempty"`
	DependsOn           search.ReferenceOrString `json:"depends-on,omitempty"`
	DerivedFrom         search.ReferenceOrString `json:"derived-from,omitempty"`
	Description         search.StringOrString    `json:"description,omitempty"`
	Effective           search.DateOrString      `json:"effective,omitempty"`
	Identifier          search.TokenOrString     `json:"identifier,omitempty"`
	Jurisdiction        search.TokenOrString     `json:"jurisdiction,omitempty"`
	Name                search.StringOrString    `json:"name,omitempty"`
	Predecessor         search.ReferenceOrString `json:"predecessor,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	Successor           search.ReferenceOrString `json:"successor,omitempty"`
	Title               search.StringOrString    `json:"title,omitempty"`
	Topic               search.TokenOrString     `json:"topic,omitempty"`
	Type                search.TokenOrString     `json:"type,omitempty"`
	Url                 search.UriOrString       `json:"url,omitempty"`
	Version             search.TokenOrString     `json:"version,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
}

// Map implements the search.Parameters interface for PlanDefinitionParams.
func (p PlanDefinitionParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.ComposedOf != nil {
		m[search.ParameterKey{Name: "composed-of"}] = p.ComposedOf.MatchesAll()
	}
	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Definition != nil {
		m[search.ParameterKey{Name: "definition"}] = p.Definition.MatchesAll()
	}
	if p.DependsOn != nil {
		m[search.ParameterKey{Name: "depends-on"}] = p.DependsOn.MatchesAll()
	}
	if p.DerivedFrom != nil {
		m[search.ParameterKey{Name: "derived-from"}] = p.DerivedFrom.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Effective != nil {
		m[search.ParameterKey{Name: "effective"}] = p.Effective.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Jurisdiction != nil {
		m[search.ParameterKey{Name: "jurisdiction"}] = p.Jurisdiction.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Predecessor != nil {
		m[search.ParameterKey{Name: "predecessor"}] = p.Predecessor.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Successor != nil {
		m[search.ParameterKey{Name: "successor"}] = p.Successor.MatchesAll()
	}
	if p.Title != nil {
		m[search.ParameterKey{Name: "title"}] = p.Title.MatchesAll()
	}
	if p.Topic != nil {
		m[search.ParameterKey{Name: "topic"}] = p.Topic.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}

	return m
}

// PractitionerParams contains typed search parameters for Practitioner resources.
type PractitionerParams struct {
	// Practitioner-specific search parameters
	Address           search.StringOrString `json:"address,omitempty"`
	AddressCity       search.StringOrString `json:"address-city,omitempty"`
	AddressCountry    search.StringOrString `json:"address-country,omitempty"`
	AddressPostalcode search.StringOrString `json:"address-postalcode,omitempty"`
	AddressState      search.StringOrString `json:"address-state,omitempty"`
	AddressUse        search.TokenOrString  `json:"address-use,omitempty"`
	Email             search.TokenOrString  `json:"email,omitempty"`
	Family            search.StringOrString `json:"family,omitempty"`
	Gender            search.TokenOrString  `json:"gender,omitempty"`
	Given             search.StringOrString `json:"given,omitempty"`
	Phone             search.TokenOrString  `json:"phone,omitempty"`
	Phonetic          search.StringOrString `json:"phonetic,omitempty"`
	Telecom           search.TokenOrString  `json:"telecom,omitempty"`
	Active            search.TokenOrString  `json:"active,omitempty"`
	Communication     search.TokenOrString  `json:"communication,omitempty"`
	Identifier        search.TokenOrString  `json:"identifier,omitempty"`
	Name              search.StringOrString `json:"name,omitempty"`
}

// Map implements the search.Parameters interface for PractitionerParams.
func (p PractitionerParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Address != nil {
		m[search.ParameterKey{Name: "address"}] = p.Address.MatchesAll()
	}
	if p.AddressCity != nil {
		m[search.ParameterKey{Name: "address-city"}] = p.AddressCity.MatchesAll()
	}
	if p.AddressCountry != nil {
		m[search.ParameterKey{Name: "address-country"}] = p.AddressCountry.MatchesAll()
	}
	if p.AddressPostalcode != nil {
		m[search.ParameterKey{Name: "address-postalcode"}] = p.AddressPostalcode.MatchesAll()
	}
	if p.AddressState != nil {
		m[search.ParameterKey{Name: "address-state"}] = p.AddressState.MatchesAll()
	}
	if p.AddressUse != nil {
		m[search.ParameterKey{Name: "address-use"}] = p.AddressUse.MatchesAll()
	}
	if p.Email != nil {
		m[search.ParameterKey{Name: "email"}] = p.Email.MatchesAll()
	}
	if p.Family != nil {
		m[search.ParameterKey{Name: "family"}] = p.Family.MatchesAll()
	}
	if p.Gender != nil {
		m[search.ParameterKey{Name: "gender"}] = p.Gender.MatchesAll()
	}
	if p.Given != nil {
		m[search.ParameterKey{Name: "given"}] = p.Given.MatchesAll()
	}
	if p.Phone != nil {
		m[search.ParameterKey{Name: "phone"}] = p.Phone.MatchesAll()
	}
	if p.Phonetic != nil {
		m[search.ParameterKey{Name: "phonetic"}] = p.Phonetic.MatchesAll()
	}
	if p.Telecom != nil {
		m[search.ParameterKey{Name: "telecom"}] = p.Telecom.MatchesAll()
	}
	if p.Active != nil {
		m[search.ParameterKey{Name: "active"}] = p.Active.MatchesAll()
	}
	if p.Communication != nil {
		m[search.ParameterKey{Name: "communication"}] = p.Communication.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}

	return m
}

// PractitionerRoleParams contains typed search parameters for PractitionerRole resources.
type PractitionerRoleParams struct {
	// PractitionerRole-specific search parameters
	Email        search.TokenOrString     `json:"email,omitempty"`
	Phone        search.TokenOrString     `json:"phone,omitempty"`
	Telecom      search.TokenOrString     `json:"telecom,omitempty"`
	Active       search.TokenOrString     `json:"active,omitempty"`
	Date         search.DateOrString      `json:"date,omitempty"`
	Endpoint     search.ReferenceOrString `json:"endpoint,omitempty"`
	Identifier   search.TokenOrString     `json:"identifier,omitempty"`
	Location     search.ReferenceOrString `json:"location,omitempty"`
	Organization search.ReferenceOrString `json:"organization,omitempty"`
	Practitioner search.ReferenceOrString `json:"practitioner,omitempty"`
	Role         search.TokenOrString     `json:"role,omitempty"`
	Service      search.ReferenceOrString `json:"service,omitempty"`
	Specialty    search.TokenOrString     `json:"specialty,omitempty"`
}

// Map implements the search.Parameters interface for PractitionerRoleParams.
func (p PractitionerRoleParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Email != nil {
		m[search.ParameterKey{Name: "email"}] = p.Email.MatchesAll()
	}
	if p.Phone != nil {
		m[search.ParameterKey{Name: "phone"}] = p.Phone.MatchesAll()
	}
	if p.Telecom != nil {
		m[search.ParameterKey{Name: "telecom"}] = p.Telecom.MatchesAll()
	}
	if p.Active != nil {
		m[search.ParameterKey{Name: "active"}] = p.Active.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Endpoint != nil {
		m[search.ParameterKey{Name: "endpoint"}] = p.Endpoint.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Location != nil {
		m[search.ParameterKey{Name: "location"}] = p.Location.MatchesAll()
	}
	if p.Organization != nil {
		m[search.ParameterKey{Name: "organization"}] = p.Organization.MatchesAll()
	}
	if p.Practitioner != nil {
		m[search.ParameterKey{Name: "practitioner"}] = p.Practitioner.MatchesAll()
	}
	if p.Role != nil {
		m[search.ParameterKey{Name: "role"}] = p.Role.MatchesAll()
	}
	if p.Service != nil {
		m[search.ParameterKey{Name: "service"}] = p.Service.MatchesAll()
	}
	if p.Specialty != nil {
		m[search.ParameterKey{Name: "specialty"}] = p.Specialty.MatchesAll()
	}

	return m
}

// ProcedureParams contains typed search parameters for Procedure resources.
type ProcedureParams struct {
	// Procedure-specific search parameters
	Code                  search.TokenOrString     `json:"code,omitempty"`
	Date                  search.DateOrString      `json:"date,omitempty"`
	Identifier            search.TokenOrString     `json:"identifier,omitempty"`
	Patient               search.ReferenceOrString `json:"patient,omitempty"`
	Encounter             search.ReferenceOrString `json:"encounter,omitempty"`
	BasedOn               search.ReferenceOrString `json:"based-on,omitempty"`
	Category              search.TokenOrString     `json:"category,omitempty"`
	InstantiatesCanonical search.ReferenceOrString `json:"instantiates-canonical,omitempty"`
	InstantiatesUri       search.UriOrString       `json:"instantiates-uri,omitempty"`
	Location              search.ReferenceOrString `json:"location,omitempty"`
	PartOf                search.ReferenceOrString `json:"part-of,omitempty"`
	Performer             search.ReferenceOrString `json:"performer,omitempty"`
	ReasonCode            search.TokenOrString     `json:"reason-code,omitempty"`
	ReasonReference       search.ReferenceOrString `json:"reason-reference,omitempty"`
	Status                search.TokenOrString     `json:"status,omitempty"`
	Subject               search.ReferenceOrString `json:"subject,omitempty"`
}

// Map implements the search.Parameters interface for ProcedureParams.
func (p ProcedureParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Encounter != nil {
		m[search.ParameterKey{Name: "encounter"}] = p.Encounter.MatchesAll()
	}
	if p.BasedOn != nil {
		m[search.ParameterKey{Name: "based-on"}] = p.BasedOn.MatchesAll()
	}
	if p.Category != nil {
		m[search.ParameterKey{Name: "category"}] = p.Category.MatchesAll()
	}
	if p.InstantiatesCanonical != nil {
		m[search.ParameterKey{Name: "instantiates-canonical"}] = p.InstantiatesCanonical.MatchesAll()
	}
	if p.InstantiatesUri != nil {
		m[search.ParameterKey{Name: "instantiates-uri"}] = p.InstantiatesUri.MatchesAll()
	}
	if p.Location != nil {
		m[search.ParameterKey{Name: "location"}] = p.Location.MatchesAll()
	}
	if p.PartOf != nil {
		m[search.ParameterKey{Name: "part-of"}] = p.PartOf.MatchesAll()
	}
	if p.Performer != nil {
		m[search.ParameterKey{Name: "performer"}] = p.Performer.MatchesAll()
	}
	if p.ReasonCode != nil {
		m[search.ParameterKey{Name: "reason-code"}] = p.ReasonCode.MatchesAll()
	}
	if p.ReasonReference != nil {
		m[search.ParameterKey{Name: "reason-reference"}] = p.ReasonReference.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}

	return m
}

// ProvenanceParams contains typed search parameters for Provenance resources.
type ProvenanceParams struct {
	// Provenance-specific search parameters
	Agent         search.ReferenceOrString `json:"agent,omitempty"`
	AgentRole     search.TokenOrString     `json:"agent-role,omitempty"`
	AgentType     search.TokenOrString     `json:"agent-type,omitempty"`
	Entity        search.ReferenceOrString `json:"entity,omitempty"`
	Location      search.ReferenceOrString `json:"location,omitempty"`
	Patient       search.ReferenceOrString `json:"patient,omitempty"`
	Recorded      search.DateOrString      `json:"recorded,omitempty"`
	SignatureType search.TokenOrString     `json:"signature-type,omitempty"`
	Target        search.ReferenceOrString `json:"target,omitempty"`
	When          search.DateOrString      `json:"when,omitempty"`
}

// Map implements the search.Parameters interface for ProvenanceParams.
func (p ProvenanceParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Agent != nil {
		m[search.ParameterKey{Name: "agent"}] = p.Agent.MatchesAll()
	}
	if p.AgentRole != nil {
		m[search.ParameterKey{Name: "agent-role"}] = p.AgentRole.MatchesAll()
	}
	if p.AgentType != nil {
		m[search.ParameterKey{Name: "agent-type"}] = p.AgentType.MatchesAll()
	}
	if p.Entity != nil {
		m[search.ParameterKey{Name: "entity"}] = p.Entity.MatchesAll()
	}
	if p.Location != nil {
		m[search.ParameterKey{Name: "location"}] = p.Location.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Recorded != nil {
		m[search.ParameterKey{Name: "recorded"}] = p.Recorded.MatchesAll()
	}
	if p.SignatureType != nil {
		m[search.ParameterKey{Name: "signature-type"}] = p.SignatureType.MatchesAll()
	}
	if p.Target != nil {
		m[search.ParameterKey{Name: "target"}] = p.Target.MatchesAll()
	}
	if p.When != nil {
		m[search.ParameterKey{Name: "when"}] = p.When.MatchesAll()
	}

	return m
}

// QuestionnaireParams contains typed search parameters for Questionnaire resources.
type QuestionnaireParams struct {
	// Questionnaire-specific search parameters
	Code                search.TokenOrString     `json:"code,omitempty"`
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Date                search.DateOrString      `json:"date,omitempty"`
	Definition          search.UriOrString       `json:"definition,omitempty"`
	Description         search.StringOrString    `json:"description,omitempty"`
	Effective           search.DateOrString      `json:"effective,omitempty"`
	Identifier          search.TokenOrString     `json:"identifier,omitempty"`
	Jurisdiction        search.TokenOrString     `json:"jurisdiction,omitempty"`
	Name                search.StringOrString    `json:"name,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	SubjectType         search.TokenOrString     `json:"subject-type,omitempty"`
	Title               search.StringOrString    `json:"title,omitempty"`
	Url                 search.UriOrString       `json:"url,omitempty"`
	Version             search.TokenOrString     `json:"version,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
}

// Map implements the search.Parameters interface for QuestionnaireParams.
func (p QuestionnaireParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Definition != nil {
		m[search.ParameterKey{Name: "definition"}] = p.Definition.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Effective != nil {
		m[search.ParameterKey{Name: "effective"}] = p.Effective.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Jurisdiction != nil {
		m[search.ParameterKey{Name: "jurisdiction"}] = p.Jurisdiction.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.SubjectType != nil {
		m[search.ParameterKey{Name: "subject-type"}] = p.SubjectType.MatchesAll()
	}
	if p.Title != nil {
		m[search.ParameterKey{Name: "title"}] = p.Title.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}

	return m
}

// QuestionnaireResponseParams contains typed search parameters for QuestionnaireResponse resources.
type QuestionnaireResponseParams struct {
	// QuestionnaireResponse-specific search parameters
	Author        search.ReferenceOrString `json:"author,omitempty"`
	Authored      search.DateOrString      `json:"authored,omitempty"`
	BasedOn       search.ReferenceOrString `json:"based-on,omitempty"`
	Encounter     search.ReferenceOrString `json:"encounter,omitempty"`
	Identifier    search.TokenOrString     `json:"identifier,omitempty"`
	PartOf        search.ReferenceOrString `json:"part-of,omitempty"`
	Patient       search.ReferenceOrString `json:"patient,omitempty"`
	Questionnaire search.ReferenceOrString `json:"questionnaire,omitempty"`
	Source        search.ReferenceOrString `json:"source,omitempty"`
	Status        search.TokenOrString     `json:"status,omitempty"`
	Subject       search.ReferenceOrString `json:"subject,omitempty"`
}

// Map implements the search.Parameters interface for QuestionnaireResponseParams.
func (p QuestionnaireResponseParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Author != nil {
		m[search.ParameterKey{Name: "author"}] = p.Author.MatchesAll()
	}
	if p.Authored != nil {
		m[search.ParameterKey{Name: "authored"}] = p.Authored.MatchesAll()
	}
	if p.BasedOn != nil {
		m[search.ParameterKey{Name: "based-on"}] = p.BasedOn.MatchesAll()
	}
	if p.Encounter != nil {
		m[search.ParameterKey{Name: "encounter"}] = p.Encounter.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.PartOf != nil {
		m[search.ParameterKey{Name: "part-of"}] = p.PartOf.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Questionnaire != nil {
		m[search.ParameterKey{Name: "questionnaire"}] = p.Questionnaire.MatchesAll()
	}
	if p.Source != nil {
		m[search.ParameterKey{Name: "source"}] = p.Source.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}

	return m
}

// RegulatedAuthorizationParams contains typed search parameters for RegulatedAuthorization resources.
type RegulatedAuthorizationParams struct {
	// RegulatedAuthorization-specific search parameters
	Case       search.TokenOrString     `json:"case,omitempty"`
	CaseType   search.TokenOrString     `json:"case-type,omitempty"`
	Holder     search.ReferenceOrString `json:"holder,omitempty"`
	Identifier search.TokenOrString     `json:"identifier,omitempty"`
	Region     search.TokenOrString     `json:"region,omitempty"`
	Status     search.TokenOrString     `json:"status,omitempty"`
	Subject    search.ReferenceOrString `json:"subject,omitempty"`
}

// Map implements the search.Parameters interface for RegulatedAuthorizationParams.
func (p RegulatedAuthorizationParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Case != nil {
		m[search.ParameterKey{Name: "case"}] = p.Case.MatchesAll()
	}
	if p.CaseType != nil {
		m[search.ParameterKey{Name: "case-type"}] = p.CaseType.MatchesAll()
	}
	if p.Holder != nil {
		m[search.ParameterKey{Name: "holder"}] = p.Holder.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Region != nil {
		m[search.ParameterKey{Name: "region"}] = p.Region.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}

	return m
}

// RelatedPersonParams contains typed search parameters for RelatedPerson resources.
type RelatedPersonParams struct {
	// RelatedPerson-specific search parameters
	Address           search.StringOrString    `json:"address,omitempty"`
	AddressCity       search.StringOrString    `json:"address-city,omitempty"`
	AddressCountry    search.StringOrString    `json:"address-country,omitempty"`
	AddressPostalcode search.StringOrString    `json:"address-postalcode,omitempty"`
	AddressState      search.StringOrString    `json:"address-state,omitempty"`
	AddressUse        search.TokenOrString     `json:"address-use,omitempty"`
	Birthdate         search.DateOrString      `json:"birthdate,omitempty"`
	Email             search.TokenOrString     `json:"email,omitempty"`
	Gender            search.TokenOrString     `json:"gender,omitempty"`
	Phone             search.TokenOrString     `json:"phone,omitempty"`
	Phonetic          search.StringOrString    `json:"phonetic,omitempty"`
	Telecom           search.TokenOrString     `json:"telecom,omitempty"`
	Active            search.TokenOrString     `json:"active,omitempty"`
	Identifier        search.TokenOrString     `json:"identifier,omitempty"`
	Name              search.StringOrString    `json:"name,omitempty"`
	Patient           search.ReferenceOrString `json:"patient,omitempty"`
	Relationship      search.TokenOrString     `json:"relationship,omitempty"`
}

// Map implements the search.Parameters interface for RelatedPersonParams.
func (p RelatedPersonParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Address != nil {
		m[search.ParameterKey{Name: "address"}] = p.Address.MatchesAll()
	}
	if p.AddressCity != nil {
		m[search.ParameterKey{Name: "address-city"}] = p.AddressCity.MatchesAll()
	}
	if p.AddressCountry != nil {
		m[search.ParameterKey{Name: "address-country"}] = p.AddressCountry.MatchesAll()
	}
	if p.AddressPostalcode != nil {
		m[search.ParameterKey{Name: "address-postalcode"}] = p.AddressPostalcode.MatchesAll()
	}
	if p.AddressState != nil {
		m[search.ParameterKey{Name: "address-state"}] = p.AddressState.MatchesAll()
	}
	if p.AddressUse != nil {
		m[search.ParameterKey{Name: "address-use"}] = p.AddressUse.MatchesAll()
	}
	if p.Birthdate != nil {
		m[search.ParameterKey{Name: "birthdate"}] = p.Birthdate.MatchesAll()
	}
	if p.Email != nil {
		m[search.ParameterKey{Name: "email"}] = p.Email.MatchesAll()
	}
	if p.Gender != nil {
		m[search.ParameterKey{Name: "gender"}] = p.Gender.MatchesAll()
	}
	if p.Phone != nil {
		m[search.ParameterKey{Name: "phone"}] = p.Phone.MatchesAll()
	}
	if p.Phonetic != nil {
		m[search.ParameterKey{Name: "phonetic"}] = p.Phonetic.MatchesAll()
	}
	if p.Telecom != nil {
		m[search.ParameterKey{Name: "telecom"}] = p.Telecom.MatchesAll()
	}
	if p.Active != nil {
		m[search.ParameterKey{Name: "active"}] = p.Active.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Relationship != nil {
		m[search.ParameterKey{Name: "relationship"}] = p.Relationship.MatchesAll()
	}

	return m
}

// RequestGroupParams contains typed search parameters for RequestGroup resources.
type RequestGroupParams struct {
	// RequestGroup-specific search parameters
	Author                search.ReferenceOrString `json:"author,omitempty"`
	Authored              search.DateOrString      `json:"authored,omitempty"`
	Code                  search.TokenOrString     `json:"code,omitempty"`
	Encounter             search.ReferenceOrString `json:"encounter,omitempty"`
	GroupIdentifier       search.TokenOrString     `json:"group-identifier,omitempty"`
	Identifier            search.TokenOrString     `json:"identifier,omitempty"`
	InstantiatesCanonical search.ReferenceOrString `json:"instantiates-canonical,omitempty"`
	InstantiatesUri       search.UriOrString       `json:"instantiates-uri,omitempty"`
	Intent                search.TokenOrString     `json:"intent,omitempty"`
	Participant           search.ReferenceOrString `json:"participant,omitempty"`
	Patient               search.ReferenceOrString `json:"patient,omitempty"`
	Priority              search.TokenOrString     `json:"priority,omitempty"`
	Status                search.TokenOrString     `json:"status,omitempty"`
	Subject               search.ReferenceOrString `json:"subject,omitempty"`
}

// Map implements the search.Parameters interface for RequestGroupParams.
func (p RequestGroupParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Author != nil {
		m[search.ParameterKey{Name: "author"}] = p.Author.MatchesAll()
	}
	if p.Authored != nil {
		m[search.ParameterKey{Name: "authored"}] = p.Authored.MatchesAll()
	}
	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.Encounter != nil {
		m[search.ParameterKey{Name: "encounter"}] = p.Encounter.MatchesAll()
	}
	if p.GroupIdentifier != nil {
		m[search.ParameterKey{Name: "group-identifier"}] = p.GroupIdentifier.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.InstantiatesCanonical != nil {
		m[search.ParameterKey{Name: "instantiates-canonical"}] = p.InstantiatesCanonical.MatchesAll()
	}
	if p.InstantiatesUri != nil {
		m[search.ParameterKey{Name: "instantiates-uri"}] = p.InstantiatesUri.MatchesAll()
	}
	if p.Intent != nil {
		m[search.ParameterKey{Name: "intent"}] = p.Intent.MatchesAll()
	}
	if p.Participant != nil {
		m[search.ParameterKey{Name: "participant"}] = p.Participant.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Priority != nil {
		m[search.ParameterKey{Name: "priority"}] = p.Priority.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}

	return m
}

// ResearchDefinitionParams contains typed search parameters for ResearchDefinition resources.
type ResearchDefinitionParams struct {
	// ResearchDefinition-specific search parameters
	ComposedOf          search.ReferenceOrString `json:"composed-of,omitempty"`
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Date                search.DateOrString      `json:"date,omitempty"`
	DependsOn           search.ReferenceOrString `json:"depends-on,omitempty"`
	DerivedFrom         search.ReferenceOrString `json:"derived-from,omitempty"`
	Description         search.StringOrString    `json:"description,omitempty"`
	Effective           search.DateOrString      `json:"effective,omitempty"`
	Identifier          search.TokenOrString     `json:"identifier,omitempty"`
	Jurisdiction        search.TokenOrString     `json:"jurisdiction,omitempty"`
	Name                search.StringOrString    `json:"name,omitempty"`
	Predecessor         search.ReferenceOrString `json:"predecessor,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	Successor           search.ReferenceOrString `json:"successor,omitempty"`
	Title               search.StringOrString    `json:"title,omitempty"`
	Topic               search.TokenOrString     `json:"topic,omitempty"`
	Url                 search.UriOrString       `json:"url,omitempty"`
	Version             search.TokenOrString     `json:"version,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
}

// Map implements the search.Parameters interface for ResearchDefinitionParams.
func (p ResearchDefinitionParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.ComposedOf != nil {
		m[search.ParameterKey{Name: "composed-of"}] = p.ComposedOf.MatchesAll()
	}
	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.DependsOn != nil {
		m[search.ParameterKey{Name: "depends-on"}] = p.DependsOn.MatchesAll()
	}
	if p.DerivedFrom != nil {
		m[search.ParameterKey{Name: "derived-from"}] = p.DerivedFrom.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Effective != nil {
		m[search.ParameterKey{Name: "effective"}] = p.Effective.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Jurisdiction != nil {
		m[search.ParameterKey{Name: "jurisdiction"}] = p.Jurisdiction.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Predecessor != nil {
		m[search.ParameterKey{Name: "predecessor"}] = p.Predecessor.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Successor != nil {
		m[search.ParameterKey{Name: "successor"}] = p.Successor.MatchesAll()
	}
	if p.Title != nil {
		m[search.ParameterKey{Name: "title"}] = p.Title.MatchesAll()
	}
	if p.Topic != nil {
		m[search.ParameterKey{Name: "topic"}] = p.Topic.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}

	return m
}

// ResearchElementDefinitionParams contains typed search parameters for ResearchElementDefinition resources.
type ResearchElementDefinitionParams struct {
	// ResearchElementDefinition-specific search parameters
	ComposedOf          search.ReferenceOrString `json:"composed-of,omitempty"`
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Date                search.DateOrString      `json:"date,omitempty"`
	DependsOn           search.ReferenceOrString `json:"depends-on,omitempty"`
	DerivedFrom         search.ReferenceOrString `json:"derived-from,omitempty"`
	Description         search.StringOrString    `json:"description,omitempty"`
	Effective           search.DateOrString      `json:"effective,omitempty"`
	Identifier          search.TokenOrString     `json:"identifier,omitempty"`
	Jurisdiction        search.TokenOrString     `json:"jurisdiction,omitempty"`
	Name                search.StringOrString    `json:"name,omitempty"`
	Predecessor         search.ReferenceOrString `json:"predecessor,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	Successor           search.ReferenceOrString `json:"successor,omitempty"`
	Title               search.StringOrString    `json:"title,omitempty"`
	Topic               search.TokenOrString     `json:"topic,omitempty"`
	Url                 search.UriOrString       `json:"url,omitempty"`
	Version             search.TokenOrString     `json:"version,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
}

// Map implements the search.Parameters interface for ResearchElementDefinitionParams.
func (p ResearchElementDefinitionParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.ComposedOf != nil {
		m[search.ParameterKey{Name: "composed-of"}] = p.ComposedOf.MatchesAll()
	}
	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.DependsOn != nil {
		m[search.ParameterKey{Name: "depends-on"}] = p.DependsOn.MatchesAll()
	}
	if p.DerivedFrom != nil {
		m[search.ParameterKey{Name: "derived-from"}] = p.DerivedFrom.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Effective != nil {
		m[search.ParameterKey{Name: "effective"}] = p.Effective.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Jurisdiction != nil {
		m[search.ParameterKey{Name: "jurisdiction"}] = p.Jurisdiction.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Predecessor != nil {
		m[search.ParameterKey{Name: "predecessor"}] = p.Predecessor.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Successor != nil {
		m[search.ParameterKey{Name: "successor"}] = p.Successor.MatchesAll()
	}
	if p.Title != nil {
		m[search.ParameterKey{Name: "title"}] = p.Title.MatchesAll()
	}
	if p.Topic != nil {
		m[search.ParameterKey{Name: "topic"}] = p.Topic.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}

	return m
}

// ResearchStudyParams contains typed search parameters for ResearchStudy resources.
type ResearchStudyParams struct {
	// ResearchStudy-specific search parameters
	Category              search.TokenOrString     `json:"category,omitempty"`
	Date                  search.DateOrString      `json:"date,omitempty"`
	Focus                 search.TokenOrString     `json:"focus,omitempty"`
	Identifier            search.TokenOrString     `json:"identifier,omitempty"`
	Keyword               search.TokenOrString     `json:"keyword,omitempty"`
	Location              search.TokenOrString     `json:"location,omitempty"`
	Partof                search.ReferenceOrString `json:"partof,omitempty"`
	Principalinvestigator search.ReferenceOrString `json:"principalinvestigator,omitempty"`
	Protocol              search.ReferenceOrString `json:"protocol,omitempty"`
	Site                  search.ReferenceOrString `json:"site,omitempty"`
	Sponsor               search.ReferenceOrString `json:"sponsor,omitempty"`
	Status                search.TokenOrString     `json:"status,omitempty"`
	Title                 search.StringOrString    `json:"title,omitempty"`
}

// Map implements the search.Parameters interface for ResearchStudyParams.
func (p ResearchStudyParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Category != nil {
		m[search.ParameterKey{Name: "category"}] = p.Category.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Focus != nil {
		m[search.ParameterKey{Name: "focus"}] = p.Focus.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Keyword != nil {
		m[search.ParameterKey{Name: "keyword"}] = p.Keyword.MatchesAll()
	}
	if p.Location != nil {
		m[search.ParameterKey{Name: "location"}] = p.Location.MatchesAll()
	}
	if p.Partof != nil {
		m[search.ParameterKey{Name: "partof"}] = p.Partof.MatchesAll()
	}
	if p.Principalinvestigator != nil {
		m[search.ParameterKey{Name: "principalinvestigator"}] = p.Principalinvestigator.MatchesAll()
	}
	if p.Protocol != nil {
		m[search.ParameterKey{Name: "protocol"}] = p.Protocol.MatchesAll()
	}
	if p.Site != nil {
		m[search.ParameterKey{Name: "site"}] = p.Site.MatchesAll()
	}
	if p.Sponsor != nil {
		m[search.ParameterKey{Name: "sponsor"}] = p.Sponsor.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Title != nil {
		m[search.ParameterKey{Name: "title"}] = p.Title.MatchesAll()
	}

	return m
}

// ResearchSubjectParams contains typed search parameters for ResearchSubject resources.
type ResearchSubjectParams struct {
	// ResearchSubject-specific search parameters
	Date       search.DateOrString      `json:"date,omitempty"`
	Identifier search.TokenOrString     `json:"identifier,omitempty"`
	Individual search.ReferenceOrString `json:"individual,omitempty"`
	Patient    search.ReferenceOrString `json:"patient,omitempty"`
	Status     search.TokenOrString     `json:"status,omitempty"`
	Study      search.ReferenceOrString `json:"study,omitempty"`
}

// Map implements the search.Parameters interface for ResearchSubjectParams.
func (p ResearchSubjectParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Individual != nil {
		m[search.ParameterKey{Name: "individual"}] = p.Individual.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Study != nil {
		m[search.ParameterKey{Name: "study"}] = p.Study.MatchesAll()
	}

	return m
}

// RiskAssessmentParams contains typed search parameters for RiskAssessment resources.
type RiskAssessmentParams struct {
	// RiskAssessment-specific search parameters
	Date        search.DateOrString      `json:"date,omitempty"`
	Identifier  search.TokenOrString     `json:"identifier,omitempty"`
	Patient     search.ReferenceOrString `json:"patient,omitempty"`
	Encounter   search.ReferenceOrString `json:"encounter,omitempty"`
	Condition   search.ReferenceOrString `json:"condition,omitempty"`
	Method      search.TokenOrString     `json:"method,omitempty"`
	Performer   search.ReferenceOrString `json:"performer,omitempty"`
	Probability search.NumberOrString    `json:"probability,omitempty"`
	Risk        search.TokenOrString     `json:"risk,omitempty"`
	Subject     search.ReferenceOrString `json:"subject,omitempty"`
}

// Map implements the search.Parameters interface for RiskAssessmentParams.
func (p RiskAssessmentParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Encounter != nil {
		m[search.ParameterKey{Name: "encounter"}] = p.Encounter.MatchesAll()
	}
	if p.Condition != nil {
		m[search.ParameterKey{Name: "condition"}] = p.Condition.MatchesAll()
	}
	if p.Method != nil {
		m[search.ParameterKey{Name: "method"}] = p.Method.MatchesAll()
	}
	if p.Performer != nil {
		m[search.ParameterKey{Name: "performer"}] = p.Performer.MatchesAll()
	}
	if p.Probability != nil {
		m[search.ParameterKey{Name: "probability"}] = p.Probability.MatchesAll()
	}
	if p.Risk != nil {
		m[search.ParameterKey{Name: "risk"}] = p.Risk.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}

	return m
}

// ScheduleParams contains typed search parameters for Schedule resources.
type ScheduleParams struct {
	// Schedule-specific search parameters
	Active          search.TokenOrString     `json:"active,omitempty"`
	Actor           search.ReferenceOrString `json:"actor,omitempty"`
	Date            search.DateOrString      `json:"date,omitempty"`
	Identifier      search.TokenOrString     `json:"identifier,omitempty"`
	ServiceCategory search.TokenOrString     `json:"service-category,omitempty"`
	ServiceType     search.TokenOrString     `json:"service-type,omitempty"`
	Specialty       search.TokenOrString     `json:"specialty,omitempty"`
}

// Map implements the search.Parameters interface for ScheduleParams.
func (p ScheduleParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Active != nil {
		m[search.ParameterKey{Name: "active"}] = p.Active.MatchesAll()
	}
	if p.Actor != nil {
		m[search.ParameterKey{Name: "actor"}] = p.Actor.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.ServiceCategory != nil {
		m[search.ParameterKey{Name: "service-category"}] = p.ServiceCategory.MatchesAll()
	}
	if p.ServiceType != nil {
		m[search.ParameterKey{Name: "service-type"}] = p.ServiceType.MatchesAll()
	}
	if p.Specialty != nil {
		m[search.ParameterKey{Name: "specialty"}] = p.Specialty.MatchesAll()
	}

	return m
}

// SearchParameterParams contains typed search parameters for SearchParameter resources.
type SearchParameterParams struct {
	// SearchParameter-specific search parameters
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Date                search.DateOrString      `json:"date,omitempty"`
	Description         search.StringOrString    `json:"description,omitempty"`
	Jurisdiction        search.TokenOrString     `json:"jurisdiction,omitempty"`
	Name                search.StringOrString    `json:"name,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	Url                 search.UriOrString       `json:"url,omitempty"`
	Version             search.TokenOrString     `json:"version,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
	Base                search.TokenOrString     `json:"base,omitempty"`
	Code                search.TokenOrString     `json:"code,omitempty"`
	Component           search.ReferenceOrString `json:"component,omitempty"`
	DerivedFrom         search.ReferenceOrString `json:"derived-from,omitempty"`
	Target              search.TokenOrString     `json:"target,omitempty"`
	Type                search.TokenOrString     `json:"type,omitempty"`
}

// Map implements the search.Parameters interface for SearchParameterParams.
func (p SearchParameterParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Jurisdiction != nil {
		m[search.ParameterKey{Name: "jurisdiction"}] = p.Jurisdiction.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}
	if p.Base != nil {
		m[search.ParameterKey{Name: "base"}] = p.Base.MatchesAll()
	}
	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.Component != nil {
		m[search.ParameterKey{Name: "component"}] = p.Component.MatchesAll()
	}
	if p.DerivedFrom != nil {
		m[search.ParameterKey{Name: "derived-from"}] = p.DerivedFrom.MatchesAll()
	}
	if p.Target != nil {
		m[search.ParameterKey{Name: "target"}] = p.Target.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}

	return m
}

// ServiceRequestParams contains typed search parameters for ServiceRequest resources.
type ServiceRequestParams struct {
	// ServiceRequest-specific search parameters
	Code                  search.TokenOrString     `json:"code,omitempty"`
	Identifier            search.TokenOrString     `json:"identifier,omitempty"`
	Patient               search.ReferenceOrString `json:"patient,omitempty"`
	Encounter             search.ReferenceOrString `json:"encounter,omitempty"`
	Authored              search.DateOrString      `json:"authored,omitempty"`
	BasedOn               search.ReferenceOrString `json:"based-on,omitempty"`
	BodySite              search.TokenOrString     `json:"body-site,omitempty"`
	Category              search.TokenOrString     `json:"category,omitempty"`
	InstantiatesCanonical search.ReferenceOrString `json:"instantiates-canonical,omitempty"`
	InstantiatesUri       search.UriOrString       `json:"instantiates-uri,omitempty"`
	Intent                search.TokenOrString     `json:"intent,omitempty"`
	Occurrence            search.DateOrString      `json:"occurrence,omitempty"`
	Performer             search.ReferenceOrString `json:"performer,omitempty"`
	PerformerType         search.TokenOrString     `json:"performer-type,omitempty"`
	Priority              search.TokenOrString     `json:"priority,omitempty"`
	Replaces              search.ReferenceOrString `json:"replaces,omitempty"`
	Requester             search.ReferenceOrString `json:"requester,omitempty"`
	Requisition           search.TokenOrString     `json:"requisition,omitempty"`
	Specimen              search.ReferenceOrString `json:"specimen,omitempty"`
	Status                search.TokenOrString     `json:"status,omitempty"`
	Subject               search.ReferenceOrString `json:"subject,omitempty"`
}

// Map implements the search.Parameters interface for ServiceRequestParams.
func (p ServiceRequestParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Encounter != nil {
		m[search.ParameterKey{Name: "encounter"}] = p.Encounter.MatchesAll()
	}
	if p.Authored != nil {
		m[search.ParameterKey{Name: "authored"}] = p.Authored.MatchesAll()
	}
	if p.BasedOn != nil {
		m[search.ParameterKey{Name: "based-on"}] = p.BasedOn.MatchesAll()
	}
	if p.BodySite != nil {
		m[search.ParameterKey{Name: "body-site"}] = p.BodySite.MatchesAll()
	}
	if p.Category != nil {
		m[search.ParameterKey{Name: "category"}] = p.Category.MatchesAll()
	}
	if p.InstantiatesCanonical != nil {
		m[search.ParameterKey{Name: "instantiates-canonical"}] = p.InstantiatesCanonical.MatchesAll()
	}
	if p.InstantiatesUri != nil {
		m[search.ParameterKey{Name: "instantiates-uri"}] = p.InstantiatesUri.MatchesAll()
	}
	if p.Intent != nil {
		m[search.ParameterKey{Name: "intent"}] = p.Intent.MatchesAll()
	}
	if p.Occurrence != nil {
		m[search.ParameterKey{Name: "occurrence"}] = p.Occurrence.MatchesAll()
	}
	if p.Performer != nil {
		m[search.ParameterKey{Name: "performer"}] = p.Performer.MatchesAll()
	}
	if p.PerformerType != nil {
		m[search.ParameterKey{Name: "performer-type"}] = p.PerformerType.MatchesAll()
	}
	if p.Priority != nil {
		m[search.ParameterKey{Name: "priority"}] = p.Priority.MatchesAll()
	}
	if p.Replaces != nil {
		m[search.ParameterKey{Name: "replaces"}] = p.Replaces.MatchesAll()
	}
	if p.Requester != nil {
		m[search.ParameterKey{Name: "requester"}] = p.Requester.MatchesAll()
	}
	if p.Requisition != nil {
		m[search.ParameterKey{Name: "requisition"}] = p.Requisition.MatchesAll()
	}
	if p.Specimen != nil {
		m[search.ParameterKey{Name: "specimen"}] = p.Specimen.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}

	return m
}

// SlotParams contains typed search parameters for Slot resources.
type SlotParams struct {
	// Slot-specific search parameters
	AppointmentType search.TokenOrString     `json:"appointment-type,omitempty"`
	Identifier      search.TokenOrString     `json:"identifier,omitempty"`
	Schedule        search.ReferenceOrString `json:"schedule,omitempty"`
	ServiceCategory search.TokenOrString     `json:"service-category,omitempty"`
	ServiceType     search.TokenOrString     `json:"service-type,omitempty"`
	Specialty       search.TokenOrString     `json:"specialty,omitempty"`
	Start           search.DateOrString      `json:"start,omitempty"`
	Status          search.TokenOrString     `json:"status,omitempty"`
}

// Map implements the search.Parameters interface for SlotParams.
func (p SlotParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.AppointmentType != nil {
		m[search.ParameterKey{Name: "appointment-type"}] = p.AppointmentType.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Schedule != nil {
		m[search.ParameterKey{Name: "schedule"}] = p.Schedule.MatchesAll()
	}
	if p.ServiceCategory != nil {
		m[search.ParameterKey{Name: "service-category"}] = p.ServiceCategory.MatchesAll()
	}
	if p.ServiceType != nil {
		m[search.ParameterKey{Name: "service-type"}] = p.ServiceType.MatchesAll()
	}
	if p.Specialty != nil {
		m[search.ParameterKey{Name: "specialty"}] = p.Specialty.MatchesAll()
	}
	if p.Start != nil {
		m[search.ParameterKey{Name: "start"}] = p.Start.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}

	return m
}

// SpecimenParams contains typed search parameters for Specimen resources.
type SpecimenParams struct {
	// Specimen-specific search parameters
	Accession   search.TokenOrString     `json:"accession,omitempty"`
	Bodysite    search.TokenOrString     `json:"bodysite,omitempty"`
	Collected   search.DateOrString      `json:"collected,omitempty"`
	Collector   search.ReferenceOrString `json:"collector,omitempty"`
	Container   search.TokenOrString     `json:"container,omitempty"`
	ContainerId search.TokenOrString     `json:"container-id,omitempty"`
	Identifier  search.TokenOrString     `json:"identifier,omitempty"`
	Parent      search.ReferenceOrString `json:"parent,omitempty"`
	Patient     search.ReferenceOrString `json:"patient,omitempty"`
	Status      search.TokenOrString     `json:"status,omitempty"`
	Subject     search.ReferenceOrString `json:"subject,omitempty"`
	Type        search.TokenOrString     `json:"type,omitempty"`
}

// Map implements the search.Parameters interface for SpecimenParams.
func (p SpecimenParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Accession != nil {
		m[search.ParameterKey{Name: "accession"}] = p.Accession.MatchesAll()
	}
	if p.Bodysite != nil {
		m[search.ParameterKey{Name: "bodysite"}] = p.Bodysite.MatchesAll()
	}
	if p.Collected != nil {
		m[search.ParameterKey{Name: "collected"}] = p.Collected.MatchesAll()
	}
	if p.Collector != nil {
		m[search.ParameterKey{Name: "collector"}] = p.Collector.MatchesAll()
	}
	if p.Container != nil {
		m[search.ParameterKey{Name: "container"}] = p.Container.MatchesAll()
	}
	if p.ContainerId != nil {
		m[search.ParameterKey{Name: "container-id"}] = p.ContainerId.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Parent != nil {
		m[search.ParameterKey{Name: "parent"}] = p.Parent.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}

	return m
}

// SpecimenDefinitionParams contains typed search parameters for SpecimenDefinition resources.
type SpecimenDefinitionParams struct {
	// SpecimenDefinition-specific search parameters
	Container  search.TokenOrString `json:"container,omitempty"`
	Identifier search.TokenOrString `json:"identifier,omitempty"`
	Type       search.TokenOrString `json:"type,omitempty"`
}

// Map implements the search.Parameters interface for SpecimenDefinitionParams.
func (p SpecimenDefinitionParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Container != nil {
		m[search.ParameterKey{Name: "container"}] = p.Container.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}

	return m
}

// StructureDefinitionParams contains typed search parameters for StructureDefinition resources.
type StructureDefinitionParams struct {
	// StructureDefinition-specific search parameters
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Date                search.DateOrString      `json:"date,omitempty"`
	Description         search.StringOrString    `json:"description,omitempty"`
	Jurisdiction        search.TokenOrString     `json:"jurisdiction,omitempty"`
	Name                search.StringOrString    `json:"name,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	Title               search.StringOrString    `json:"title,omitempty"`
	Url                 search.UriOrString       `json:"url,omitempty"`
	Version             search.TokenOrString     `json:"version,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
	Identifier          search.TokenOrString     `json:"identifier,omitempty"`
	Abstract            search.TokenOrString     `json:"abstract,omitempty"`
	Base                search.ReferenceOrString `json:"base,omitempty"`
	BasePath            search.TokenOrString     `json:"base-path,omitempty"`
	Derivation          search.TokenOrString     `json:"derivation,omitempty"`
	Experimental        search.TokenOrString     `json:"experimental,omitempty"`
	ExtContext          search.TokenOrString     `json:"ext-context,omitempty"`
	Keyword             search.TokenOrString     `json:"keyword,omitempty"`
	Kind                search.TokenOrString     `json:"kind,omitempty"`
	Path                search.TokenOrString     `json:"path,omitempty"`
	Type                search.UriOrString       `json:"type,omitempty"`
	Valueset            search.ReferenceOrString `json:"valueset,omitempty"`
}

// Map implements the search.Parameters interface for StructureDefinitionParams.
func (p StructureDefinitionParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Jurisdiction != nil {
		m[search.ParameterKey{Name: "jurisdiction"}] = p.Jurisdiction.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Title != nil {
		m[search.ParameterKey{Name: "title"}] = p.Title.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Abstract != nil {
		m[search.ParameterKey{Name: "abstract"}] = p.Abstract.MatchesAll()
	}
	if p.Base != nil {
		m[search.ParameterKey{Name: "base"}] = p.Base.MatchesAll()
	}
	if p.BasePath != nil {
		m[search.ParameterKey{Name: "base-path"}] = p.BasePath.MatchesAll()
	}
	if p.Derivation != nil {
		m[search.ParameterKey{Name: "derivation"}] = p.Derivation.MatchesAll()
	}
	if p.Experimental != nil {
		m[search.ParameterKey{Name: "experimental"}] = p.Experimental.MatchesAll()
	}
	if p.ExtContext != nil {
		m[search.ParameterKey{Name: "ext-context"}] = p.ExtContext.MatchesAll()
	}
	if p.Keyword != nil {
		m[search.ParameterKey{Name: "keyword"}] = p.Keyword.MatchesAll()
	}
	if p.Kind != nil {
		m[search.ParameterKey{Name: "kind"}] = p.Kind.MatchesAll()
	}
	if p.Path != nil {
		m[search.ParameterKey{Name: "path"}] = p.Path.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}
	if p.Valueset != nil {
		m[search.ParameterKey{Name: "valueset"}] = p.Valueset.MatchesAll()
	}

	return m
}

// StructureMapParams contains typed search parameters for StructureMap resources.
type StructureMapParams struct {
	// StructureMap-specific search parameters
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Date                search.DateOrString      `json:"date,omitempty"`
	Description         search.StringOrString    `json:"description,omitempty"`
	Jurisdiction        search.TokenOrString     `json:"jurisdiction,omitempty"`
	Name                search.StringOrString    `json:"name,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	Title               search.StringOrString    `json:"title,omitempty"`
	Url                 search.UriOrString       `json:"url,omitempty"`
	Version             search.TokenOrString     `json:"version,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
	Identifier          search.TokenOrString     `json:"identifier,omitempty"`
}

// Map implements the search.Parameters interface for StructureMapParams.
func (p StructureMapParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Jurisdiction != nil {
		m[search.ParameterKey{Name: "jurisdiction"}] = p.Jurisdiction.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Title != nil {
		m[search.ParameterKey{Name: "title"}] = p.Title.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}

	return m
}

// SubscriptionParams contains typed search parameters for Subscription resources.
type SubscriptionParams struct {
	// Subscription-specific search parameters
	Contact  search.TokenOrString  `json:"contact,omitempty"`
	Criteria search.StringOrString `json:"criteria,omitempty"`
	Payload  search.TokenOrString  `json:"payload,omitempty"`
	Status   search.TokenOrString  `json:"status,omitempty"`
	Type     search.TokenOrString  `json:"type,omitempty"`
	Url      search.UriOrString    `json:"url,omitempty"`
}

// Map implements the search.Parameters interface for SubscriptionParams.
func (p SubscriptionParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Contact != nil {
		m[search.ParameterKey{Name: "contact"}] = p.Contact.MatchesAll()
	}
	if p.Criteria != nil {
		m[search.ParameterKey{Name: "criteria"}] = p.Criteria.MatchesAll()
	}
	if p.Payload != nil {
		m[search.ParameterKey{Name: "payload"}] = p.Payload.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Type != nil {
		m[search.ParameterKey{Name: "type"}] = p.Type.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}

	return m
}

// SubscriptionStatusParams contains typed search parameters for SubscriptionStatus resources.
type SubscriptionStatusParams struct{}

// Map implements the search.Parameters interface for SubscriptionStatusParams.
func (p SubscriptionStatusParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	return m
}

// SubscriptionTopicParams contains typed search parameters for SubscriptionTopic resources.
type SubscriptionTopicParams struct {
	// SubscriptionTopic-specific search parameters
	Date               search.DateOrString   `json:"date,omitempty"`
	DerivedOrSelf      search.UriOrString    `json:"derived-or-self,omitempty"`
	Identifier         search.TokenOrString  `json:"identifier,omitempty"`
	Resource           search.UriOrString    `json:"resource,omitempty"`
	Status             search.TokenOrString  `json:"status,omitempty"`
	Title              search.StringOrString `json:"title,omitempty"`
	TriggerDescription search.StringOrString `json:"trigger-description,omitempty"`
	Url                search.UriOrString    `json:"url,omitempty"`
	Version            search.TokenOrString  `json:"version,omitempty"`
}

// Map implements the search.Parameters interface for SubscriptionTopicParams.
func (p SubscriptionTopicParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.DerivedOrSelf != nil {
		m[search.ParameterKey{Name: "derived-or-self"}] = p.DerivedOrSelf.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Resource != nil {
		m[search.ParameterKey{Name: "resource"}] = p.Resource.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Title != nil {
		m[search.ParameterKey{Name: "title"}] = p.Title.MatchesAll()
	}
	if p.TriggerDescription != nil {
		m[search.ParameterKey{Name: "trigger-description"}] = p.TriggerDescription.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}

	return m
}

// SubstanceParams contains typed search parameters for Substance resources.
type SubstanceParams struct {
	// Substance-specific search parameters
	Category            search.TokenOrString     `json:"category,omitempty"`
	Code                search.TokenOrString     `json:"code,omitempty"`
	ContainerIdentifier search.TokenOrString     `json:"container-identifier,omitempty"`
	Expiry              search.DateOrString      `json:"expiry,omitempty"`
	Identifier          search.TokenOrString     `json:"identifier,omitempty"`
	Quantity            search.QuantityOrString  `json:"quantity,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	SubstanceReference  search.ReferenceOrString `json:"substance-reference,omitempty"`
}

// Map implements the search.Parameters interface for SubstanceParams.
func (p SubstanceParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Category != nil {
		m[search.ParameterKey{Name: "category"}] = p.Category.MatchesAll()
	}
	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.ContainerIdentifier != nil {
		m[search.ParameterKey{Name: "container-identifier"}] = p.ContainerIdentifier.MatchesAll()
	}
	if p.Expiry != nil {
		m[search.ParameterKey{Name: "expiry"}] = p.Expiry.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Quantity != nil {
		m[search.ParameterKey{Name: "quantity"}] = p.Quantity.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.SubstanceReference != nil {
		m[search.ParameterKey{Name: "substance-reference"}] = p.SubstanceReference.MatchesAll()
	}

	return m
}

// SubstanceDefinitionParams contains typed search parameters for SubstanceDefinition resources.
type SubstanceDefinitionParams struct {
	// SubstanceDefinition-specific search parameters
	Classification search.TokenOrString  `json:"classification,omitempty"`
	Code           search.TokenOrString  `json:"code,omitempty"`
	Domain         search.TokenOrString  `json:"domain,omitempty"`
	Identifier     search.TokenOrString  `json:"identifier,omitempty"`
	Name           search.StringOrString `json:"name,omitempty"`
}

// Map implements the search.Parameters interface for SubstanceDefinitionParams.
func (p SubstanceDefinitionParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Classification != nil {
		m[search.ParameterKey{Name: "classification"}] = p.Classification.MatchesAll()
	}
	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.Domain != nil {
		m[search.ParameterKey{Name: "domain"}] = p.Domain.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}

	return m
}

// SupplyDeliveryParams contains typed search parameters for SupplyDelivery resources.
type SupplyDeliveryParams struct {
	// SupplyDelivery-specific search parameters
	Identifier search.TokenOrString     `json:"identifier,omitempty"`
	Patient    search.ReferenceOrString `json:"patient,omitempty"`
	Receiver   search.ReferenceOrString `json:"receiver,omitempty"`
	Status     search.TokenOrString     `json:"status,omitempty"`
	Supplier   search.ReferenceOrString `json:"supplier,omitempty"`
}

// Map implements the search.Parameters interface for SupplyDeliveryParams.
func (p SupplyDeliveryParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Receiver != nil {
		m[search.ParameterKey{Name: "receiver"}] = p.Receiver.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Supplier != nil {
		m[search.ParameterKey{Name: "supplier"}] = p.Supplier.MatchesAll()
	}

	return m
}

// SupplyRequestParams contains typed search parameters for SupplyRequest resources.
type SupplyRequestParams struct {
	// SupplyRequest-specific search parameters
	Date       search.DateOrString      `json:"date,omitempty"`
	Identifier search.TokenOrString     `json:"identifier,omitempty"`
	Category   search.TokenOrString     `json:"category,omitempty"`
	Requester  search.ReferenceOrString `json:"requester,omitempty"`
	Status     search.TokenOrString     `json:"status,omitempty"`
	Subject    search.ReferenceOrString `json:"subject,omitempty"`
	Supplier   search.ReferenceOrString `json:"supplier,omitempty"`
}

// Map implements the search.Parameters interface for SupplyRequestParams.
func (p SupplyRequestParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Category != nil {
		m[search.ParameterKey{Name: "category"}] = p.Category.MatchesAll()
	}
	if p.Requester != nil {
		m[search.ParameterKey{Name: "requester"}] = p.Requester.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}
	if p.Supplier != nil {
		m[search.ParameterKey{Name: "supplier"}] = p.Supplier.MatchesAll()
	}

	return m
}

// TaskParams contains typed search parameters for Task resources.
type TaskParams struct {
	// Task-specific search parameters
	AuthoredOn      search.DateOrString      `json:"authored-on,omitempty"`
	BasedOn         search.ReferenceOrString `json:"based-on,omitempty"`
	BusinessStatus  search.TokenOrString     `json:"business-status,omitempty"`
	Code            search.TokenOrString     `json:"code,omitempty"`
	Encounter       search.ReferenceOrString `json:"encounter,omitempty"`
	Focus           search.ReferenceOrString `json:"focus,omitempty"`
	GroupIdentifier search.TokenOrString     `json:"group-identifier,omitempty"`
	Identifier      search.TokenOrString     `json:"identifier,omitempty"`
	Intent          search.TokenOrString     `json:"intent,omitempty"`
	Modified        search.DateOrString      `json:"modified,omitempty"`
	Owner           search.ReferenceOrString `json:"owner,omitempty"`
	PartOf          search.ReferenceOrString `json:"part-of,omitempty"`
	Patient         search.ReferenceOrString `json:"patient,omitempty"`
	Performer       search.TokenOrString     `json:"performer,omitempty"`
	Period          search.DateOrString      `json:"period,omitempty"`
	Priority        search.TokenOrString     `json:"priority,omitempty"`
	Requester       search.ReferenceOrString `json:"requester,omitempty"`
	Status          search.TokenOrString     `json:"status,omitempty"`
	Subject         search.ReferenceOrString `json:"subject,omitempty"`
}

// Map implements the search.Parameters interface for TaskParams.
func (p TaskParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.AuthoredOn != nil {
		m[search.ParameterKey{Name: "authored-on"}] = p.AuthoredOn.MatchesAll()
	}
	if p.BasedOn != nil {
		m[search.ParameterKey{Name: "based-on"}] = p.BasedOn.MatchesAll()
	}
	if p.BusinessStatus != nil {
		m[search.ParameterKey{Name: "business-status"}] = p.BusinessStatus.MatchesAll()
	}
	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.Encounter != nil {
		m[search.ParameterKey{Name: "encounter"}] = p.Encounter.MatchesAll()
	}
	if p.Focus != nil {
		m[search.ParameterKey{Name: "focus"}] = p.Focus.MatchesAll()
	}
	if p.GroupIdentifier != nil {
		m[search.ParameterKey{Name: "group-identifier"}] = p.GroupIdentifier.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Intent != nil {
		m[search.ParameterKey{Name: "intent"}] = p.Intent.MatchesAll()
	}
	if p.Modified != nil {
		m[search.ParameterKey{Name: "modified"}] = p.Modified.MatchesAll()
	}
	if p.Owner != nil {
		m[search.ParameterKey{Name: "owner"}] = p.Owner.MatchesAll()
	}
	if p.PartOf != nil {
		m[search.ParameterKey{Name: "part-of"}] = p.PartOf.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Performer != nil {
		m[search.ParameterKey{Name: "performer"}] = p.Performer.MatchesAll()
	}
	if p.Period != nil {
		m[search.ParameterKey{Name: "period"}] = p.Period.MatchesAll()
	}
	if p.Priority != nil {
		m[search.ParameterKey{Name: "priority"}] = p.Priority.MatchesAll()
	}
	if p.Requester != nil {
		m[search.ParameterKey{Name: "requester"}] = p.Requester.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Subject != nil {
		m[search.ParameterKey{Name: "subject"}] = p.Subject.MatchesAll()
	}

	return m
}

// TerminologyCapabilitiesParams contains typed search parameters for TerminologyCapabilities resources.
type TerminologyCapabilitiesParams struct {
	// TerminologyCapabilities-specific search parameters
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Date                search.DateOrString      `json:"date,omitempty"`
	Description         search.StringOrString    `json:"description,omitempty"`
	Jurisdiction        search.TokenOrString     `json:"jurisdiction,omitempty"`
	Name                search.StringOrString    `json:"name,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	Title               search.StringOrString    `json:"title,omitempty"`
	Url                 search.UriOrString       `json:"url,omitempty"`
	Version             search.TokenOrString     `json:"version,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
}

// Map implements the search.Parameters interface for TerminologyCapabilitiesParams.
func (p TerminologyCapabilitiesParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Jurisdiction != nil {
		m[search.ParameterKey{Name: "jurisdiction"}] = p.Jurisdiction.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Title != nil {
		m[search.ParameterKey{Name: "title"}] = p.Title.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}

	return m
}

// TestReportParams contains typed search parameters for TestReport resources.
type TestReportParams struct {
	// TestReport-specific search parameters
	Identifier  search.TokenOrString     `json:"identifier,omitempty"`
	Issued      search.DateOrString      `json:"issued,omitempty"`
	Participant search.UriOrString       `json:"participant,omitempty"`
	Result      search.TokenOrString     `json:"result,omitempty"`
	Tester      search.StringOrString    `json:"tester,omitempty"`
	Testscript  search.ReferenceOrString `json:"testscript,omitempty"`
}

// Map implements the search.Parameters interface for TestReportParams.
func (p TestReportParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Issued != nil {
		m[search.ParameterKey{Name: "issued"}] = p.Issued.MatchesAll()
	}
	if p.Participant != nil {
		m[search.ParameterKey{Name: "participant"}] = p.Participant.MatchesAll()
	}
	if p.Result != nil {
		m[search.ParameterKey{Name: "result"}] = p.Result.MatchesAll()
	}
	if p.Tester != nil {
		m[search.ParameterKey{Name: "tester"}] = p.Tester.MatchesAll()
	}
	if p.Testscript != nil {
		m[search.ParameterKey{Name: "testscript"}] = p.Testscript.MatchesAll()
	}

	return m
}

// TestScriptParams contains typed search parameters for TestScript resources.
type TestScriptParams struct {
	// TestScript-specific search parameters
	Context              search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity      search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType          search.TokenOrString     `json:"context-type,omitempty"`
	Date                 search.DateOrString      `json:"date,omitempty"`
	Description          search.StringOrString    `json:"description,omitempty"`
	Identifier           search.TokenOrString     `json:"identifier,omitempty"`
	Jurisdiction         search.TokenOrString     `json:"jurisdiction,omitempty"`
	Name                 search.StringOrString    `json:"name,omitempty"`
	Publisher            search.StringOrString    `json:"publisher,omitempty"`
	Status               search.TokenOrString     `json:"status,omitempty"`
	TestscriptCapability search.StringOrString    `json:"testscript-capability,omitempty"`
	Title                search.StringOrString    `json:"title,omitempty"`
	Url                  search.UriOrString       `json:"url,omitempty"`
	Version              search.TokenOrString     `json:"version,omitempty"`
	ContextTypeQuantity  search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue     search.CompositeOrString `json:"context-type-value,omitempty"`
}

// Map implements the search.Parameters interface for TestScriptParams.
func (p TestScriptParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Jurisdiction != nil {
		m[search.ParameterKey{Name: "jurisdiction"}] = p.Jurisdiction.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.TestscriptCapability != nil {
		m[search.ParameterKey{Name: "testscript-capability"}] = p.TestscriptCapability.MatchesAll()
	}
	if p.Title != nil {
		m[search.ParameterKey{Name: "title"}] = p.Title.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}

	return m
}

// ValueSetParams contains typed search parameters for ValueSet resources.
type ValueSetParams struct {
	// ValueSet-specific search parameters
	Context             search.TokenOrString     `json:"context,omitempty"`
	ContextQuantity     search.QuantityOrString  `json:"context-quantity,omitempty"`
	ContextType         search.TokenOrString     `json:"context-type,omitempty"`
	Date                search.DateOrString      `json:"date,omitempty"`
	Description         search.StringOrString    `json:"description,omitempty"`
	Jurisdiction        search.TokenOrString     `json:"jurisdiction,omitempty"`
	Name                search.StringOrString    `json:"name,omitempty"`
	Publisher           search.StringOrString    `json:"publisher,omitempty"`
	Status              search.TokenOrString     `json:"status,omitempty"`
	Title               search.StringOrString    `json:"title,omitempty"`
	Url                 search.UriOrString       `json:"url,omitempty"`
	Version             search.TokenOrString     `json:"version,omitempty"`
	ContextTypeQuantity search.CompositeOrString `json:"context-type-quantity,omitempty"`
	ContextTypeValue    search.CompositeOrString `json:"context-type-value,omitempty"`
	Identifier          search.TokenOrString     `json:"identifier,omitempty"`
	Code                search.TokenOrString     `json:"code,omitempty"`
	Expansion           search.UriOrString       `json:"expansion,omitempty"`
	Reference           search.UriOrString       `json:"reference,omitempty"`
}

// Map implements the search.Parameters interface for ValueSetParams.
func (p ValueSetParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Context != nil {
		m[search.ParameterKey{Name: "context"}] = p.Context.MatchesAll()
	}
	if p.ContextQuantity != nil {
		m[search.ParameterKey{Name: "context-quantity"}] = p.ContextQuantity.MatchesAll()
	}
	if p.ContextType != nil {
		m[search.ParameterKey{Name: "context-type"}] = p.ContextType.MatchesAll()
	}
	if p.Date != nil {
		m[search.ParameterKey{Name: "date"}] = p.Date.MatchesAll()
	}
	if p.Description != nil {
		m[search.ParameterKey{Name: "description"}] = p.Description.MatchesAll()
	}
	if p.Jurisdiction != nil {
		m[search.ParameterKey{Name: "jurisdiction"}] = p.Jurisdiction.MatchesAll()
	}
	if p.Name != nil {
		m[search.ParameterKey{Name: "name"}] = p.Name.MatchesAll()
	}
	if p.Publisher != nil {
		m[search.ParameterKey{Name: "publisher"}] = p.Publisher.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}
	if p.Title != nil {
		m[search.ParameterKey{Name: "title"}] = p.Title.MatchesAll()
	}
	if p.Url != nil {
		m[search.ParameterKey{Name: "url"}] = p.Url.MatchesAll()
	}
	if p.Version != nil {
		m[search.ParameterKey{Name: "version"}] = p.Version.MatchesAll()
	}
	if p.ContextTypeQuantity != nil {
		m[search.ParameterKey{Name: "context-type-quantity"}] = p.ContextTypeQuantity.MatchesAll()
	}
	if p.ContextTypeValue != nil {
		m[search.ParameterKey{Name: "context-type-value"}] = p.ContextTypeValue.MatchesAll()
	}
	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Code != nil {
		m[search.ParameterKey{Name: "code"}] = p.Code.MatchesAll()
	}
	if p.Expansion != nil {
		m[search.ParameterKey{Name: "expansion"}] = p.Expansion.MatchesAll()
	}
	if p.Reference != nil {
		m[search.ParameterKey{Name: "reference"}] = p.Reference.MatchesAll()
	}

	return m
}

// VerificationResultParams contains typed search parameters for VerificationResult resources.
type VerificationResultParams struct {
	// VerificationResult-specific search parameters
	Target search.ReferenceOrString `json:"target,omitempty"`
}

// Map implements the search.Parameters interface for VerificationResultParams.
func (p VerificationResultParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Target != nil {
		m[search.ParameterKey{Name: "target"}] = p.Target.MatchesAll()
	}

	return m
}

// VisionPrescriptionParams contains typed search parameters for VisionPrescription resources.
type VisionPrescriptionParams struct {
	// VisionPrescription-specific search parameters
	Identifier  search.TokenOrString     `json:"identifier,omitempty"`
	Patient     search.ReferenceOrString `json:"patient,omitempty"`
	Encounter   search.ReferenceOrString `json:"encounter,omitempty"`
	Datewritten search.DateOrString      `json:"datewritten,omitempty"`
	Prescriber  search.ReferenceOrString `json:"prescriber,omitempty"`
	Status      search.TokenOrString     `json:"status,omitempty"`
}

// Map implements the search.Parameters interface for VisionPrescriptionParams.
func (p VisionPrescriptionParams) Map() map[search.ParameterKey]search.MatchAll {
	m := make(map[search.ParameterKey]search.MatchAll)

	if p.Identifier != nil {
		m[search.ParameterKey{Name: "identifier"}] = p.Identifier.MatchesAll()
	}
	if p.Patient != nil {
		m[search.ParameterKey{Name: "patient"}] = p.Patient.MatchesAll()
	}
	if p.Encounter != nil {
		m[search.ParameterKey{Name: "encounter"}] = p.Encounter.MatchesAll()
	}
	if p.Datewritten != nil {
		m[search.ParameterKey{Name: "datewritten"}] = p.Datewritten.MatchesAll()
	}
	if p.Prescriber != nil {
		m[search.ParameterKey{Name: "prescriber"}] = p.Prescriber.MatchesAll()
	}
	if p.Status != nil {
		m[search.ParameterKey{Name: "status"}] = p.Status.MatchesAll()
	}

	return m
}
